<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":true,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-3001225672102099",
    enable_page_level_ads: true
  });
</script>


  



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "3a22f8cc"
    });
  daovoice('update');
  </script>



  <meta name="description" content="第1章 了解SQL 数据库软件应称为DBMS（数据库管理系统）。  数据库是通过DBMS创建和操纵的容器。  在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。  模式（schema）： 关于数据库和表的布局及特性的信息。  有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。  主键（primary">
<meta name="keywords" content="MySQL,SQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL必知必会">
<meta property="og:url" content="https://hunter1023.github.io/2020/06/14/MySQL必知必会/index.html">
<meta property="og:site_name" content="特叔服务">
<meta property="og:description" content="第1章 了解SQL 数据库软件应称为DBMS（数据库管理系统）。  数据库是通过DBMS创建和操纵的容器。  在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。  模式（schema）： 关于数据库和表的布局及特性的信息。  有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。  主键（primary">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-06-21T12:37:40.247Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL必知必会">
<meta name="twitter:description" content="第1章 了解SQL 数据库软件应称为DBMS（数据库管理系统）。  数据库是通过DBMS创建和操纵的容器。  在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。  模式（schema）： 关于数据库和表的布局及特性的信息。  有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。  主键（primary">






  <link rel="canonical" href="https://hunter1023.github.io/2020/06/14/MySQL必知必会/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>MySQL必知必会 | 特叔服务</title>
  




  <script async src="//www.googletagmanager.com/gtag/js?id=[object Object]"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-121247993-1');
    }
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">特叔服务</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/06/14/MySQL必知必会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hunter">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="特叔服务">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MySQL必知必会

              
            
          </h1>
        

        <div class="post-meta">
			
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-14 08:26:30" itemprop="dateCreated datePublished" datetime="2020-06-14T08:26:30+08:00">2020-06-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-21 20:37:40" itemprop="dateModified" datetime="2020-06-21T20:37:40+08:00">2020-06-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/06/14/MySQL必知必会/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/MySQL必知必会/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第1章-了解SQL"><a href="#第1章-了解SQL" class="headerlink" title="第1章 了解SQL"></a>第1章 了解SQL</h2><ul>
<li><p>数据库软件应称为DBMS（数据库管理系统）。</p>
</li>
<li><p>数据库是通过DBMS创建和操纵的容器。</p>
</li>
<li><p>在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。</p>
</li>
<li><p>模式（schema）： 关于<strong>数据库</strong>和<strong>表</strong>的<strong>布局及特性</strong>的信息。</p>
</li>
<li><p>有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。</p>
</li>
<li><p>主键（primary key）</p>
</li>
<li><p>SQL（发音为字母S-Q-L或sequel）是<strong>结构化查询语言（Structured Query Language）</strong>的缩写。</p>
</li>
</ul>
<h2 id="第2章-MySQL简介"><a href="#第2章-MySQL简介" class="headerlink" title="第2章 MySQL简介"></a>第2章 MySQL简介</h2><ul>
<li>DBMS可分为两类：一类为<strong>基于共享文件系统</strong>的DBMS，另一类为<strong>基于客户机——服务器</strong>的DBMS。前者（包括诸如<strong>Microsoft Access</strong>和<strong>FileMaker</strong>）用于<strong>桌面用途</strong>，通常不用于高端或更关键的应用。</li>
<li>MySQL、Oracle以及Microsoft SQL Server等数据库是基于客户机——服务器的数据库。客户机—服务器应用分为两个不同的部分。<strong>服务器</strong>部分是负责<strong>所有数据访问和处理</strong>的一个软件。</li>
<li>为进行所有数据库交互，客户机软件都要与服务器软件进行通信。</li>
<li>每个MySQL安装都有一个名为mysql的简单命令行实用程序。</li>
</ul>
<hr>
<h3 id="配置MySQL环境变量"><a href="#配置MySQL环境变量" class="headerlink" title="配置MySQL环境变量"></a>配置MySQL环境变量</h3><ul>
<li><code>Win</code> + <code>Pause Break</code> 打开<strong>系统</strong>窗口。</li>
<li>高级系统设置 - 高级 - 环境变量 - 系统变量</li>
<li>找到<strong>Path</strong>，点击<strong>编辑</strong> - 浏览</li>
<li>选择MySQL安装目录下的bin文件夹所在路径，默认路径为<code>C:\Program Files\MySQL\MySQL Server 5.7\bin</code></li>
<li>一路确定，即完成环境变量的配置。此时打开命令行窗口，即通过<code>mysql -u -root -p</code>命令并输入密码后访问数据库。</li>
</ul>
<hr>
<h3 id="统一字符集为UTF-8"><a href="#统一字符集为UTF-8" class="headerlink" title="统一字符集为UTF-8"></a>统一字符集为UTF-8</h3><p>为了中文字符的顺利存储，需要将数据库的字符集统一为UTF-8。</p>
<p>修改<code>C:\ProgramData\MySQL\MySQL Server 5.7\my.ini</code>：</p>
<ul>
<li><p>找到<code>[mysql]</code></p>
<p>在下方添加<code>default-character-set=utf8</code></p>
</li>
<li><p>找到<code>[mysqld]</code></p>
<p>在下方添加<code>character-set-server=utf8</code></p>
</li>
<li><p>找到<code>[client]</code></p>
<p>在下方添加<code>default-character-set=utf8</code></p>
</li>
</ul>
<hr>
<ul>
<li>在操作系统命令提示符下输入mysql将出现一个如下的简单提示：<ul>
<li>为了指定<strong>用户登录名</strong>ben，应该使用<code>mysql -u ben</code>。为了给出<strong>用户名</strong>、<strong>主机名</strong>、<strong>端口</strong>和<strong>口令</strong>，应该使用<code>mysql -u ben -p -h myserver -P 9999</code>。<strong>完整的命令行选项和参数列表</strong>可用<code>mysql --help</code>获得。</li>
</ul>
</li>
<li>命令用<code>；</code>或<code>\g</code><strong>结束</strong>，换句话说，<strong>仅按Enter不执行命令</strong>；</li>
<li>输入<code>quit</code>或<code>exit</code><strong>退出命令行实用程序</strong>。</li>
</ul>
<h2 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h2><ul>
<li><p>在最初安装MySQL时，很可能会要求你输入一个管理登录（通常为root）和一个口令。如果你使用的是自己的本地服务器，并且是简单地试验一下MySQL，使用上述登录就可以了。但现实中，管理登录受到密切保护</p>
</li>
<li><p>在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作前，需要选择一个数据库。为此，可使用<strong>USE关键字</strong>。</p>
</li>
<li><p>决不要用<strong>关键字</strong>命名一个表或列。附录E列出了MySQL的关键字。</p>
</li>
<li><p><strong>USE语句</strong>并不返回任何结果。依赖于使用的客户机，显示某种形式的通知。例如，这里显示出的Database changed消息是mysql命令行实用程序在数据库选择成功后显示的。</p>
</li>
<li><p>双击Schemata列表中列出的任一数据库以使用它。你看不到USE命令的实际执行，但会看到被选择的数据库（黑体加亮），而且应用标题栏将显示所选择的数据库名。</p>
</li>
<li><p>必须先使用USE打开数据库，才能读取其中的数据。</p>
</li>
<li><p>数据库、表、列、用户、权限等的信息被存储在数据库和表中（MySQL使用MySQL来存储这些信息）</p>
</li>
<li><p>可用MySQL的<strong>SHOW命令</strong>来显示这些信息（MySQL从内部表中提取这些信息）</p>
<ul>
<li><p><code>SHOW DATABASES;</code></p>
<p>返回<strong>可用数据库</strong>的一个列表。包含在这个列表中的可能是MySQL内部使用的数据库</p>
</li>
<li><p><code>SHOW TABLES;</code></p>
<p>获得<strong>当前选择的数据库内可用表</strong></p>
</li>
<li><p><code>SHOW COLUMNS FROM xxx;</code></p>
<p>要求给出一个表名，<strong>显示对应的所有表列及其具体属性</strong></p>
<p><code>DESCRIBE customers;</code>是<code>SHOW COLUMNS FROM customers;</code>的一种<strong>快捷方式</strong>。</p>
</li>
<li><p><code>SHOW STATUS;</code></p>
<p>用于显示广泛的<strong>服务器状态</strong>信息</p>
</li>
<li><p><code>SHOW CREATE DATABASE;</code>和<code>SHOW CREATE TABLE;</code></p>
<p>分别用来显示<strong>创建特定数据库或表的MySQL语句</strong>。</p>
</li>
<li><p><code>SHOW GRANTS;</code></p>
<p>用来<strong>显示授予用户（所有用户或特定用户）的安全权限</strong>；</p>
</li>
<li><p><code>SHOW ERRORS;</code>和<code>SHOW WARNINGS;</code></p>
<p>用来<strong>显示服务器错误</strong>或<strong>警告消息</strong>。 </p>
</li>
</ul>
</li>
<li><p><strong>自动增量</strong>：</p>
<p>在<strong>每个行添加到表中</strong>时，MySQL可以<strong>自动地为每个行分配下一个可用编号</strong>，<strong>不用在添加一行时手动分配唯一值</strong>。如果需要它，则必须在<strong>用CREATE语句创建表时</strong>把它作为<strong>表定义的组成部分</strong>。</p>
</li>
</ul>
<blockquote>
<p>MySQL 5支持一个新的INFORMA-TION_SCHEMA命令，可用它来获得和过滤模式信息。</p>
</blockquote>
<ul>
<li>M有SQL用<code>#</code>标记<strong>注释</strong></li>
</ul>
<h2 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h2><blockquote>
<p>。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名</p>
</blockquote>
<blockquote>
<p>如果没有明确排序查询结果（下一章介绍），则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。</p>
</blockquote>
<blockquote>
<p>多条SQL语句必须以分号（;）分隔。MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号</p>
</blockquote>
<blockquote>
<p>即使不一定需要，但加上分号肯定没有坏处</p>
</blockquote>
<blockquote>
<p>如果你使用的是mysql命令行，必须加上分号来结束SQL语句</p>
</blockquote>
<blockquote>
<p>，SQL语句不区分大小写</p>
</blockquote>
<blockquote>
<p>。许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。</p>
</blockquote>
<blockquote>
<p>在SELECT关键字后给出多个列名，列名之间必须以逗号分隔。</p>
</blockquote>
<blockquote>
<p>但最后一个列名后不加。如果在最后一个列名后加了逗号，将出现错误。</p>
</blockquote>
<blockquote>
<p>SQL语句一般返回原始的、无格式的数据。数据的格式化是一个表示问题，而不是一个检索问题</p>
</blockquote>
<blockquote>
<p>SELECT语句还可以检索所有的列而不必逐个列出它们。这可以通过在实际列名的位置使用星号（*）通配符来达到</p>
</blockquote>
<blockquote>
<p>列的顺序一般是列在表定义中出现的顺序。但有时候并不是这样的，表的模式的变化（如添加或删除列）可能会导致顺序的变化。</p>
</blockquote>
<blockquote>
<p>虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。</p>
</blockquote>
<blockquote>
<p>避免相同内容重复显示如何检索出有不同值的列表呢？<br>解决办法是使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。</p>
</blockquote>
<blockquote>
<p>如何检索出有不同值的列表呢？解决办法是使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。</p>
</blockquote>
<blockquote>
<p>DISTINCT 只作用于当前列，与逗号之后的列无关不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列</p>
</blockquote>
<blockquote>
<p>不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列</p>
</blockquote>
<blockquote>
<p>SELECT语句返回所有匹配的行</p>
</blockquote>
<blockquote>
<p>为了返回第一行或前几行，可使用LIMIT子句。</p>
</blockquote>
<blockquote>
<p>LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数</p>
</blockquote>
<blockquote>
<p>所以，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。</p>
</blockquote>
<blockquote>
<p>检索出来的第一行为行0而不是行1</p>
</blockquote>
<blockquote>
<p>MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。</p>
</blockquote>
<blockquote>
<p>也可能会使用完全限定的名字来引用列（同时使用表名和列字）</p>
</blockquote>
<blockquote>
<p>表名也可以是完全限定</p>
</blockquote>
<h2 id="第5章-排序检索数据"><a href="#第5章-排序检索数据" class="headerlink" title="第5章 排序检索数据"></a>第5章 排序检索数据</h2><ul>
<li><p>关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义</p>
</li>
<li><p>为了明确地<strong>排序</strong>用SELECT语句检索出的数据，可使用<strong>ORDER BY</strong>子句</p>
</li>
<li><p>取一个或多个列的名字，据此对输出进行排序</p>
</li>
<li><p>也可以<strong>通过非选择列进行排序</strong>：</p>
</li>
<li><p>为了按<strong>多个列</strong>排序，只要<strong>指定列名</strong>，列名之间<strong>用逗号分开</strong>即可（就像选择多个列时所做的那样）</p>
</li>
<li><p>在按多个列排序时，排序完全按所规定的顺序进行</p>
</li>
<li><p><strong>升序</strong>排序（从A到Z）。这只是<strong>默认</strong>的排序顺序</p>
</li>
<li><p>为了进行<strong>降序</strong>排序，必须指定<strong>DESC</strong>关键字</p>
</li>
<li><p><strong>DESC</strong>关键字<strong>只应用到直接位于其前面</strong>的列名</p>
</li>
<li><p>如果想在多个列上进行降序排序，<strong>必须对每个列指定DESC关键字</strong>。</p>
</li>
<li><p>在字典（dictionary）排序顺序中，<strong>A被视为与a相同</strong>，这是<strong>MySQL</strong>（和大多数DBMS）的<strong>默认</strong>行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。</p>
</li>
<li><p>如果使用<strong>LIMIT</strong>，它<strong>必须位于ORDER BY之后</strong>。使用子句的次序不对将产生错误消息。</p>
</li>
</ul>
<h2 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h2><blockquote>
<p>只检索所需数据需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）。在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名（FROM子句）之后给出</p>
</blockquote>
<blockquote>
<p>应该让ORDER BY位于WHERE之后，否则将会产生错误</p>
</blockquote>
<ul>
<li><p>MySQL支持下列所有条件操作符：</p>
<p>| 操作符    | 说明                   |<br>| ——— | ———————- |<br>| <code>=</code>       | 等于                   |<br>| <code>&lt;&gt;</code>/<code>!=</code> | <strong>不等于</strong>             |<br>| <code>&lt;</code>       | 小于                   |<br>| <code>&lt;=</code>      | 小于等于               |<br>| <code>&gt;</code>       | 大于                   |<br>| <code>&gt;=</code>      | 大于等于               |<br>| <code>BETWEEN</code> | <strong>在指定的两个值之间</strong> |</p>
</li>
</ul>
<ul>
<li>MySQL在<strong>执行匹配时</strong>默认<strong>不区分大小写</strong></li>
</ul>
<blockquote>
<p>不匹配检查以下例子列出不是由供应商1003制造的所有产品：</p>
</blockquote>
<ul>
<li><p><strong>单引号</strong>用来<strong>限定字符串</strong>。(Python既可以用单引号，也可以用双引号)</p>
</li>
<li><p>在使用<code>BETWEEN</code>时，必须<strong>指定两个值</strong>——所需范围的低端值和高端值。<strong>这两个值必须用AND关键字分隔</strong>。BETWEEN匹配范围中所有的值，<strong>包括指定的开始值</strong>和<strong>结束值</strong>。</p>
</li>
<li><p>SELECT语句有一个特殊的WHERE子句，可用来<strong>检查具有NULL值的列</strong>。这个WHERE子句就是<strong>IS NULL子句</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在通过过滤选择出不具有特定值的行时，<strong>你可能希望返回具有NULL值的行，但是，不行</strong>。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。</p>
</li>
</ul>
<h2 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h2><h3 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h3><ul>
<li>MySQL允许给出多个WHERE子句。这些子句可以两种方式使用：以<strong>AND子句</strong>的方式或<strong>OR子句</strong>的方式使用。</li>
</ul>
<h4 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h4><ul>
<li><p>SQL（像多数语言一样）<strong>在处理OR操作符前，优先处理AND操作符</strong>，为了使机器能够理解，应<strong>使用圆括号明确地分组相应的操作符</strong>。如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SLECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>任何时候</strong>使用具有<strong>AND</strong>和<strong>OR</strong>操作符的WHERE子句，<strong>都应该使用圆括号明确地分组操作符</strong>，消除歧义。</p>
</li>
</ul>
<hr>
<h3 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h3><ul>
<li><p>IN操作符后跟<strong>由逗号分隔</strong>的合法值清单，<strong>整个清单必须括在圆括号中</strong>。<strong>IN操作符完成与OR相同的功能</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么要使用IN操作符？其优点具体如下。</p>
<ol>
<li>在使用<strong>长的合法选项清单</strong>时，IN操作符的<strong>语法更清楚且更直观</strong>。</li>
<li>在使用IN时，<strong>计算的次序更容易管理</strong>（因为<strong>使用的操作符更少</strong>）。</li>
<li>IN操作符<strong>一般比OR操作符清单执行更快</strong>。</li>
<li>IN的最大优点是<strong>可以包含其他SELECT语句</strong>，使得<strong>能够更动态地建立WHERE子句</strong>。第14章将对此进行详细介绍。</li>
</ol>
</li>
</ul>
<h3 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h3><ul>
<li><p>NOT操作符有且只有一个功能，那就是<strong>否定它之后所跟的任何条件</strong>。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，<strong>在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单</strong>。</p>
</li>
<li><p>MySQL支持使用NOT对IN、BETWEEN和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。</p>
</li>
</ul>
<h2 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h2><h3 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h3><ul>
<li><p>怎样搜索<strong>产品名中包含文本anvil</strong>的所有产品？用简单的比较操作符肯定不行，<strong>必须使用通配符</strong>。利用通配符可创建比较特定数据的搜索模式</p>
</li>
<li><p><strong>搜索模式</strong>（<strong>search pattern</strong>）：</p>
<p>由<strong>字面值</strong>、<strong>通配符</strong>或<strong>两者组合构成的搜索条件</strong></p>
</li>
<li><p>通配符本身实际是SQL的WHERE子句中<strong>有特殊含义的字符</strong>，SQL支持几种通配符。</p>
</li>
<li><p>为在搜索子句中使用通配符，必须使用<strong>LIKE操作符</strong>。LIKE指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。</p>
</li>
<li><p>操作符何时不是操作符？答案是在它作为谓词（<strong>predi-cate</strong>）时。<strong>从技术上说，LIKE是谓词而不是操作符</strong>。虽然最终的结果是相同的，但应该对此术语有所了解，以免在SQL文档中遇到此术语时不知道。</p>
</li>
</ul>
<h4 id="百分号-通配符"><a href="#百分号-通配符" class="headerlink" title="百分号(%)通配符"></a>百分号(%)通配符</h4><ul>
<li><p>最常使用的通配符是百分号（%）。在搜索串中，<strong>%表示任何字符出现任意次数</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>| prod_id | prod_name    |<br>| ——- | ———— |<br>| JP1000  | JetPack 1000 |<br>| JP2000  | JetPack 2000 |</p>
</li>
<li><p>根据MySQL的配置方式，<strong>搜索可以是区分大小写的</strong>。如果区分大小写，<code>&#39;jet%&#39;</code>与JetPack 1000将不匹配。</p>
</li>
<li><p>通配符<strong>可以在搜索模式中任意位置使用</strong>，并且<strong>可以使用多个通配符</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'%anvil%'</span>;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>| prod_id | prod_name    |<br>| ——- | ———— |<br>| ANV01   | .5 ton anvil |<br>| ANV02   | 1 ton anvil  |<br>| ANV03   | 2 ton anvil  |</p>
</li>
</ul>
<ul>
<li><p>重要的是要注意到，<strong>除了一个或多个字符外，%还能匹配0个字符</strong>。<strong>%代表搜索模式中给定位置的0个、1个或多个字符</strong>。</p>
</li>
<li><p>注意<strong>尾空格</strong>：</p>
<p>尾空格可能会<strong>干扰通配符匹配</strong>。例如，在保存词anvil时，如果它后面有一个或多个空格，则子句WHERE prod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l后有多余的字符。<strong>解决这个问题的一个简单的办法是在搜索模式最后附加一个%</strong>。一个<strong>更好的办法是使用函数</strong>（第11章将会介绍）<strong>去掉首尾空格</strong>。</p>
</li>
<li><p>虽然<strong>似乎%通配符可以匹配任何东西</strong>，但有一个例外，即<strong>NULL</strong>。<strong>即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行</strong>。</p>
</li>
</ul>
<hr>
<h4 id="下划线-通配符"><a href="#下划线-通配符" class="headerlink" title="下划线(_)通配符"></a>下划线(_)通配符</h4><ul>
<li>下划线的<strong>用途与%一样</strong>，但下划线<strong>只匹配单个字符</strong>。</li>
</ul>
<hr>
<h3 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h3><ol>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。<strong>把通配符置于搜索模式的开始处，搜索起来是最慢的</strong>。</li>
</ol>
<h2 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h2><blockquote>
<p>正则表达式是用来匹配文本的特殊的串（字符集合）</p>
</blockquote>
<blockquote>
<p>所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式</p>
</blockquote>
<blockquote>
<p>MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤SELECT检索出的数据。</p>
</blockquote>
<blockquote>
<p>：MySQL仅支持多数正则表达式实现的一个很小的子集</p>
</blockquote>
<blockquote>
<p>除关键字LIKE被REGEXP替代外，这条语句看上去非常像使用LIKE的语句（第8章）。它告诉MySQL:REGEXP后所跟的东西作为正则表达式（与文字正文1000匹配的一个正则表达式）处理。</p>
</blockquote>
<blockquote>
<p>．是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符</p>
</blockquote>
<blockquote>
<p>LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相</p>
</blockquote>
<blockquote>
<p>那么，REGEXP能不能用来匹配整个列值（从而起与LIKE相同的作用）？答案是肯定的，使用^和$定位符（anchor）即可，本章后面介绍。</p>
</blockquote>
<blockquote>
<p>MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY ‘JetPack .000’。</p>
</blockquote>
<blockquote>
<p>为搜索两个串之一（或者为这个串，或者为另一个串），使用|</p>
</blockquote>
<blockquote>
<p>2000。|为正则表达式的OR操作符。它表示匹配其中之一</p>
</blockquote>
<blockquote>
<p>‘1000 | 2000 | 3000’将匹配1000或2000或3000。</p>
</blockquote>
<blockquote>
<p>如果你只想匹配特定的字符，怎么办？可通过指定一组用[和]括起来的字符来完成</p>
</blockquote>
<blockquote>
<p>Ton。[123]定义一组字符，它的意思是匹配1或2或3</p>
</blockquote>
<blockquote>
<p>正如所见，[]是另一种形式的OR语句。事实上，正则表达式[123]Ton为[1|2|3]Ton的缩写，也可以使用后者</p>
</blockquote>
<blockquote>
<p>需要用[]来定义OR语句查找什么。</p>
</blockquote>
<blockquote>
<p>字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。因此，尽管[123]匹配字符1、2或3，但[^123]却匹配除这些字符外的任何东西</p>
</blockquote>
<blockquote>
<p>，下面的集合将匹配数字0到9：[0123456789]为简化这种类型的集合，可使用-来定义一个范围。下面的式子功能上等同于上述数字列表：[0-9]</p>
</blockquote>
<blockquote>
<p>范围不限于完整的集合，[1-3]和[6-9]也是合法的范围。此外，范围不一定只是数值的，[a-z]匹配任意字母字符。</p>
</blockquote>
<blockquote>
<p>为了匹配特殊字符，必须用\为前导。\-表示查找-, \．表示查找．。</p>
</blockquote>
<blockquote>
<p>\．匹配．，所以只检索出一行。这种处理就是所谓的转义（escaping），正则表达式内具有特殊意义的所有字符都必须以这种方式转义。</p>
</blockquote>
<blockquote>
<p> 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。</p>
</blockquote>
<blockquote>
<p> 匹配字符类</p>
</blockquote>
<blockquote>
<p>为更方便工作，可以使用预定义的字符集，称为字符类（character class）。表9-2列出字符类以及它们的含义。</p>
</blockquote>
<blockquote>
<p>你可能需要寻找所有的数，不管数中包含多少数字，或者你可能想寻找一个单词并且还能够适应一个尾随的s（如果存在），等等。这可以用表9-3列出的正则表达式重复元字符来完成。</p>
</blockquote>
<blockquote>
<p>sticks？匹配stick和sticks（s后的？使s可选，因为？匹配它前面的任何字符的0次或1次出现）</p>
</blockquote>
<blockquote>
<p>没有？，匹配stick和sticks会非常困难。</p>
</blockquote>
<blockquote>
<p>以下是另一个例子。这次我们打算匹配连在一起的4位数字：</p>
</blockquote>
<blockquote>
<p>需要注意的是，在使用正则表达式时，编写某个特殊的表达式几乎总是有不止一种方法。</p>
</blockquote>
<blockquote>
<p>为了匹配特定位置的文本，需要使用表9-4列出的定位符。</p>
</blockquote>
<blockquote>
<p>^匹配串的开始。</p>
</blockquote>
<blockquote>
<p>^的双重用途 ^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。</p>
</blockquote>
<blockquote>
<p>LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。</p>
</blockquote>
<blockquote>
<p>REGEXP检查总是返回0（没有匹配）或1（匹配）。可以用带文字串的REGEXP来测试表达式，并试验它们。相应的语法如下：</p>
</blockquote>
<h2 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h2><blockquote>
<p>与前面各章介绍过的列不同，计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。</p>
</blockquote>
<blockquote>
<p>只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的。</p>
</blockquote>
<blockquote>
<p>。在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列。</p>
</blockquote>
<blockquote>
<p> 多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。</p>
</blockquote>
<blockquote>
<p>Concat()需要一个或多个指定的串，各个串之间用逗号分隔。</p>
</blockquote>
<blockquote>
<p>在第8章中曾提到通过删除数据右侧多余的空格来整理数据，这可以使用MySQL的RTrim()函数来完成</p>
</blockquote>
<blockquote>
<p>RTrim()函数去掉值右边的所有空格。通过使用RTrim()，各个列都进行了整理。</p>
</blockquote>
<blockquote>
<p>MySQL除了支持RTrim()（正如刚才所见，它去掉串右边的空格），还支持LTrim()（去掉串左边的空格）以及Trim()（去掉串左右两边的空格）。</p>
</blockquote>
<blockquote>
<p>SQL支持列别名。别名（alias）是一个字段或值的替换名。别名用AS关键字赋予。请看下面的SELECT语句：</p>
</blockquote>
<blockquote>
<p>从输出中可以看到，结果与以前的相同，但现在列名为vend_title，任何客户机应用都可以按名引用这个列，就像它是一个实际的表列一样。</p>
</blockquote>
<blockquote>
<p>别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它，等等。</p>
</blockquote>
<blockquote>
<p>别名有时也称为导出列（derived column）</p>
</blockquote>
<blockquote>
<p>MySQL支持表10-1中列出的基本算术操作符。此外，圆括号可用来区分优先顺序。</p>
</blockquote>
<blockquote>
<p>SELECT提供了测试和试验函数与计算的一个很好的办法。虽然SELECT通常用来从表中检索数据，但可以省略FROM子句以便简单地访问和处理表达式。例如，SELECT 3*2；将返回6, SELECT Trim(‘abc’)；将返回abc，而SELECT Now()利用Now()函数返回当前日期和时间。通过这些例子，可以明白如何根据需要使</p>
</blockquote>
<h2 id="第11章-使用数据处理函数"><a href="#第11章-使用数据处理函数" class="headerlink" title="第11章 使用数据处理函数"></a>第11章 使用数据处理函数</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>相对来说，多数<strong>SQL语句是可移植的</strong>，在SQL实现之间有差异时，这些差异通常不那么难处理。而<strong>函数的可移植性却不强</strong>。几乎每种主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大。</p>
</li>
<li><p>为了代码的可移植，许多SQL程序员不赞成使用特殊实现的功能。虽然这样做很有好处，但不总是利于应用程序的性能。</p>
</li>
<li><p>如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p>
</li>
</ul>
<hr>
<h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><p>大多数SQL实现支持以下类型的函数。</p>
<ol>
<li>用于<strong>处理文本串</strong>（如<strong>删除或填充值</strong>，<strong>转换值为大写或小写</strong>）的<strong>文本处理函数</strong>。</li>
<li>用于在数值数据上进行算术操作（如<strong>返回绝对值</strong>，进行<strong>代数运算</strong>）的<strong>数值函数</strong>。</li>
<li>用于<strong>处理日期</strong>和<strong>时间值</strong>并从这些值中<strong>提取特定成分</strong>（例如，返回<strong>两个日期之差</strong>，<strong>检查日期有效性</strong>等）的<strong>日期和时间函数</strong>。</li>
<li>返回DBMS正使用的特殊信息（如返回<strong>用户登录信息</strong>，<strong>检查版本细节</strong>）的<strong>系统函数</strong>。</li>
</ol>
<hr>
<h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TRIM(s)</code></td>
<td>删除字符串首尾的空格</td>
</tr>
<tr>
<td><code>LTRIM(s)</code></td>
<td>删除字符串开头的空格</td>
</tr>
<tr>
<td><code>RTRIM(s)</code></td>
<td>删除字符串末尾的空格</td>
</tr>
<tr>
<td><code>UPPER(s)</code></td>
<td>将字符串转为大写</td>
</tr>
<tr>
<td><code>LOWER(s)</code></td>
<td>将字符串转为小写</td>
</tr>
<tr>
<td><code>LENGTH(s)</code></td>
<td>获取字符串长度</td>
</tr>
<tr>
<td><code>SUBSTRING(s, start, length)</code></td>
<td>获取字符串子集</td>
</tr>
<tr>
<td><code>LEFT(s, n)</code></td>
<td>返回字符串的<strong>前n个字符</strong></td>
</tr>
<tr>
<td><code>RIGHT(s, n)</code></td>
<td>返回字符串的<strong>后n个字符</strong></td>
</tr>
<tr>
<td><code>REPLACE(s, s1, s2)</code></td>
<td>将字符串s中的<strong>子集s1替换为s2</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><p>例子：</p>
<ul>
<li>错误写法：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>, <span class="keyword">NAME</span>, <span class="keyword">LENGTH</span>(<span class="keyword">NAME</span>) <span class="keyword">AS</span> LEN_NAME</span><br><span class="line"><span class="keyword">FROM</span> world.city <span class="keyword">WHERE</span> LEN_NAME &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>city表中没有LEN_NAME列</strong>，执行会报错。</p>
<ul>
<li>正确写法：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>, <span class="keyword">NAME</span>, <span class="keyword">LENGTH</span>(<span class="keyword">NAME</span>) <span class="keyword">AS</span> LEN_NAME</span><br><span class="line"><span class="keyword">FROM</span> world.city <span class="keyword">WHERE</span> <span class="keyword">LENGTH</span>(<span class="keyword">NAME</span>) &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法</p>
</blockquote>
<blockquote>
<p>使得能对串进行发音比较而不是字母比较。</p>
</blockquote>
<blockquote>
<p>虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。</p>
</blockquote>
<blockquote>
<p>在这个例子中，WHERE子句使用Soundex()函数来转换cust_contact列值和搜索串为它们的SOUNDEX值。因为Y.Lee和Y.Lie发音相似，所以它们的SOUNDEX值匹配，因此WHERE子句正确地过滤出了所需的数据。</p>
</blockquote>
<hr>
<h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><ul>
<li>一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ADDDATE(d, n)</code></td>
<td>计算起始日期d加上n<strong>天</strong>的日期<br>如<code>SELECT ADDDATE(2017-06-15, INTERVAL 10 DAY)</code></td>
</tr>
<tr>
<td><code>ADDTIME(t, n)</code></td>
<td>时间t加上n<strong>秒</strong>的时间</td>
</tr>
<tr>
<td><code>CURDATE()</code></td>
<td>返回当前<strong>日期</strong></td>
</tr>
<tr>
<td><code>CURTIME()</code></td>
<td>返回当前<strong>时间</strong>(<strong>不含日期</strong>)</td>
</tr>
<tr>
<td><code>NOW()</code></td>
<td>返回<strong>当前日期和时间</strong></td>
</tr>
<tr>
<td><code>DATE()</code></td>
<td><strong>从日期或日期时间表达式中提取日期值</strong><br>如<code>SELECT DATE(&quot;2017-06-15&quot;)</code></td>
</tr>
<tr>
<td><code>DATEDIFF(d1, d2)</code></td>
<td>计算日期d1-&gt;d2之间<strong>相隔的天数</strong></td>
</tr>
<tr>
<td><code>TIMESTAMPDIFF(interval, datetime_expr1, datetime_expr2)</code></td>
<td>比较两个日期的时间差。<br>interval 确定时间差的<strong>单位</strong>：SECOND、MINUTE、HOUR、DAY、MONTH、YEAR<br>差值为 后一个时间参数 - 前一个时间参数</td>
</tr>
<tr>
<td><code>DATE_ADD(d, INTERVAL expr type)</code></td>
<td>计算起始日期d加上一个<strong>时间段</strong>后的日期</td>
</tr>
<tr>
<td><code>DATE_FORMAT(d, f)</code></td>
<td>按表达式f的要求显示日期d</td>
</tr>
<tr>
<td><code>DAYOFWEEK(d)</code></td>
<td>当前日期是<strong>星期几</strong></td>
</tr>
<tr>
<td><code>YEAR(d)</code></td>
<td>返回<strong>年份</strong></td>
</tr>
<tr>
<td><code>MONTH(d)</code></td>
<td>返回<strong>月份</strong></td>
</tr>
<tr>
<td><code>DAY(d)</code></td>
<td>返回日期值d的<strong>日</strong>部分</td>
</tr>
<tr>
<td><code>HOUR(t)</code></td>
<td>返回<strong>小时值</strong></td>
</tr>
<tr>
<td><code>MINuTE(t)</code></td>
<td>返回<strong>分钟值</strong></td>
</tr>
<tr>
<td><code>SECOND(t)</code></td>
<td>返回<strong>秒钟值</strong></td>
</tr>
<tr>
<td><code>TIME(expression)</code></td>
<td>提取表达式中的<strong>时间部分</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><p>数据经常需要<strong>用日期进行过滤</strong></p>
<ul>
<li><p>首先需要注意的是MySQL使用的<strong>日期格式</strong>。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，<strong>日期必须为格式yyyy-mm-dd</strong>。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它<strong>排除了多义性</strong>（如，04/05/06是2006年5月4日或2006年4月5日或2004年5月6日或……）。</p>
</li>
<li><p><strong>应该总是使用4位数字的年份</strong>。支持2位数字的年份，MySQL处理00-69为2000-2069，处理70-99为1970-1999。虽然它们可能是打算要的年份，但<strong>使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定</strong>。</p>
</li>
</ul>
</li>
<li><p>如果你<strong>想要的仅是日期</strong>，则<strong>使用Date()是一个良好的习惯</strong>，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个<strong>Time()函数</strong>，在你<strong>只想要时间时</strong>应该使用它。</p>
</li>
<li><p><code>Date()</code>和<code>Time()</code>都是在MySQL 4.1.1中第一次引入的。</p>
</li>
<li><p>还有一种日期比较需要说明。如果你想检索出2005年9月下的所有订单，怎么办？简单的相等测试不行，因为它也要匹配月份中的天数。有几种解决办法。</p>
<ul>
<li><p>其中之一如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">Date</span>(order_date) <span class="keyword">BETWEEN</span> <span class="string">'2005-09-01'</span> <span class="keyword">AND</span> <span class="string">'2005-09-30'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>另外一种办法（<strong>不需要记住每个月中有多少天或不需要操心闰年2月</strong>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(order_date) = <span class="number">2005</span> <span class="keyword">AND</span> <span class="keyword">MONTH</span>(order_date) = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABS(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>SIN(x)</td>
<td>返回正弦值(参数是<strong>弧度</strong>)</td>
</tr>
<tr>
<td>COS(x)</td>
<td>返回余弦值(参数是<strong>弧度</strong>)</td>
</tr>
<tr>
<td>TAN(x)</td>
<td>返回正切值(参数是<strong>弧度</strong>)</td>
</tr>
<tr>
<td>EXP(x)</td>
<td>返回<strong>e的x次方</strong></td>
</tr>
<tr>
<td>MOD(x, y)</td>
<td>返回<strong>x除以y以后的余数</strong></td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率(<strong>3.141593</strong>)</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回<strong>0到1</strong>的随机数</td>
</tr>
<tr>
<td>SQRT()</td>
<td>返回x的<strong>平方根</strong></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><ul>
<li>我们经常需要<strong>汇总数据而不用把它们实际检索出来</strong>，为此MySQL提供了专门的函数。使用这些函数，MySQL查询可用于<strong>检索数据，以便分析和报表生成</strong>。这种类型的检索例子有以下几种：<ul>
<li>确定表中<strong>行数</strong>（或者满足某个条件或包含某个特定值的行数）</li>
<li>获得表中<strong>行组的和</strong>。</li>
<li>找出表列（或所有行或某些特定的行）的<strong>最大值、最小值</strong>和<strong>平均值</strong>。</li>
</ul>
</li>
<li>上述例子都需要<strong>对表中数据</strong>（而<strong>不是实际数据本身</strong>）<strong>汇总</strong>。因此，返回实际表数据是对时间和处理资源的一种浪费（更不用说带宽了）。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>对 列值为NULL的行 的处理</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AVG()</code></td>
<td>返回<strong>某列</strong>的平均值</td>
<td>忽略</td>
</tr>
<tr>
<td><code>COUNT()</code></td>
<td>返回<strong>某列</strong>的<strong>行数</strong></td>
<td>COUNT(<strong>*</strong>) <strong>不忽略</strong><br>COUNT(<strong>指定列名</strong>)忽略</td>
</tr>
<tr>
<td><code>MAX()</code></td>
<td>返回<strong>某列</strong>的最大值</td>
<td>忽略</td>
</tr>
<tr>
<td><code>MIN()</code></td>
<td>返回<strong>某列</strong>的最小值</td>
<td>忽略</td>
</tr>
<tr>
<td><code>SUM()</code></td>
<td>返回<strong>某列</strong>之和</td>
<td>忽略</td>
</tr>
</tbody>
</table>
<ul>
<li>MySQL还支持一系列的标准偏差聚集函数，但本书并未涉及这些内容。</li>
</ul>
<h4 id="AVG-函数"><a href="#AVG-函数" class="headerlink" title="AVG()函数"></a>AVG()函数</h4><ul>
<li><p>AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。<strong>可返回所有列的平均值</strong>，也可用来返回<strong>特定列或行的平均值</strong>。</p>
<ul>
<li>如下，使用AVG()返回products表中<strong>所有产品的平均价格</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
<ul>
<li>如下，返回<strong>特定供应商所提供产品的平均价格</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AVG()只能用来确定特定数值列得平均值，且<strong>列名必须作为函数参数给出</strong>。<strong>为了获得多个列的平均值，必须使用多个AVG()函数</strong>。</p>
</li>
<li><p><strong>AVG()函数忽略列值为NULL的行。</strong></p>
</li>
</ul>
<hr>
<h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT()函数"></a>COUNT()函数</h4><ul>
<li><p>可利用COUNT()确定<strong>表中行的数目</strong>或<strong>符合特定条件的行的数目</strong>。</p>
</li>
<li><p>COUNT()函数有两种使用方式：</p>
<ol>
<li>使用<code>COUNT(*)</code>对表中行的数目进行计数，<strong>包括空值（NULL）</strong>。</li>
<li>使用<code>COUNT(column)</code>对特定列中具有值的行进行计数，<strong>忽略NULL值</strong>。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX()函数"></a>MAX()函数</h4><ul>
<li><p>MAX()返回指定列中的最大值。MAX()<strong>要求指定列名</strong>。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>对<strong>非数值数据</strong>使用MAX()：</p>
<p>虽然MAX()一般用来找出最大的<strong>数值</strong>或<strong>日期值</strong>，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在<strong>用于文本数据时</strong>，如果数据按相应的列排序，则MAX()<strong>返回最后一行</strong>。</p>
</li>
<li><p>MAX()函数<strong>忽略列值为NULL的行</strong>。</p>
</li>
</ul>
<hr>
<h4 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN()函数"></a>MIN()函数</h4><ul>
<li><p>MIN()的功能正好与MAX()功能相反，它返回指定列的最小值。与MAX()一样，MIN()要求指定列名</p>
</li>
<li><p>在用于文本数据时，如果数据按相应的列排序，则MIN()<strong>返回最前面的行</strong>。</p>
</li>
<li>MIN()函数<strong>忽略列值为NULL的行</strong>。</li>
</ul>
<hr>
<h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM()函数"></a>SUM()函数</h4><ul>
<li><p>SUM()用来返回<strong>指定列值的和</strong>（总计）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(quantity) <span class="keyword">AS</span> items_ordered</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SUM()也可以用来<strong>合计计算值</strong>。在下面的例子中，合计每项物品的item_price*quantity，得出总的订单金额：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(item_price * quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SUM()<strong>函数忽略列值为NULL的行</strong>。</p>
</li>
</ul>
<hr>
<h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><ul>
<li><p>聚集函数的<strong>DISTINCT</strong>的使用，已经被添加到MySQL <strong>5.0.3</strong>中。下面所述内容<strong>在MySQL 4.x中不能正常运行</strong>。</p>
</li>
<li><p>上述5个聚集函数都可以如下使用：</p>
<ol>
<li><strong>对所有的行执行计算</strong>，指定ALL参数或不给参数（因为<strong>ALL是默认行为</strong>）；</li>
<li><strong>只包含不同的值</strong>，指定<strong>DISTINCT参数</strong>。</li>
</ol>
</li>
<li><p>下面的例子使用AVG()函数返回特定供应商提供的产品的平均价格。它与上面的SELECT语句相同，但<strong>使用了DISTINCT参数</strong>，因此平均值<strong>只考虑各个不同的价格</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误</strong>。类似地，<strong>DISTINCT必须使用列名</strong>，<strong>不能用于计算或表达式</strong>。</p>
</li>
</ul>
<hr>
<h3 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_items,</span><br><span class="line">		<span class="keyword">MIN</span>(prod_price) <span class="keyword">AS</span> price_min,</span><br><span class="line">		<span class="keyword">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,</span><br><span class="line">		<span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里用单条SELECT语句执行了4个聚集计算，返回4个值（products表中物品的数目，产品价格的最低、最高以及平均值）</p>
</li>
<li><p>在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。</p>
</li>
</ul>
<h2 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h2><h3 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h3><ul>
<li>如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办？这就是分组显身手的时候了。<strong>分组</strong>允许<strong>把数据分为多个逻辑组</strong>，以便能<strong>对每个组进行聚集计算</strong>。</li>
</ul>
<hr>
<h3 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h3><ul>
<li><p>分组是在SELECT语句的<strong>GROUP BY子句中建立</strong>的。理解分组的最好办法是看一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p>| vend_id | num_prods |<br>| ——- | ——— |<br>| 1001    | 3         |<br>| 1002    | 2         |<br>| 1003    | 7         |<br>| 1005    | 2         |</p>
</li>
<li><p><strong>GROUP BY子句指示</strong>MySQL<strong>按vend_id排序并分组数据</strong>。这导致<strong>对每个vend_id</strong>而不是整个表<strong>计算num_prods一次</strong></p>
</li>
<li><p>因为使用了GROUP BY，就<strong>不必指定要计算和估值的每个组了</strong>,<strong>系统会自动完成</strong>。<strong>GROUP BY子句</strong>指示MySQL分组数据，然后<strong>对每个组</strong>而不是整个结果集<strong>进行聚集</strong>。</p>
</li>
<li><p>一些重要的规定：</p>
<ul>
<li>GROUP BY子句<strong>可以包含任意数目的列</strong>。这使得<strong>能对分组进行嵌套，为数据分组提供更细致的控制</strong>。</li>
<li>如果在GROUP BY子句中<strong>嵌套了分组</strong>，<strong>数据将在最后规定的分组上进行汇总</strong>。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li><strong>GROUP BY子句中列出的每个列</strong>都必须是<strong>检索列</strong>或<strong>有效的表达式</strong>（但<strong>不能是聚集函数</strong>）。如果<strong>在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式</strong>。<strong>不能使用别名</strong>。</li>
<li><strong>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出</strong>。</li>
<li>如果<strong>分组列中具有NULL值</strong>，则NULL<strong>将作为一个分组返回</strong>。如果列中有多行NULL值，它们将分为一组。</li>
<li><strong>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</strong>。</li>
</ul>
</li>
<li><p>使用<strong>WITH ROLLUP关键字</strong>，<strong>可以得到每个分组以及每个分组汇总级别（针对每个分组）的值</strong>，如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h3><ul>
<li><p><strong>WHERE</strong>子句能<strong>过滤指定的行</strong>；<strong>HAVING</strong>子句用于<strong>过滤分组</strong>。</p>
</li>
<li><p>HAVING非常类似于WHERE。事实上，<strong>目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代</strong>。</p>
</li>
<li><p>过滤分组的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这里WHERE子句不起作用，因为过滤是<strong>基于分组聚集值</strong>。</p>
</li>
<li><p>HAVING和WHERE的差别</p>
<p><strong>WHERE</strong>在<strong>数据分组前</strong>进行过滤，<strong>HAVING</strong>在<strong>数据分组后</strong>进行过滤。<strong>这是一个重要的区别，WHERE排除的行不包括在分组中。</strong>这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。</p>
</li>
<li><p>有没有在一条语句中<strong>同时使用WHERE和HAVING子句的需要</strong>呢？事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点，可增加一条WHERE子句，过滤出过去12个月内下过的订单。然后再增加HAVING子句过滤出具有两个以上订单的分组。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &gt;= <span class="number">10</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><ul>
<li><p>虽然<strong>GROUP BY</strong>和<strong>ORDER BY</strong>经常完成相同的工作，但它们是非常不同的。</p>
<p>| ORDER BY                                   | GROUP BY                                                     |<br>| —————————————— | ———————————————————— |<br>| 排序产生的输出                             | 分组行。但<strong>输出可能不是分组的顺序</strong>。                       |<br>| 任意列都可以使用(甚至非选择的列也可以使用) | 只可能使用<strong>选择列</strong>或<strong>表达式列</strong>，<strong>而且必须使用每个选择列表达式</strong> |<br>| 不一定需要                                 | 如果与聚集函数一起使用列(或表达式)，则必须使用               |</p>
</li>
<li><p><strong>我们经常发现用GROUP BY分组的数据确实是以分组顺序输出，但情况并不总是这样，它并不是SQL规范所要求的</strong>。</p>
</li>
<li><p><strong>应该提供明确的ORDER BY子句</strong>，即使其效果等同于GROUP BY子句也是如此。<strong>千万不要仅依赖GROUP BY排序数据</strong>。</p>
</li>
</ul>
<hr>
<h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td><strong>行</strong>级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td><strong>组</strong>级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul>
<li><p><strong>MySQL 4.1引入了对子查询的支持</strong>，所以要想使用本章描述的SQL，必须使用MySQL 4.1或更高级的版本。</p>
</li>
<li><p><strong>查询（query）</strong></p>
<p>任何SQL语句都是查询。但此术语<strong>一般指SELECT语句</strong>。</p>
</li>
<li><p>SQL还允许创建<strong>子查询（subquery）</strong>，即<strong>嵌套在其他查询中的查询</strong>。</p>
</li>
</ul>
<hr>
<h3 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h3><ul>
<li><p>本书所有章中使用的数据库表都是<strong>关系表</strong>。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。</p>
</li>
<li><p>现在，假如需要<strong>列出订购物品TNT2的所有客户</strong>，应该怎样检索？下面列出具体的步骤：</p>
<ol>
<li>检索包含物品TNT2的所有订单的编号。</li>
<li>检索具有前一步骤列出的订单编号的所有客户的ID。</li>
<li>检索前一步骤返回的所有客户ID的客户信息。</li>
</ol>
<p>上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。也可以<strong>使用子查询来把3个查询组合成一条语句</strong>。</p>
</li>
<li><p>在SELECT语句中，<strong>子查询</strong>总是<strong>从内向外</strong>处理。包含子查询的SELECT语句难以阅读和调试，特别是它们较为复杂时更是如此。<strong>把子查询分解为多行并且适当地进行缩进</strong>，<strong>能极大地简化子查询的使用</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                 <span class="keyword">FROM</span> orders</span><br><span class="line">                 <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                     <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                     <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时<strong>由于性能的限制，不能嵌套太多的子查询</strong>。</p>
</li>
<li><p><strong>列必须匹配</strong></p>
<p>在WHERE子句中<strong>使用子查询</strong>，<strong>应该保证SELECT语句具有与WHERE子句中相同数目的列</strong>。<strong>通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列</strong>。</p>
</li>
<li><p>虽然<strong>子查询一般与IN操作符结合使用</strong>，<strong>但也可以用于测试等于（=）、不等于（&lt;&gt;）等</strong>。</p>
</li>
</ul>
<hr>
<h3 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h3><ul>
<li><p>使用子查询的另一方法是<strong>创建计算字段</strong></p>
</li>
<li><p>假如需要显示customers表中每个客户的订单总数，订单与相应的客户ID存储在orders表中。操作应遵循以下步骤：</p>
<ol>
<li>从customers表中检索客户列表</li>
<li>对于检索出的每个客户，统计其在orders表中的订单数目。<strong>对每个客户执行<code>COUNT(*)</code>计算，应该将<code>COUNT(*)</code>作为一个子查询</strong>。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,</span><br><span class="line">		cust_state,</span><br><span class="line">		(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">         <span class="keyword">FROM</span> orders</span><br><span class="line">         <span class="keyword">WHERE</span> orders.cust_id = customers.cust_id) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>涉及外部查询</strong>的子查询称为<strong>相关子查询</strong>。任何时候<strong>只要列名可能有多义性</strong>，就必须使用这种语法（<strong>表名和列名由一个句点分隔</strong>）。</p>
</li>
</ul>
<h2 id="第15章-联结表"><a href="#第15章-联结表" class="headerlink" title="第15章 联结表"></a>第15章 联结表</h2><ul>
<li><p><strong>联结</strong>是利用SQL的<strong>SELECT</strong>能执行的<strong>最重要</strong>的操作</p>
</li>
<li><p>假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？将这些数据与产品信息分开存储的理由如下。</p>
<ul>
<li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li>
<li>如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。</li>
<li>如果有重复数据（即每种产品都存储供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。</li>
</ul>
</li>
<li><p>相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础</p>
</li>
<li><p><strong>一类数据一个表</strong>。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p>
</li>
<li><p>vendors表的<strong>主键</strong>又叫作<strong>products的外键</strong>，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。</p>
</li>
<li><p><strong>外键（foreign key）</strong>为某个表中的一列，它<strong>包含另一个表的主键值</strong>，定义了两个表之间的关系。</p>
</li>
<li><p>关系数据可以有效地存储和方便地处理。因此，<strong>关系数据库</strong>的<strong>可伸缩性</strong>远比非关系数据库要好。</p>
</li>
<li><p><strong>可伸缩性（scale）</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（<strong>scale well</strong>）</p>
</li>
<li><p>联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p>
</li>
<li><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可</p>
</li>
<li><p>在一条SELECT语句中<strong>联结几个表时</strong>，相应的<strong>关系是在运行中构造</strong>的</p>
</li>
<li><p>在联结两个表时，你实际上做的是<strong>将第一个表中的每一行与第二个表中的每一行配对</strong>。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行</p>
</li>
<li><p><strong>没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对</strong>，而不管它们逻辑上是否可以配在一起。由没有联结条件的表关系返回的结果为<strong>笛卡儿积</strong>。检索出的<strong>行的数目</strong>将是<strong>第一个表中的行数乘以第二个表中的行数</strong>。</p>
</li>
<li><p>应该保证所有联结都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。</p>
</li>
<li><p>有时我们会听到返回称为<strong>叉联结（cross join）</strong>的笛卡儿积的联结类型。</p>
</li>
<li><p><strong>等值联结（equijoin）</strong>，它基于两个表之间的相等测试，也称为<strong>内部联结</strong>。</p>
</li>
<li><p>这里，两个表之间的关系是FROM子句的组成部分，以<strong>INNER JOIN</strong>指定。在使用这种语法时，<strong>联结条件</strong>用特定的<strong>ON子句</strong>而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</p>
</li>
<li><p>MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。</p>
</li>
</ul>
<h2 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h2><ul>
<li><p>给列起<strong>别名</strong>的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name), <span class="string">' ('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">') '</span>) <span class="keyword">AS</span></span><br><span class="line">vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>别名除了用于<strong>列名</strong>和<strong>计算字段</strong>外，SQL还允许<strong>给表名起别名</strong>。这样做有两个主要理由：</p>
<ol>
<li><p>缩短SQL语句</p>
</li>
<li><p>允许在<strong>单条</strong>SELECT语句中<strong>多次使用</strong>相同的表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line">	<span class="keyword">AND</span> oi.order_num = o.order_num</span><br><span class="line">	<span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ul>
<li><strong>表别名</strong>只在<strong>查询</strong>执行中使用。与列别名不一样，<strong>表别名不返回到客户机</strong>。</li>
</ul>
<hr>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><ul>
<li><p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。</p>
<ul>
<li>方法一（<strong>子查询</strong>）:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = (<span class="keyword">SELECT</span> vend_id</span><br><span class="line">                <span class="keyword">FROM</span> products</span><br><span class="line">                <span class="keyword">WHERE</span> prod_id = <span class="string">'DTNTR'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二(联结)：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id = p2.vend_id</span><br><span class="line">	<span class="keyword">AND</span> p2.prod_id = <span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure>
<p> 此查询中需要的<strong>两个表实际上是相同的表</strong>，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有<strong>二义性</strong>，因为MySQL不知道你引用的是products表中的哪个实例。为解决此问题，使用了表别名。</p>
</li>
<li><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候<strong>处理联结远比处理子查询快得多</strong>。应该试一下两种方法，以确定哪一种的性能更好。</p>
</li>
</ul>
<hr>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><ul>
<li><p>标准的<strong>内部联结</strong>返回<strong>所有数据</strong>，甚至<strong>相同的列多次出现</strong>。<strong>自然联结排除多次出现，使每个列只返回一次</strong>。</p>
</li>
<li><p>自然联结是这样一种联结，其中你<strong>只能选择那些唯一的列</strong>。这一般是通过对表使用通配符（<strong>SELECT *</strong>），对所有其他表的列使用明确的子集来完成的。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.*, o.order_num, o.order_date,</span><br><span class="line">		oi.prod_id, oi.quality, oi.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line">	<span class="keyword">AND</span> oi.order_num = o.order_num</span><br><span class="line">	<span class="keyword">AND</span> prod_id = <span class="string">'FB'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事实上，<strong>迄今为止我们建立的每个内部联结都是自然联结</strong>，很可能我们永远都不会用到不是自然联结的内部联结。</p>
</li>
</ul>
<hr>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><ul>
<li><p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。</p>
<ul>
<li><p>下面的SELECT语句给出一个简单的<strong>内部联结</strong>。它检索所有客户及其订单(<strong>不包括没有订单的客户</strong>)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>外部联结</strong>语法类似。为了检索素有客户(<strong>包括没有订单的客户</strong>)，可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>这条SELECT语句使用了关键字<strong>OUTER JOIN</strong>来<strong>指定联结的类型</strong>（而不是在WHERE子句中指定）</p>
</li>
</ul>
</li>
<li><p>在使用<strong>OUTER JOIN</strong>语法时，必须使用<strong>RIGHT</strong>或<strong>LEFT</strong>关键字<strong>指定包括其所有行的表</strong>（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）</p>
</li>
<li><p>外部联结的<strong>OUTER可省略</strong></p>
</li>
<li><p>MySQL<strong>不支持</strong>简化字符<code>*=</code>和<code>=*</code>的使用，这两种操作符在其他DBMS中是很流行的。</p>
</li>
<li><p>如果要<strong>检索所有客户及每个客户所下的订单数</strong>，下面使用了<strong>COUNT()函数</strong>的代码可完成此工作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name,</span><br><span class="line">	customers.cust_id,</span><br><span class="line">	<span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line">	<span class="keyword">ON</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h3><ul>
<li><p>有必要汇总一下关于联结及其使用的某些要点：</p>
<ul>
<li><p>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</p>
</li>
<li><p>应该总是<strong>提供联结条件</strong>，否则会得出笛卡儿积。</p>
</li>
<li><p>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</p>
</li>
</ul>
</li>
</ul>
<h2 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h2><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><ul>
<li><p>MySQL也允许<strong>执行多个查询</strong>（多条SELECT语句），并<strong>将结果作为单个查询结果集返回</strong>。这些<strong>组合查询</strong>通常称为<strong>并（union）</strong>或<strong>复合查询（compound query）</strong>。</p>
</li>
<li><p>有两种基本情况，其中需要使用组合查询：</p>
<ol>
<li>在<strong>单个查询中</strong>从<strong>不同的表</strong>返回<strong>类似结构</strong>的数据；</li>
<li>对<strong>单个表</strong>执行<strong>多个查询</strong>，<strong>按单个查询返回数据</strong>。</li>
</ol>
</li>
<li><strong>任何具有多个WHERE子句的SELECT语句</strong>都可以作为<strong>一个组合查询</strong>给出，在以下段落中可以看到这一点。<strong>这两种技术在不同的查询中性能也不同</strong>。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。</li>
</ul>
<hr>
<h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><p>可用<strong>UNION操作符</strong>来<strong>组合数条SQL查询</strong>。<strong>利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集</strong>。</p>
<h4 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h4><ul>
<li><p>UNION的使用很简单，<strong>只需给出每条SELECT语句，在各条语句之间放上关键字UNION</strong>。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p>| vend_id | prod_id | prod_price |<br>| ——- | ——- | ———- |<br>| 1003    | FC      | 2.50       |<br>| 1002    | FU1     | 3.42       |<br>| 1003    | SLING   | 4.49       |<br>| 1003    | TNT1    | 2.50       |<br>| 1001    | ANV01   | 5.99       |<br>| 1001    | ANV02   | 9.99       |<br>| 1001    | ANV03   | 14.99      |<br>| 1002    | OL1     | 8.99       |</p>
<p>UNION指示MySQL执行两条SELECT语句，并<strong>把输出组合成单个查询结果集</strong>。</p>
<p>作为参考，这里给出使用多条WHERE子句而不是使用UNION的相同查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line">	<span class="keyword">OR</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p>这个简单的例子中，<strong>使用UNION可能比使用WHERE子句更为复杂</strong>。但对于<strong>更复杂的过滤条件</strong>，或者<strong>从多个表中检索数据</strong>的情形，<strong>使用UNION可能会使处理更简单</strong>。</p>
</li>
</ul>
<hr>
<h4 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h4><ul>
<li><p>UNION必须由<strong>两条或两条以上的SELECT语句组成</strong>，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。</p>
</li>
<li><p>UNION中<strong>每个查询必须包含相同的列、表达式或聚集函数</strong>（不过各个列<strong>不需要以相同的次序列出</strong>）。</p>
</li>
<li><p>列数据类型必须<strong>兼容</strong>。类型不必完全相同，但必须是DBMS可以隐含地转换的类型(如<strong>不同的数值类型</strong>或<strong>不同的日期类型</strong>)。</p>
</li>
</ul>
<hr>
<h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><ul>
<li><p><strong>UNION从查询结果集中自动去除了重复的行</strong>（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。</p>
</li>
<li><p>如果<strong>想返回所有匹配行</strong>，可<strong>使用UNION ALL</strong>而不是UNION。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UNION ALL为UNION的一种形式，它完成WHERE子句完成不了的工作</strong>。如果确实需要每个条件的匹配行全部出现（包括<strong>重复行</strong>），则必须使用UNION ALL而不是WHERE。</p>
</li>
</ul>
<hr>
<h4 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h4><ul>
<li>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后<strong>。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句</strong>。</li>
</ul>
<h2 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h2><blockquote>
<p>MySQL支持几种基本的数据库引擎。并非所有的引擎都支持本书所描述的全文本搜索。两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。</p>
</blockquote>
<blockquote>
<p>通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。</p>
</blockquote>
<blockquote>
<p>使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。</p>
</blockquote>
<blockquote>
<p>在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。</p>
</blockquote>
<blockquote>
<p>为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引。</p>
</blockquote>
<blockquote>
<p>一般在创建表时启用全文本搜索。CREATE TABLE语句（第21章中介绍）接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。</p>
</blockquote>
<blockquote>
<p>在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。</p>
</blockquote>
<blockquote>
<p>可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立即索引）。</p>
</blockquote>
<blockquote>
<p>如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然后再修改表，定义FULLTEXT。这样有助于更快地导入数据（而且使索引数据的总时间小于在导入每行时分别进行索引所需的总时间）</p>
</blockquote>
<blockquote>
<p>在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
</blockquote>
<blockquote>
<p>传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p>
</blockquote>
<blockquote>
<p>除非使用BINARY方式（本章中没有介绍），否则全文本搜索不区分大小写。</p>
</blockquote>
<blockquote>
<p>（使用全文本搜索）返回以文本匹配的良好程度排序的数据。</p>
</blockquote>
<blockquote>
<p>文本搜索的一个重要部分就是对结果排序</p>
</blockquote>
<blockquote>
<p>由于数据是索引的，全文本搜索还相当快。</p>
</blockquote>
<blockquote>
<p>查询扩展用来设法放宽所返回的全文本搜索结果的范围</p>
</blockquote>
<blockquote>
<p>。在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索：❑ 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；❑ 其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简要地解释MySQL如何断定什么有用，什么无用）。❑ 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</p>
</blockquote>
<blockquote>
<p>表中的行越多（这些行中的文本就越多），使用查询扩展返回的结果越好。</p>
</blockquote>
<blockquote>
<p>MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean mode）。以布尔方式，可以提供关于如下内容的细节：❑ 要匹配的词；❑ 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；❑ 排列提示（指定某些词比其他词更重要，更重要的词等级更高）;❑ 表达式分组；❑ 另外一些内容。</p>
</blockquote>
<blockquote>
<p>即使没有定义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。</p>
</blockquote>
<blockquote>
<p>即使没有定义FULLTEXT索引，也可以使用它</p>
</blockquote>
<blockquote>
<p>为了匹配包含heavy但不包含任意以rope开始的词的行，可使用以下查询：</p>
</blockquote>
<blockquote>
<p>表18-1列出支持的所有布尔操作符。</p>
</blockquote>
<blockquote>
<p>没有指定操作符，这个搜索匹配包含rabbit和bait中的至少一个词的行。</p>
</blockquote>
<blockquote>
<p>在布尔方式中，不按等级值降序排序返回的行。</p>
</blockquote>
<blockquote>
<p>MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。</p>
</blockquote>
<blockquote>
<p>忽略词中的单引号。例如，don’t索引为dont。</p>
</blockquote>
<blockquote>
<p>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</p>
</blockquote>
<blockquote>
<p>仅在MyISAM数据库引擎中支持全文本搜索。</p>
</blockquote>
<hr>
<h2 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h2><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><ul>
<li><strong>INSERT语句</strong>用来插入行到数据库表。插入可以用几种方式使用：<ul>
<li>插入完整的行</li>
<li>插入行的一部分</li>
<li>插入多行</li>
<li>插入某些查询的结果</li>
</ul>
</li>
</ul>
<hr>
<h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><ul>
<li><p>INSERT语句<strong>要求指定表名</strong>和<strong>被插入到新行中的值</strong>。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="literal">NULL</span>,</span><br><span class="line">      <span class="string">'Pep E. LaPew'</span>,</span><br><span class="line">       <span class="string">'100 Main Street'</span>,</span><br><span class="line">       <span class="string">'Los Angeles'</span>,</span><br><span class="line">       <span class="string">'CA'</span>,</span><br><span class="line">       <span class="string">'90046'</span>,</span><br><span class="line">       <span class="string">'USA'</span>,</span><br><span class="line">       <span class="literal">NULL</span>,</span><br><span class="line">       <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>存储到每个表列中的数据在<strong>VALUES子句</strong>中给出，对<strong>每个列必须提供一个值</strong>，<strong>各个列必须以在表定义中出现的次序填充</strong>。如果某个列没有值，应该使用NULL值（假定表允许对该列指定空值）。<strong>第一列cust_id也为NULL(每次插入一个新行时，该列由MySQL自动增量，NULL值会被MySQL忽略)</strong>。</p>
<p>虽然这种语法很简单，但<strong>并不安全，应该尽量避免使用</strong>。上面的SQL语句高度依赖于表中列的定义次序。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。</p>
</li>
<li><p>INSERT语句一般<strong>不会产生输出</strong>。</p>
</li>
<li><p>一般<strong>不要使用没有明确给出列的列表的INSERT语句</strong>。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。</p>
</li>
<li><p>不管使用哪种INSERT语法，都必须给出VALUES的正确数目</p>
<ul>
<li>如果<strong>不提供列名</strong>，则必须给每个表列提供一个值</li>
<li>如果<strong>提供列名</strong>，则必须对<strong>每个列出的列</strong>提供一个值</li>
</ul>
</li>
<li><p>省略的列必须满足以下某个条件。</p>
<ol>
<li>该<strong>列</strong>定义为<strong>允许NULL值</strong>。</li>
<li>在<strong>表定义中给出默认值</strong>。这表示如果不给出值，将使用默认值。</li>
</ol>
<p>如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</p>
</li>
<li><p><strong>INSERT操作可能很耗时，而且可能降低等待处理的SELECT语句的性能</strong>。如果<strong>数据检索是最重要的</strong>（通常是这样），则你可以通过<strong>在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级</strong>，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">LOW</span> <span class="keyword">PRIORITY</span> <span class="keyword">INTO</span> ...</span><br></pre></td></tr></table></figure>
<p>这<strong>也适用于</strong>下一章介绍的<strong>UPDATE和DELETE语句</strong>。</p>
</li>
</ul>
<hr>
<h3 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h3><ul>
<li><p>如果想<strong>插入多个行</strong>：</p>
<ol>
<li><p>可以使用<strong>多条INSERT语句</strong>，甚至<strong>一次提交</strong>它们，<strong>每条语句用一个分号结束</strong>。</p>
</li>
<li><p>只<strong>要每条INSERT语句中的列名(和次序)相同</strong>，可以用<strong>单条INSERT语句</strong>插入多组值，<strong>每组值用一对圆括号括起来，用逗号分隔</strong>。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country)</span><br><span class="line"><span class="keyword">VALUES</span>(</span><br><span class="line">		<span class="string">'Pep E. LaPew'</span>,</span><br><span class="line">    	<span class="string">'100 Main Street'</span>,</span><br><span class="line">    	<span class="string">'Los Angeles'</span>,</span><br><span class="line">    	<span class="string">'CA'</span>,</span><br><span class="line">    	<span class="string">'90046'</span>,</span><br><span class="line">    	<span class="string">'USA'</span></span><br><span class="line">	),</span><br><span class="line">	(</span><br><span class="line">    	<span class="string">'M. Martian'</span>,</span><br><span class="line">        <span class="string">'42 Galaxy Way'</span>,</span><br><span class="line">        <span class="string">'New York'</span>,</span><br><span class="line">        <span class="string">'NY'</span>,</span><br><span class="line">        <span class="string">'11213'</span>,</span><br><span class="line">        <span class="string">'USA'</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>单条INSERT语句处理多个插入比使用多条INSERT语句快</strong>。</p>
</li>
</ul>
<hr>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><ul>
<li><p>INSERT还存在另一种形式，可以利用它<strong>将一条SELECT语句的结果插入表中</strong>。这就是所谓的<strong>INSERT SELECT</strong>。</p>
<p>假如你想<strong>从另一表中合并客户列表到你的customers表</strong>，可以如下进行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(cust_id,</span><br><span class="line">                      cust_contact,</span><br><span class="line">                      cust_email,</span><br><span class="line">                      cust_name)</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,</span><br><span class="line">		cust_contact,</span><br><span class="line">		cust_email,</span><br><span class="line">		cust_name</span><br><span class="line"><span class="keyword">FROM</span> custnew;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等</p>
</li>
</ul>
<hr>
<h2 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><ul>
<li><p>为了更新(修改)表中的数据，可使用UPDATE语句。可采用两种方式使用UPDATE：</p>
<ol>
<li>更新表中<strong>特定行</strong></li>
<li>更新表中<strong>所有行</strong></li>
</ol>
</li>
<li><p>基本的UPDATE语句由3部分组成</p>
<ol>
<li>要更新的表</li>
<li>列名和它们的新值</li>
<li>确定要更新行的<strong>过滤条件</strong></li>
</ol>
<p>例如，客户10005现在有了电子邮件地址，需要更新记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_email = <span class="string">'elmer@fudd.com'</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
<p><strong>SET命令用来将新值赋给被更新的列</strong>。</p>
</li>
<li><p>UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行。<strong>没有WHERE子句</strong>，MySQL将会<strong>更新customers表中所有行</strong>。</p>
</li>
<li><p>更新多个列的语法稍有不同：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_name = <span class="string">'The Fudds'</span>,</span><br><span class="line">	cust_email = <span class="string">'elmer@fudd.com'</span></span><br><span class="line"><span class="keyword">WHERE</span> cust <span class="keyword">id</span> = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
<p><strong>更新多个列只需使用单个SET命令</strong>，<strong>每个“列=值”对之间用逗号分隔</strong>。</p>
</li>
<li><p>UPDATE语句中可以使用<strong>子查询</strong>。</p>
</li>
<li><p><strong>IGNORE关键字</strong></p>
<p>如果用UPDATE语句<strong>更新多行</strong>，并且这些行中的一行或者多行<strong>出现一个错误，整个UPDATE操作会被取消</strong>。如果<strong>希望即使发生错误也继续更新</strong>，可使用<strong>IGNORE关键字</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">IGNORE</span> customers ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了<strong>删除某个列的值，可设置其为NULL</strong>(前提表定义允许NULL值)。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_email = <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul>
<li>为了从一个表中<strong>删除数据</strong>，使用<strong>DELETE语句</strong>。可以通过两种方式使用DELETE：<ol>
<li>从表中删除<strong>特定的行</strong></li>
<li>从表中删除<strong>所有行</strong></li>
</ol>
</li>
<li><p>DELETE语句以WHERE子句结束，它告诉MySQL删除哪一行。<strong>没有WHERE子句</strong>，MySQL将会<strong>删除表中所有行</strong>。</p>
</li>
<li><p>DELETE<strong>不需要列名或通配符</strong>。DELETE<strong>删除整行</strong>而不是删除列。<strong>为了删除指定的列，请使用UPDATE语句</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10006</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DELETE<strong>不删除表本身</strong>。</p>
</li>
<li><p><strong>更快的删除</strong></p>
<p>ruu过<strong>想删除表中所有行，不要使用DELETE</strong>。可使用<strong>TRUNCATE TABLE语句</strong>，<strong>它完成相同的工作，但速度更快</strong>（<strong>TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据</strong>）。</p>
</li>
</ul>
<hr>
<h3 id="更新和删除的指导原则"><a href="#更新和删除的指导原则" class="headerlink" title="更新和删除的指导原则"></a>更新和删除的指导原则</h3><ul>
<li>除非确实打算更新和删除每一行，否则<strong>一定要带WHERE子句</strong></li>
<li><strong>保证每个表都有主键</strong>，从而能通过WHERE子句指定唯一的列。</li>
<li>在对UPDATE或DELETE语句<strong>使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确</strong>。、</li>
<li>使用<strong>强制实施引用完整性的数据库</strong>（15章），这样MySQL<strong>将不允许删除具有与其他表相关联的数据的行</strong>。</li>
<li><strong>MySQL没有撤销（undo）按钮</strong>。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。</li>
</ul>
<hr>
<h2 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><ul>
<li>为了用程序创建表，可使用SQL的<strong>CREATE TABLE语句</strong>。</li>
</ul>
<h4 id="表创建基础"><a href="#表创建基础" class="headerlink" title="表创建基础"></a>表创建基础</h4><ul>
<li><p>为利用CREATE TABLE创建表，必须给出下列信息：</p>
<ul>
<li><strong>新表的名字</strong>，在<strong>关键字CREATE TABLE之后</strong>给出；</li>
<li>表<strong>列的名字和定义</strong>在<strong>圆括号之中</strong>，各列之间<strong>用逗号分隔</strong>；</li>
<li><strong>每列的定义</strong>以<strong>列名开始</strong>，后跟<strong>列的数据类型</strong>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers</span><br><span class="line">(</span><br><span class="line">	cust_id			<span class="built_in">int</span>			<span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    cust_name		<span class="built_in">char</span>(<span class="number">50</span>)	<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    cust_address	<span class="built_in">char</span>(<span class="number">50</span>)	<span class="literal">NULL</span>,</span><br><span class="line">    cust_city		<span class="built_in">char</span>(<span class="number">50</span>)	<span class="literal">NULL</span>,</span><br><span class="line">    cust_state		<span class="built_in">char</span>(<span class="number">5</span>)		<span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (cust_id)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表的<strong>主键</strong>可以<strong>在创建表时用PRIMARY KEY关键字指定</strong>。这里，列cust_id指定作为主键列。<strong>整条语句由右圆括号后的分号结束</strong>。</p>
</li>
<li><p><strong>语句格式化</strong></p>
<p>MySQL语句中忽略空格。语句可以在一个长行上输入，也可以分成许多行。它们的作用都相同。<strong>对列定义进行恰当的缩进，以便阅读和编辑</strong>。</p>
</li>
<li><p><strong>创建新表时，指定的表名必须不存在</strong>，否则将出错。<strong>如果要防止意外覆盖已有的表，SQL要求首先手工删除该表</strong>（请参阅后面的小节），<strong>然后再重建它</strong>，而不是简单地用创建表语句覆盖它。<strong>如果仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS</strong>(<strong>并不检查已有表的模式是否与打算创建的表模式相匹配，只是查看表名是否存在</strong>，并且仅在表名不存在时创建它)。</p>
</li>
</ul>
<hr>
<h4 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h4><ul>
<li><p>每个表列或者是NULL列，或者是NOT NULL列，<strong>这种状态在创建时由表的定义规定</strong>。</p>
</li>
<li><p><strong>NULL为默认设置</strong>，<strong>如果不指定NOT NULL，则认为指定的是NULL</strong>。</p>
</li>
<li>进行查询时可通过<code>WHERE XXX IS NULL</code>或<code>WHERE XXX IS NOT NULL</code>进行筛选。</li>
</ul>
<hr>
<h4 id="主键再介绍"><a href="#主键再介绍" class="headerlink" title="主键再介绍"></a>主键再介绍</h4><ul>
<li><p><strong>主键值必须唯一</strong>。如果主键<strong>使用单个列</strong>，则<strong>它的值必须唯一</strong>；如果<strong>使用多个列</strong>，则<strong>这些列的组合值必须唯一</strong>。</p>
</li>
<li><p>为创建由<strong>多个列组成的主键</strong>，应该<strong>以逗号分隔的列表给出各列名</strong>。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">    order_num	<span class="built_in">int</span>				<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_item	<span class="built_in">int</span>				<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_id		<span class="built_in">char</span>(<span class="number">10</span>)		<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    quantity	<span class="built_in">int</span>				<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    item_price	<span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)	<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (order_num, order_item)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p><strong>订单号（order_num列）和订单物品（order_item列）的组合是唯一的，从而适合作为主键</strong>。</p>
</li>
<li><p>主键可以<strong>在创建表时定义</strong>，或者<strong>在创建表之后定义</strong>。<strong>主键只能使用NOT NULL值的列</strong>，因为允许NULL值的列不能作为唯一标识。</p>
</li>
</ul>
<hr>
<h4 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h4><ul>
<li><p><strong>AUTO_INCREMENT</strong>告诉MySQL，<strong>本列每当增加一行时自动增量</strong>。每次执行一个<strong>INSERT操作</strong>时，MySQL<strong>自动对该列增量</strong>，赋予一下一个可用的值。这样能使得每个行被分配一个唯一的值，可以作为主键值。</p>
</li>
<li><p><strong>每个表只允许一个AUTO_INCREMENT列</strong>，<strong>而且它必须被索引</strong>（如，通过使它<strong>成为主键</strong>）。</p>
</li>
<li><p><strong>覆盖AUTO_INCREMENT</strong> </p>
<p>如果一个列被指定为AUTO_INCRE-MENT，则它需要使用特殊的值吗？你<strong>可以在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可</strong>，该值将被用来<strong>替代自动生成的值</strong>，<strong>后续的增量将开始使用该手工插入的值</strong>。</p>
</li>
<li><p><strong>确定AUTO_INCREMENT值</strong></p>
<p>让MySQL通过自动增量生成主键的一个缺点是<strong>你不知道这些值都是谁</strong>。</p>
<p>考虑这个场景：你正在增加一个新订单，这要求在orders表中创建一行，然后在orderitems表中对订购的每项物品创建一行。order_num在orderitems表中与订单细节一起存储。<strong>这显然要求你在插入orders行之后，插入orderitems行之前知道生成的order_num</strong>。</p>
<p>那么，<strong>如何在使用AUTO_INCREMENT列时获得这个值呢</strong>？可使用<strong>last_insert_id()函数</strong>获得这个值，如<code>SELECT_last_insert_id()</code>，<strong>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句</strong>。</p>
</li>
</ul>
<hr>
<h4 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h4><ul>
<li><p>如果<strong>在插入行时没有给出值</strong>，MySQL<strong>允许指定此时使用的默认值</strong>。默认值用<strong>CREATE TABLE语句的列定义中的DEFAULT关键字指定</strong>。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">	order_num	<span class="built_in">INT</span>				<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_item	<span class="built_in">INT</span>				<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_id		<span class="built_in">CHAR</span>(<span class="number">10</span>)		<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    quantity	<span class="built_in">INT</span>				<span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">    item_price 	<span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)	<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (order_num, order_item)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>此例子中，给该列的描述添加文本<strong>DEFAULT 1</strong>指示MySQL，<strong>在未给出数量的情况下使用数量1</strong>。</p>
</li>
<li><p>与大多数DBMS<strong>不一样</strong>，MySQL<strong>不允许使用函数作为默认值</strong>，它<strong>只支持常量</strong>。</p>
</li>
<li><p>许多数据库开发人员<strong>使用默认值而不是NULL列</strong>，特别是对<strong>用于计算或数据分组的列更是如此</strong>。</p>
</li>
</ul>
<hr>
<h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h4><ul>
<li><p>迄今为止使用的CREATE TABLE语句全都以<strong>ENGINE=InnoDB语句</strong>结束。<strong>如果省略ENGINE=语句，则使用默认引擎</strong>(MySQL <strong>5.5之前</strong>，<strong>MyISAM</strong>是默认的引擎；<strong>5.5之后</strong>，<strong>InnoDB</strong>是默认的引擎)。</p>
</li>
<li><p>几个需要知道的引擎：</p>
<ol>
<li><strong>InnoDB</strong>是一个可靠的<strong>事务处理引擎</strong>（参见第26章），它<strong>不支持全文本搜索</strong>(18章)；</li>
<li><strong>MyISAM</strong>是一个<strong>性能极高</strong>的引擎，它<strong>支持全文本搜索，不支持事务处理</strong>。</li>
<li><strong>MEMORY</strong>功能等同于MyISAM，但由于<strong>数据存储在内存中</strong>，速度很快，故适合于<strong>临时表</strong>。</li>
</ol>
</li>
<li><p>引擎可以混用</p>
</li>
<li><strong>外键（用于强制实施引用完整性，如第1章所述）不能跨引擎</strong>。</li>
</ul>
<hr>
<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><ul>
<li><p>更新表定义，可使用<strong>ALTER TABLE语句</strong></p>
</li>
<li><p>为了使用ALTER TABLE更改表结构，必须给出下面的信息：</p>
<ul>
<li>在<strong>ALTER TABLE之后</strong>给出<strong>要更改的表名</strong>（<strong>该表必须存在，否则将出错</strong>）；</li>
<li><strong>所做更改的列表</strong>。</li>
</ul>
</li>
<li><p><strong>给表添加一个列</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p><strong>增加一个列</strong>，<strong>必须明确其数据类型</strong>。</p>
</li>
<li><p><strong>删除表中的列</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ALTER TABLE的一种常见用途是<strong>定义外键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (order_num) <span class="keyword">REFERENCES</span> orders (order_num);</span><br></pre></td></tr></table></figure>
<p>如果<strong>对单个表进行多个更改</strong>，可以<strong>使用单条ALTER TABLE语句</strong>，<strong>每个更改用逗号分隔</strong>。</p>
</li>
<li><p><strong>复杂的表结构更改</strong>一般需要<strong>手动删除过程</strong>：</p>
<ol>
<li>用新的列布局创建一个新表</li>
<li>使用<strong>INSERT SELECT语句</strong>(19章)<strong>从旧表复制数据到新表</strong>。如果有必要，<strong>可使用转换函数和计算字段</strong>。</li>
<li>检验包含所需数据的新表</li>
<li>重命名旧表（如果确定，可以删除它）</li>
<li>用旧表原来的名字重命名新表</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键</li>
</ol>
</li>
<li><p>使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。</p>
</li>
</ul>
<hr>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ul>
<li><p>删除表（删除整个表而不是其内容）非常简单，使用<strong>DROP TABLE语句</strong>即可。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br></pre></td></tr></table></figure>
<p><strong>删除表没有确认，也不能撤销</strong>，执行这条语句将永久删除该表。</p>
</li>
</ul>
<hr>
<h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><ul>
<li><p>使用<strong>RENAME TABLE语句</strong>可以重命名一个表。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> customers2 <span class="keyword">TO</span> customers;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以<strong>使用单条RENAME TABLE语句</strong>对<strong>多个表</strong>进行重命名，<strong>每个重命名用逗号分隔</strong>。</p>
</li>
</ul>
<hr>
<h2 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h2><blockquote>
<p>MySQL 5添加了对视图的支持</p>
</blockquote>
<blockquote>
<p>虚拟的表</p>
</blockquote>
<blockquote>
<p>只包含使用时动态检索数据的查询</p>
</blockquote>
<blockquote>
<p>productcustomers是一个视图，作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询</p>
</blockquote>
<blockquote>
<p>视图的一些常见应用。❑ 重用SQL语句。❑ 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。❑ 使用表的组成部分而不是整个表。❑ 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。❑ 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p>
</blockquote>
<blockquote>
<p>如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p>
</blockquote>
<blockquote>
<p>视图创建和使用的一些最常见的规则和限制。❑ 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。❑ 对于可以创建的视图数目没有限制。❑ 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。❑ 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。❑ ORDER BY可以用在视图中，但如果从该视图检索数据的SELECT语句中也含有ORDERBY，那么该视图中的ORDER BY将被覆盖。❑ 视图不能索引，也不能有关联的触发器或默认值。❑ 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</p>
</blockquote>
<blockquote>
<p>视图的创建。❑ 视图用CREATE VIEW语句来创建。❑ 使用SHOW CREATE VIEW viewname；来查看创建视图的语句。❑ 用DROP删除视图，其语法为DROP VIEW viewname;。❑ 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACEVIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</p>
</blockquote>
<blockquote>
<p>隐藏复杂的SQL</p>
</blockquote>
<blockquote>
<p>[插图]创建可重用的视图 创建不受特定数据限制的视图是一种好办法</p>
</blockquote>
<blockquote>
<p>扩展视图的范围不仅使得它能被重用，而且甚至更有用。这样做不需要创建和维护多个类似视图</p>
</blockquote>
<blockquote>
<p>视图的数据能否更新？答案视情况而定。</p>
</blockquote>
<blockquote>
<p>更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p>
</blockquote>
<blockquote>
<p>如果视图定义中有以下操作，则不能进行视图的更新：❑ 分组（使用GROUP BY和HAVING）；❑ 联结；❑ 子查询；❑ 并；❑ 聚集函数（Min()、Count()、Sum()等）；❑ DISTINCT；❑ 导出（计算）列。</p>
</blockquote>
<blockquote>
<p> 一般，应该将视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）。</p>
</blockquote>
<h2 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h2><blockquote>
<p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
</blockquote>
<blockquote>
<p>需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</p>
</blockquote>
<blockquote>
<p>简化对变动的管理。</p>
</blockquote>
<blockquote>
<p>使用存储过程比使用单独的SQL语句要快</p>
</blockquote>
<blockquote>
<p>简单、安全、高性能</p>
</blockquote>
<blockquote>
<p>存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。</p>
</blockquote>
<blockquote>
<p>调用</p>
</blockquote>
<blockquote>
<p>CALL接受存储过程的名字以及需要传递给它的任意参数</p>
</blockquote>
<blockquote>
<p>如果命令行实用程序要解释存储过程自身内的；字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。</p>
</blockquote>
<blockquote>
<p>临时更改命令行实用程序的语句分隔符</p>
</blockquote>
<blockquote>
<p>DELIMITER //</p>
</blockquote>
<blockquote>
<p>使用//作为新的语句结束分隔符</p>
</blockquote>
<blockquote>
<p>除\符号外，任何字符都可以用作语句分隔符。</p>
</blockquote>
<blockquote>
<p>因为存储过程实际上是一种函数，所以存储过程名后需要有()符号（即使不传递参数也需要）</p>
</blockquote>
<blockquote>
<p>存储过程在创建之后，被保存在服务器上以供使用，直至被删除</p>
</blockquote>
<blockquote>
<p>请注意没有使用后面的()，只给出存储过程名</p>
</blockquote>
<blockquote>
<p>如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IFEXISTS。</p>
</blockquote>
<blockquote>
<p>一般，存储过程并不显示结果，而是把结果返回给你指定的变量。</p>
</blockquote>
<blockquote>
<p>关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）</p>
</blockquote>
<blockquote>
<p>IN（传递给存储过程）</p>
</blockquote>
<blockquote>
<p>OUT（从存储过程传出</p>
</blockquote>
<blockquote>
<p>INOUT（对存储过程传入和传出）</p>
</blockquote>
<blockquote>
<p>记录集不是允许的类型，因此，不能通过一个参数返回多个行和列</p>
</blockquote>
<blockquote>
<p>所有MySQL变量都必须以@开始</p>
</blockquote>
<blockquote>
<p>在调用时，这条语句并不显示任何数据。它返回以后可以显示（或在其他处理中使用）的变量。为了显示检索出的产品平均价格，可如下进行：</p>
</blockquote>
<blockquote>
<p>业务规则和智能处理</p>
</blockquote>
<blockquote>
<p>注释（前面放置–）</p>
</blockquote>
<blockquote>
<p>DECLARE语句定义了两个局部变量</p>
</blockquote>
<blockquote>
<p>COMMENT值</p>
</blockquote>
<blockquote>
<p>它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示。</p>
</blockquote>
<blockquote>
<p>IF语句还支持ELSEIF和ELSE子句（前者还使用THEN子句，后者不使用）</p>
</blockquote>
<blockquote>
<p>显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE语句：</p>
</blockquote>
<blockquote>
<p>获得包括何时、由谁创建等详细信息的存储过程列表，使用SHOW PROCEDURESTATUS。</p>
</blockquote>
<h2 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h2><blockquote>
<p>在检索出来的行中前进或后退一行或多行。这就是使用游标的原因</p>
</blockquote>
<blockquote>
<p>游标（cursor）</p>
</blockquote>
<blockquote>
<p>数据库查询</p>
</blockquote>
<blockquote>
<p>结果集</p>
</blockquote>
<blockquote>
<p>主要用于交互式应用</p>
</blockquote>
<blockquote>
<p>MySQL游标只能用于存储过程（和函数）</p>
</blockquote>
<blockquote>
<p>定义要使用的SELECT语句</p>
</blockquote>
<blockquote>
<p>把数据实际检索出来</p>
</blockquote>
<blockquote>
<p>在结束游标使用时，必须关闭游标</p>
</blockquote>
<blockquote>
<p>游标用DECLARE语句创建</p>
</blockquote>
<blockquote>
<p>OPEN CURSOR语句</p>
</blockquote>
<blockquote>
<p>存储检索出的数据以供浏览和滚动</p>
</blockquote>
<blockquote>
<p>CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。</p>
</blockquote>
<blockquote>
<p>果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p>
</blockquote>
<blockquote>
<p>FETCH指定检索什么数据（所需的列）</p>
</blockquote>
<blockquote>
<p>向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）</p>
</blockquote>
<blockquote>
<p>自动从第一行开始</p>
</blockquote>
<blockquote>
<p>REPEAT</p>
</blockquote>
<blockquote>
<p>UNTIL done END REPEAT</p>
</blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
<blockquote>
<p>CONTINUE HANDLER</p>
</blockquote>
<blockquote>
<p>MySQL还支持循环语句，它可用来重复执行代码，直到使用LEAVE语句手动退出为止</p>
</blockquote>
<blockquote>
<p>REPEAT语句的语法使它更适合于对游标进行循环。</p>
</blockquote>
<h2 id="第25章-使用触发器"><a href="#第25章-使用触发器" class="headerlink" title="第25章 使用触发器"></a>第25章 使用触发器</h2><blockquote>
<p>要在某个表发生更改时自动处理。这确切地说就是触发器</p>
</blockquote>
<blockquote>
<p>在创建触发器时，需要给出4条信息：❑ 唯一的触发器名；❑ 触发器关联的表；❑ 触发器应该响应的活动（DELETE、INSERT或UPDATE）；❑ 触发器何时执行（处理之前或之后）</p>
</blockquote>
<blockquote>
<p>AFTER INSERT，</p>
</blockquote>
<blockquote>
<p>，文本Product added将对每个插入的行显示一次</p>
</blockquote>
<blockquote>
<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建</p>
</blockquote>
<blockquote>
<p>引用一个名为NEW的虚拟表，访问被插入的行</p>
</blockquote>
<blockquote>
<p>NEW. order_num</p>
</blockquote>
<blockquote>
<p>通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据</p>
</blockquote>
<blockquote>
<p>引用一个名为OLD的虚拟表，访问被删除的行</p>
</blockquote>
<blockquote>
<p>OLD中的值全都是只读的，不能更新。</p>
</blockquote>
<blockquote>
<p>使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器来说）为，如果由于某种原因，订单不能存档，DELETE本身将被放弃</p>
</blockquote>
<blockquote>
<p>使用BEGIN END块的好处是触发器能容纳多条SQL语句（在BEGIN END块中一条挨着一条）</p>
</blockquote>
<blockquote>
<p>引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值</p>
</blockquote>
<h2 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h2><blockquote>
<p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p>
</blockquote>
<blockquote>
<p>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果</p>
</blockquote>
<blockquote>
<p>发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p>
</blockquote>
<blockquote>
<p>❑ 事务（transaction）指一组SQL语句；❑ 回退（rollback）指撤销指定SQL语句的过程；❑ 提交（commit）指将未存储的SQL语句结果写入数据库表；❑ 保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同）。</p>
</blockquote>
<blockquote>
<p>关键在于将SQL语句组分解为逻辑块</p>
</blockquote>
<blockquote>
<p>标识事务的开始</p>
</blockquote>
<blockquote>
<p>ROLLBACK命令用来回退（撤销）MySQL语句</p>
</blockquote>
<blockquote>
<p>用一条ROLLBACK语句回退STARTTRANSACTION之后的所有语句</p>
</blockquote>
<blockquote>
<p>ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）。</p>
</blockquote>
<blockquote>
<p>哪些语句可以回退？ 事务处理用来管理INSERT、UPDATE和DELETE语句</p>
</blockquote>
<blockquote>
<p>不能回退CREATE或DROP操作</p>
</blockquote>
<blockquote>
<p>在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句</p>
</blockquote>
<blockquote>
<p>因为涉及更新两个数据库表orders和orderitems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。</p>
</blockquote>
<blockquote>
<p>更复杂的事务处理可能需要部分提交或回退。</p>
</blockquote>
<blockquote>
<p>必须能在事务处理块中合适的位置放置占位符</p>
</blockquote>
<blockquote>
<p>占位符称为保留点</p>
</blockquote>
<blockquote>
<p>SAVEPOINT</p>
</blockquote>
<blockquote>
<p> 保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。</p>
</blockquote>
<blockquote>
<p>任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句：</p>
</blockquote>
<blockquote>
<p>设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）</p>
</blockquote>
<blockquote>
<p>针对每个连接而不是服务器</p>
</blockquote>
<h2 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h2><blockquote>
<p>❑ 字符集为字母和符号的集合；❑ 编码为某个字符集成员的内部表示；❑ 校对为规定字符如何比较的指令。</p>
</blockquote>
<blockquote>
<p>字符集</p>
</blockquote>
<blockquote>
<p>校对</p>
</blockquote>
<h2 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h2><blockquote>
<p>MySQL创建一个名为root的用户账号，它对整个MySQL服务器具有完全的控制</p>
</blockquote>
<blockquote>
<p>不过在现实世界的日常工作中，决不能使用root</p>
</blockquote>
<blockquote>
<p>mysql数据库有一个名为user的表，它包含所有用户账号。user表有一个名为user的列，它存储用户登录名</p>
</blockquote>
<blockquote>
<p>IDENTIFIED BY指定的口令为纯文本，MySQL将在保存到user表之前对其进行加密。为了作为散列值指定口令，使用IDENTIFIED BY PASSWORD</p>
</blockquote>
<blockquote>
<p>CREATE USER是最清楚和最简单的句子。此外，也可以通过直接插入行到user表来增加用户，不过为安全起见，一般不建议这样做</p>
</blockquote>
<blockquote>
<p>删除用户账号和所有相关的账号权限</p>
</blockquote>
<blockquote>
<p>MySQL 5以前，DROP USER只能用来删除用户账号，不能删除相关的权限</p>
</blockquote>
<blockquote>
<p>新创建的用户账号没有访问权限</p>
</blockquote>
<blockquote>
<p>MySQL的权限用用户名和主机名结合定义</p>
</blockquote>
<blockquote>
<p>此GRANT允许用户</p>
</blockquote>
<blockquote>
<p>使用SELECT</p>
</blockquote>
<blockquote>
<p>GRANT的反操作为REVOKE，用它来撤销特定的权限</p>
</blockquote>
<blockquote>
<p>被撤销的访问权限必须存在，否则会出错。</p>
</blockquote>
<blockquote>
<p>在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求</p>
</blockquote>
<blockquote>
<p>副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用</p>
</blockquote>
<blockquote>
<p>列出各权限并用逗号分隔，将多条GRANT语句串在一起</p>
</blockquote>
<blockquote>
<p>更改用户口令，可使用SET PASSWORD语句</p>
</blockquote>
<blockquote>
<p>新口令必须传递到Password()函数进行加密</p>
</blockquote>
<blockquote>
<p>在不指定用户名时，SET PASSWORD更新当前登录用户的口令。</p>
</blockquote>
<h2 id="第29章-数据库维护"><a href="#第29章-数据库维护" class="headerlink" title="第29章 数据库维护"></a>第29章 数据库维护</h2><blockquote>
<p>MySQL数据库是基于磁盘的文件</p>
</blockquote>
<blockquote>
<p>由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。</p>
</blockquote>
<blockquote>
<p>转储所有数据库内容到某个外部文件</p>
</blockquote>
<blockquote>
<p>从一个数据库复制所有数据</p>
</blockquote>
<blockquote>
<p>BACKUP TABLE</p>
</blockquote>
<blockquote>
<p>SELECT INTO OUTFILE</p>
</blockquote>
<blockquote>
<p>数据可以用RESTORE TABLE来复原。</p>
</blockquote>
<blockquote>
<p>首先刷新未写数据 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSH TABLES语句。</p>
</blockquote>
<blockquote>
<p> ANALYZE TABLE，用来检查表键是否正确</p>
</blockquote>
<blockquote>
<p> CHECK TABLE用来针对许多问题对表进行检查</p>
</blockquote>
<blockquote>
<p>CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描</p>
</blockquote>
<blockquote>
<p>下面是几个重要的mysqld命令行选项：❑ –help显示帮助——一个选项列表；❑ –safe-mode装载减去某些最佳配置的服务器；❑ –verbose显示全文本消息（为获得更详细的帮助消息与–help联合使用）；❑ –version显示版本信息然后退出。</p>
</blockquote>
<blockquote>
<p>错误日志。它包含启动和关闭问题以及任意关键错误的细节</p>
</blockquote>
<blockquote>
<p>位于data目录中</p>
</blockquote>
<blockquote>
<p>查询日志。它记录所有MySQL活动，在诊断问题时非常有用</p>
</blockquote>
<blockquote>
<p>位于data目录中</p>
</blockquote>
<blockquote>
<p>二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句</p>
</blockquote>
<blockquote>
<p>位于data目录内</p>
</blockquote>
<blockquote>
<p>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询</p>
</blockquote>
<blockquote>
<p>在确定数据库何处需要优化很有用</p>
</blockquote>
<blockquote>
<p>位于data目录中</p>
</blockquote>
<blockquote>
<p>使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。</p>
</blockquote>
<h2 id="第30章-改善性能"><a href="#第30章-改善性能" class="headerlink" title="第30章 改善性能"></a>第30章 改善性能</h2><blockquote>
<p>在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说，应该坚持遵循这些硬件建议。</p>
</blockquote>
<blockquote>
<p>MySQL是用一系列的默认设置预先配置的，这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等</p>
</blockquote>
<blockquote>
<p>多用户多线程</p>
</blockquote>
<blockquote>
<p>你遇到显著的性能不良，可使用SHOW PROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）</p>
</blockquote>
<blockquote>
<p>存储过程</p>
</blockquote>
<blockquote>
<p>比一条一条地执行其中的各条MySQL语句快</p>
</blockquote>
<blockquote>
<p>不要用SELECT *</p>
</blockquote>
<blockquote>
<p>❑ 有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作</p>
</blockquote>
<blockquote>
<p>导入数据时，应该关闭自动提交</p>
</blockquote>
<blockquote>
<p>删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们。</p>
</blockquote>
<blockquote>
<p>索引数据库表以改善数据检索的性能</p>
</blockquote>
<blockquote>
<p>分析使用的SELECT语句以找出重复的WHERE和ORDER BY子句</p>
</blockquote>
<blockquote>
<p>有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进。</p>
</blockquote>
<blockquote>
<p>索引改善数据检索的性能，但损害数据插入、删除和更新的性能</p>
</blockquote>
<blockquote>
<p>收集数据且不经常被搜索，则在有必要之前不要索引它们</p>
</blockquote>
<blockquote>
<p> LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE</p>
</blockquote>
<blockquote>
<p>理想的优化和配置也会改变</p>
</blockquote>
<h2 id="附录C-MySQL语句的语法"><a href="#附录C-MySQL语句的语法" class="headerlink" title="附录C MySQL语句的语法"></a>附录C MySQL语句的语法</h2><blockquote>
<p>方括号中</p>
</blockquote>
<blockquote>
<p>是可选的</p>
</blockquote>
<blockquote>
<p>更新已存在表的模式</p>
</blockquote>
<blockquote>
<p>将事务处理写到数据库</p>
</blockquote>
<blockquote>
<p>在一个或多个列上创建索引</p>
</blockquote>
<h2 id="附录D-MySQL数据类型"><a href="#附录D-MySQL数据类型" class="headerlink" title="附录D MySQL数据类型"></a>附录D MySQL数据类型</h2><blockquote>
<p>定长串接受长度固定的字符串，其长度是在创建表时指定的</p>
</blockquote>
<blockquote>
<p>定长列不允许多于指定的字符数目</p>
</blockquote>
<blockquote>
<p>CHAR</p>
</blockquote>
<blockquote>
<p>变长串存储可变长度的文本。有些变长数据类型具有最大的定长，而有些则是完全变长的</p>
</blockquote>
<blockquote>
<p>TEXT</p>
</blockquote>
<blockquote>
<p>为什么还要使用定长数据类型？回答是因为性能</p>
</blockquote>
<blockquote>
<p>不允许对变长列（或一个列的可变部分）进行索引</p>
</blockquote>
<blockquote>
<p>不管使用何种形式的串数据类型，串值都必须括在引号内（通常单引号更好）。</p>
</blockquote>
<blockquote>
<p>如果数值是计算（求和、平均等）中使用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p>
</blockquote>
<blockquote>
<p>默认情况为有符号，但如果你知道自己不需要存储负值，可以使用UNSIGNED关键字</p>
</blockquote>
<blockquote>
<p>与串不一样，数值不应该括在引号内。</p>
</blockquote>
<blockquote>
<p> MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)</p>
</blockquote>
<blockquote>
<p>可存储任何数据（甚至包括二进制信息）</p>
</blockquote>

      
    </div>

    

    
    
    

    

    
      
    
    

    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Hunter</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="https://hunter1023.github.io/2020/06/14/MySQL必知必会/" title="MySQL必知必会">https://hunter1023.github.io/2020/06/14/MySQL必知必会/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
          
            <a href="/tags/SQL/" rel="tag"><i class="fa fa-tag"></i> SQL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/13/Python入门到实践/" rel="next" title="Python入门到实践">
                <i class="fa fa-chevron-left"></i> Python入门到实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/16/MySQL报错的分类与解决方法/" rel="prev" title="MySQL报错的分类与解决方法">
                MySQL报错的分类与解决方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
				<a href="/">
				  <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Hunter">
				</a>
            
              <p class="site-author-name" itemprop="name">Hunter</p>
              <div class="site-description motion-element" itemprop="description">Tough times never last, but tough people do.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第1章-了解SQL"><span class="nav-number">1.</span> <span class="nav-text">第1章 了解SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第2章-MySQL简介"><span class="nav-number">2.</span> <span class="nav-text">第2章 MySQL简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置MySQL环境变量"><span class="nav-number">2.1.</span> <span class="nav-text">配置MySQL环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#统一字符集为UTF-8"><span class="nav-number">2.2.</span> <span class="nav-text">统一字符集为UTF-8</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第3章-使用MySQL"><span class="nav-number">3.</span> <span class="nav-text">第3章 使用MySQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第4章-检索数据"><span class="nav-number">4.</span> <span class="nav-text">第4章 检索数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第5章-排序检索数据"><span class="nav-number">5.</span> <span class="nav-text">第5章 排序检索数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第6章-过滤数据"><span class="nav-number">6.</span> <span class="nav-text">第6章 过滤数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第7章-数据过滤"><span class="nav-number">7.</span> <span class="nav-text">第7章 数据过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#组合WHERE子句"><span class="nav-number">7.1.</span> <span class="nav-text">组合WHERE子句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算次序"><span class="nav-number">7.1.1.</span> <span class="nav-text">计算次序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IN操作符"><span class="nav-number">7.2.</span> <span class="nav-text">IN操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NOT操作符"><span class="nav-number">7.3.</span> <span class="nav-text">NOT操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章-用通配符进行过滤"><span class="nav-number">8.</span> <span class="nav-text">第8章 用通配符进行过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LIKE操作符"><span class="nav-number">8.1.</span> <span class="nav-text">LIKE操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#百分号-通配符"><span class="nav-number">8.1.1.</span> <span class="nav-text">百分号(%)通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#下划线-通配符"><span class="nav-number">8.1.2.</span> <span class="nav-text">下划线(_)通配符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用通配符的技巧"><span class="nav-number">8.2.</span> <span class="nav-text">使用通配符的技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第9章-用正则表达式进行搜索"><span class="nav-number">9.</span> <span class="nav-text">第9章 用正则表达式进行搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第10章-创建计算字段"><span class="nav-number">10.</span> <span class="nav-text">第10章 创建计算字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第11章-使用数据处理函数"><span class="nav-number">11.</span> <span class="nav-text">第11章 使用数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">11.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用函数"><span class="nav-number">11.2.</span> <span class="nav-text">使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文本处理函数"><span class="nav-number">11.2.1.</span> <span class="nav-text">文本处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日期和时间处理函数"><span class="nav-number">11.2.2.</span> <span class="nav-text">日期和时间处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值处理函数"><span class="nav-number">11.2.3.</span> <span class="nav-text">数值处理函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第12章-汇总数据"><span class="nav-number">12.</span> <span class="nav-text">第12章 汇总数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#聚集函数"><span class="nav-number">12.1.</span> <span class="nav-text">聚集函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AVG-函数"><span class="nav-number">12.1.1.</span> <span class="nav-text">AVG()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COUNT-函数"><span class="nav-number">12.1.2.</span> <span class="nav-text">COUNT()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAX-函数"><span class="nav-number">12.1.3.</span> <span class="nav-text">MAX()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MIN-函数"><span class="nav-number">12.1.4.</span> <span class="nav-text">MIN()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SUM-函数"><span class="nav-number">12.1.5.</span> <span class="nav-text">SUM()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚集不同值"><span class="nav-number">12.2.</span> <span class="nav-text">聚集不同值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合聚集函数"><span class="nav-number">12.3.</span> <span class="nav-text">组合聚集函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第13章-分组数据"><span class="nav-number">13.</span> <span class="nav-text">第13章 分组数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据分组"><span class="nav-number">13.1.</span> <span class="nav-text">数据分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建分组"><span class="nav-number">13.2.</span> <span class="nav-text">创建分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤分组"><span class="nav-number">13.3.</span> <span class="nav-text">过滤分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组和排序"><span class="nav-number">13.4.</span> <span class="nav-text">分组和排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELECT子句顺序"><span class="nav-number">13.5.</span> <span class="nav-text">SELECT子句顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第14章-使用子查询"><span class="nav-number">14.</span> <span class="nav-text">第14章 使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#子查询"><span class="nav-number">14.1.</span> <span class="nav-text">子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用子查询进行过滤"><span class="nav-number">14.2.</span> <span class="nav-text">利用子查询进行过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为计算字段使用子查询"><span class="nav-number">14.3.</span> <span class="nav-text">作为计算字段使用子查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第15章-联结表"><span class="nav-number">15.</span> <span class="nav-text">第15章 联结表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第16章-创建高级联结"><span class="nav-number">16.</span> <span class="nav-text">第16章 创建高级联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自联结"><span class="nav-number">16.1.</span> <span class="nav-text">自联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自然联结"><span class="nav-number">16.2.</span> <span class="nav-text">自然联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部联结"><span class="nav-number">16.3.</span> <span class="nav-text">外部联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用联结和联结条件"><span class="nav-number">16.4.</span> <span class="nav-text">使用联结和联结条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第17章-组合查询"><span class="nav-number">17.</span> <span class="nav-text">第17章 组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#组合查询"><span class="nav-number">17.1.</span> <span class="nav-text">组合查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建组合查询"><span class="nav-number">17.2.</span> <span class="nav-text">创建组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用UNION"><span class="nav-number">17.2.1.</span> <span class="nav-text">使用UNION</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNION规则"><span class="nav-number">17.2.2.</span> <span class="nav-text">UNION规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含或取消重复的行"><span class="nav-number">17.2.3.</span> <span class="nav-text">包含或取消重复的行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对组合查询结果排序"><span class="nav-number">17.2.4.</span> <span class="nav-text">对组合查询结果排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第18章-全文本搜索"><span class="nav-number">18.</span> <span class="nav-text">第18章 全文本搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第19章-插入数据"><span class="nav-number">19.</span> <span class="nav-text">第19章 插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据插入"><span class="nav-number">19.1.</span> <span class="nav-text">数据插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入完整的行"><span class="nav-number">19.2.</span> <span class="nav-text">插入完整的行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入多个行"><span class="nav-number">19.3.</span> <span class="nav-text">插入多个行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入检索出的数据"><span class="nav-number">19.4.</span> <span class="nav-text">插入检索出的数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第20章-更新和删除数据"><span class="nav-number">20.</span> <span class="nav-text">第20章 更新和删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#更新数据"><span class="nav-number">20.1.</span> <span class="nav-text">更新数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除数据"><span class="nav-number">20.2.</span> <span class="nav-text">删除数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新和删除的指导原则"><span class="nav-number">20.3.</span> <span class="nav-text">更新和删除的指导原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第21章-创建和操纵表"><span class="nav-number">21.</span> <span class="nav-text">第21章 创建和操纵表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建表"><span class="nav-number">21.1.</span> <span class="nav-text">创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#表创建基础"><span class="nav-number">21.1.1.</span> <span class="nav-text">表创建基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用NULL值"><span class="nav-number">21.1.2.</span> <span class="nav-text">使用NULL值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主键再介绍"><span class="nav-number">21.1.3.</span> <span class="nav-text">主键再介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用AUTO-INCREMENT"><span class="nav-number">21.1.4.</span> <span class="nav-text">使用AUTO_INCREMENT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指定默认值"><span class="nav-number">21.1.5.</span> <span class="nav-text">指定默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引擎类型"><span class="nav-number">21.1.6.</span> <span class="nav-text">引擎类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新表"><span class="nav-number">21.2.</span> <span class="nav-text">更新表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除表"><span class="nav-number">21.3.</span> <span class="nav-text">删除表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重命名表"><span class="nav-number">21.4.</span> <span class="nav-text">重命名表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第22章-使用视图"><span class="nav-number">22.</span> <span class="nav-text">第22章 使用视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第23章-使用存储过程"><span class="nav-number">23.</span> <span class="nav-text">第23章 使用存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第24章-使用游标"><span class="nav-number">24.</span> <span class="nav-text">第24章 使用游标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第25章-使用触发器"><span class="nav-number">25.</span> <span class="nav-text">第25章 使用触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第26章-管理事务处理"><span class="nav-number">26.</span> <span class="nav-text">第26章 管理事务处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第27章-全球化和本地化"><span class="nav-number">27.</span> <span class="nav-text">第27章 全球化和本地化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第28章-安全管理"><span class="nav-number">28.</span> <span class="nav-text">第28章 安全管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第29章-数据库维护"><span class="nav-number">29.</span> <span class="nav-text">第29章 数据库维护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第30章-改善性能"><span class="nav-number">30.</span> <span class="nav-text">第30章 改善性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录C-MySQL语句的语法"><span class="nav-number">31.</span> <span class="nav-text">附录C MySQL语句的语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录D-MySQL数据类型"><span class="nav-number">32.</span> <span class="nav-text">附录D MySQL数据类型</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hunter</span>

  

  
</div>









<span id="busuanzi_container_site_uv">
  本站访问次数：<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
</span>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  

  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'bfNJwb6OakQAqcsORwzGDDVj-gzGzoHsz',
    appKey: 'bSLvxGSfThsJp8vbhiMV4LUd',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<style>
  .copy-btn {
    display: inline-block;
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 700;
    line-height: 20px;
    color: #333;
    white-space: nowrap;
    vertical-align: middle;
    cursor: pointer;
    
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
    
    user-select: none;
    outline: 0;
  }

  .highlight-wrap .copy-btn {
    transition: opacity .3s ease-in-out;
    opacity: 0;
    padding: 2px 6px;
    position: absolute;
    
      right: 4px;
      top: 8px;
    
  }

  .highlight-wrap:hover .copy-btn,
  .highlight-wrap .copy-btn:focus {
    opacity: 1;
  }

  .highlight-wrap {
    position: relative;
  }
</style>
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


</body>
</html>
