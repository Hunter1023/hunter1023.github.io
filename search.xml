<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python基础练习题</title>
      <link href="/2020/07/03/Python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2020/07/03/Python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="求三位数组合"><a href="#求三位数组合" class="headerlink" title="求三位数组合"></a>求三位数组合</h2><p>已知有一个list，里面有<strong>4个数字</strong>，分别是3，6，2，7 ，这四个数字<strong>能组成多少个互不相同且无重复数字的三位数</strong>？比如362算一个，326算一个，请逐个输出他们。</p><hr><p><strong>分析</strong></p><ol><li>三层嵌套循环，<strong>每一层循环从list中取出一个数字</strong>，这三个数字组成一个三位数</li><li>需要对取出来的三个数字进行<strong>去重</strong></li></ol><hr><p><strong>解答</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">lst = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">number_lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> lst:</span><br><span class="line">       <span class="keyword">for</span> k <span class="keyword">in</span> lst:</span><br><span class="line">           <span class="keyword">if</span> i != j <span class="keyword">and</span> i != k <span class="keyword">and</span> j != k: <span class="comment"># 去重</span></span><br><span class="line">               number_lst.append(</span><br><span class="line">       <span class="string">'&#123;first&#125;&#123;second&#125;&#123;third&#125;'</span>.format(</span><br><span class="line">               first=i, second=j, third=k))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'共有&#123;count&#125;个符合条件的数字'</span>.format(</span><br><span class="line">   count=len(number_lst)))</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> number_lst:</span><br><span class="line">   <span class="keyword">print</span> item</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>注意字符串format的用法，首先要在字符串里定义哪个区域是需要被替换的，并在大括号里定义一个名字，然后在format函数的参数里指明这个名字被谁替换</p><hr><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><ol><li>打印10000以内的完全平方数</li><li>如果一个数<strong>加100</strong>是一个完全平方数，<strong>加268</strong>也是一个完全平方数，求10000以内所有符合这个要求的数值</li></ol><hr><p><strong>解答</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一题 方法一</span></span><br><span class="line">numbers = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10001</span>)]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    print(num)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第一题 方法二</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>  num &lt; <span class="number">10001</span>:</span><br><span class="line">    print(num*num)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第二题</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    square = num*num</span><br><span class="line">    <span class="keyword">if</span> square &gt; <span class="number">10268</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    squares.append(square)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> square <span class="keyword">in</span> squares:</span><br><span class="line">    <span class="keyword">if</span> (square + <span class="number">168</span>) <span class="keyword">in</span> squares:</span><br><span class="line">        print(square - <span class="number">100</span>)</span><br></pre></td></tr></table></figure><ul><li>有一个数，假设加100后的值为A，加268之后的值是B，根据题目要求，A和B都是完全平方数，那么B-A = 168</li><li>程序先找出10268以内的所有完全平方数，然后遍历，如果一个完全平方数加168 以后还是完全平方数，那么这个完全平方数减去100，就是要找的数值</li></ul><hr><h2 id="打印乘法口诀表"><a href="#打印乘法口诀表" class="headerlink" title="打印乘法口诀表"></a>打印乘法口诀表</h2><p>打印乘法口诀表，效果如下表所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1 = 1  </span><br><span class="line">1*2 = 2 2*2 = 4  </span><br><span class="line">1*3 = 3 2*3 = 6 3*3 = 9  </span><br><span class="line">1*4 = 4 2*4 = 8 3*4 = 12 4*4 = 16  </span><br><span class="line">1*5 = 5 2*5 = 103*5 = 15 4*5 = 20 5*5 = 25  </span><br><span class="line">1*6 = 6 2*6 = 12 3*6 = 18 4*6 = 24 5*6 = 30 6*6 = 36  </span><br><span class="line">1*7 = 7 2*7 = 14 3*7 = 21 4*7 = 28 5*7 = 35 6*7 = 42 7*7 = 49  </span><br><span class="line">1*8 = 8 2*8 = 16 3*8 = 24 4*8 = 32 5*8 = 40 6*8 = 48 7*8 = 56 8*8 = 64  </span><br><span class="line">1*9 = 9 2*9 = 18 3*9 = 27 4*9 = 36 5*9 = 45 6*9 = 54 7*9 = 63 8*9 = 72 9*9 = 81</span><br></pre></td></tr></table></figure><hr><p><strong>解答</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_line</span><span class="params">(number)</span>:</span></span><br><span class="line">    line = <span class="string">""</span></span><br><span class="line">    str_foramt = <span class="string">"&#123;left&#125;*&#123;right&#125; = &#123;result&#125;"</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">1</span>:</span><br><span class="line">            line += <span class="string">" \t"</span></span><br><span class="line">        line += str_foramt.format(left=i, right=number, result=i*number)</span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    print(get_line(i))</span><br></pre></td></tr></table></figure><hr><h2 id="输出水仙花数"><a href="#输出水仙花数" class="headerlink" title="输出水仙花数"></a>输出水仙花数</h2><p><strong>题目</strong></p><p>输出所有的水仙花数，所谓<strong>水仙花数是指一个三位数</strong>，<strong>各个位上的数的立方相加在一起等于这个三位数</strong>。比如153，1的3次方 + 5的三次方 + 3的三次方 等于153。</p><hr><p><strong>解答</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">1000</span>):</span><br><span class="line">    i = n / <span class="number">100</span>         <span class="comment"># 获取百位数</span></span><br><span class="line">    j = n / <span class="number">10</span> % <span class="number">10</span>     <span class="comment"># 获取十位数</span></span><br><span class="line">    k = n % <span class="number">10</span>          <span class="comment"># 获取个位数</span></span><br><span class="line">    <span class="keyword">if</span> n == i**<span class="number">3</span> + j**<span class="number">3</span> + k**<span class="number">3</span>:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure><hr><h2 id="输出学生分数的考评等级"><a href="#输出学生分数的考评等级" class="headerlink" title="输出学生分数的考评等级"></a>输出学生分数的考评等级</h2><p>允许用户从终端输入一个分数，程序输出这个分数所属的考评等级，90到100分是A，60到89是B，60分以下是C</p><hr><p><strong>解答</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    scores = int(input(<span class="string">"请输入分数："</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> scores &gt;= <span class="number">90</span> <span class="keyword">and</span> scores &lt;= <span class="number">100</span>:</span><br><span class="line">        grade = <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">elif</span> scores &gt;= <span class="number">60</span>:</span><br><span class="line">        grade = <span class="string">'B'</span></span><br><span class="line">    <span class="keyword">elif</span> scores &gt;= <span class="number">0</span>:</span><br><span class="line">        grade = <span class="string">'C'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(grade)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python项目——数据可视化</title>
      <link href="/2020/06/28/Python%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2020/06/28/Python%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h2><ul><li>数据<strong>可视化</strong>：通过可视化表示来探索数据</li><li>数据<strong>挖掘</strong>：使用代码来探索<strong>数据集的规律和关联</strong></li></ul><h3 id="安装-matplotlib"><a href="#安装-matplotlib" class="headerlink" title="安装 matplotlib"></a>安装 matplotlib</h3><h4 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h4><p><strong>pip</strong>是一个以Python写成的<strong>软件包管理系统</strong>，它可以<strong>安装和管理软件包</strong>。</p><p>大多数较新的Python版本都自带pip，因此首先可检查系统是否已经安装了pip。</p><ul><li><p>在Windows系统中检查是否安装了pip</p><p>  打开一个终端窗口，并执行如下命令：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; python -m pip --version</span><br><span class="line">pip 20.1.1 from C:\Users\Hunter\AppData\Local\Programs\Python\Python38-32\lib\site-packages\pip (python 3.8)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="在-Windows-系统中安装-matplotlib"><a href="#在-Windows-系统中安装-matplotlib" class="headerlink" title="在 Windows 系统中安装 matplotlib"></a>在 Windows 系统中安装 matplotlib</h4><p>在Windows系统中，首先需要<strong>安装Visual Studio</strong>。接下来，访问<a href="https://pypi.org/project/matplotlib/#files" target="_blank" rel="noopener">matplotlib · PyPI</a>，查找与使用的Python版本、操作系统相匹配的<code>.whl</code>文件。</p><p>将这个<code>.whl</code>文件复制到<strong>项目所在文件夹</strong>，打开命令窗口，使用pip来安装matplotlib:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --user matplotlib-3.2.2-cp38-cp38-win32.whl</span><br></pre></td></tr></table></figure><hr><h4 id="测试-matplotlib"><a href="#测试-matplotlib" class="headerlink" title="测试 matplotlib"></a>测试 matplotlib</h4><p>安装必要的包后，对安装进行测试。为此，首先使用命令python或python3启动一个终端会话，再尝试导入matplotlib:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; import matplotlib</span><br></pre></td></tr></table></figure><p>如果<strong>没有出现任何错误消息，就说明成功安装了 matplotlib</strong>。</p><hr><h3 id="绘制简单的折线图"><a href="#绘制简单的折线图" class="headerlink" title="绘制简单的折线图"></a>绘制简单的折线图</h3><p>我们将使用平方数序列1、4、9、16和25来绘制这个图表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">%matplotlib inline <span class="comment"># 让生成的图形嵌入jupyter notebook中</span></span><br><span class="line"></span><br><span class="line">    squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">    plt.plot(squares)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><ul><li><p><strong>模块pyplot</strong>包含很多用于生成图表的函数。</p></li><li><p><code>plt.show()</code>打开<strong>matplotlib查看器</strong>，并显示绘制的图形。查看器能够<strong>缩放和导航图形</strong>，另外，<strong>单击磁盘图表可将图形保存起来</strong>。</p></li></ul><h4 id="修改标签文字和线条粗细"><a href="#修改标签文字和线条粗细" class="headerlink" title="修改标签文字和线条粗细"></a>修改标签文字和线条粗细</h4><p>上述代码通过matplotlib查看器显示的图形，<strong>标签文字太小、线条太细</strong>。下面通过一些定制来改善这个图形的可读性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">plt.plot(squares, linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><strong>参数linewidth</strong>决定了<code>plot()</code>绘制的<strong>线条的粗细</strong></li><li>函数<code>title()</code>给图表<strong>指定标题</strong></li><li>参数fontsize指定了图表中<strong>文字的大小</strong></li><li>函数<code>xlabel()</code>和<code>ylabel()</code></li><li>函数<code>tick_params()</code>设置<strong>刻度的样式</strong></li></ul><hr><h4 id="校正图形"><a href="#校正图形" class="headerlink" title="校正图形"></a>校正图形</h4><p>图形更容易阅读后，我们发现<strong>没有正确地绘制数据</strong>：折线图的终点指出4.0的平方为25。下面来修复这个问题。</p><p><strong>当你向<code>plot()</code>提供一系列数字时，它假设第一个数据点对应的x坐标值为0</strong>，但我们的第一个点对应的x值为1。为改变这种默认行为，我们可以给<code>plot()</code><strong>同时提供输入值和输出值</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">input_values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">plt.plot(input_values, squares, linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h4 id="使用-scatter-绘制散点图并设置其样式"><a href="#使用-scatter-绘制散点图并设置其样式" class="headerlink" title="使用 scatter() 绘制散点图并设置其样式"></a>使用 <code>scatter()</code> 绘制散点图并设置其样式</h4><p>有时候，需要<strong>绘制散点图</strong>并<strong>设置各个数据点的样式</strong>。例如，你可能想<strong>以一种颜色显示较小的值</strong>，用<strong>另一种颜色显示较大的值</strong>。绘制大型数据集时，还可以<strong>对每个点都设置相同的样式，再使用不同的样式选项重新绘制某些点，以突出它们</strong>。</p><p><strong>要绘制简单的点，可使用函数<code>scatter()</code>，并向它传递一对x和y坐标，它将在指定位置绘制一个点</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>下面来<strong>设置输出的样式</strong>，使其更有趣：添加标题，给轴加上标签，并<strong>确保所有文本都大到能够看清</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(<span class="number">2</span>, <span class="number">4</span>, s=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 显示图例</span></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><code>plt.scatter(2, 4, s=200)</code>：<strong>实参s设置了</strong>绘制图形时使用的<strong>点的尺寸</strong></li></ul><hr><h4 id="使用-scatter-绘制一系列点"><a href="#使用-scatter-绘制一系列点" class="headerlink" title="使用 scatter() 绘制一系列点"></a>使用 scatter() 绘制一系列点</h4><p>要绘制一系列的点，可向<code>scatter()</code>传递两个<strong>分别包含x值和y值的列表</strong>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y_values = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制一个展示 船票Fare 与 乘客年龄和性别 之间关系的散点图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="comment"># 利用query对性别和年龄进行筛选</span></span><br><span class="line">x_values_1 = titanic.query(<span class="string">"Sex == 'male' &amp; Age != 'NaN'"</span>)[<span class="string">'Age'</span>]</span><br><span class="line">y_values_1 = titanic.query(<span class="string">"Sex == 'male' &amp; Age != 'NaN'"</span>)[<span class="string">'Fare'</span>]</span><br><span class="line"></span><br><span class="line">x_values_2 = titanic.query(<span class="string">"Sex == 'female' &amp; Age != 'NaN'"</span>)[<span class="string">'Age'</span>]</span><br><span class="line">y_values_2 = titanic.query(<span class="string">"Sex == 'female' &amp; Age != 'NaN'"</span>)[<span class="string">'Fare'</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values_1, y_values_1, s=<span class="number">10</span>, c=<span class="string">'b'</span>, label=<span class="string">'Male'</span>)</span><br><span class="line">plt.scatter(x_values_2, y_values_2, s=<span class="number">10</span>, c=<span class="string">'r'</span>, label=<span class="string">'Female'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">titanic.loc[titanic[<span class="string">'Sex'</span>] == <span class="string">'male'</span>, <span class="string">'color'</span>] = <span class="string">'b'</span> <span class="comment"># 该处loc[]的用法为：指出 符合条件的行的列值 和 列标签</span></span><br><span class="line">titanic.loc[~(titanic[<span class="string">'Sex'</span>] == <span class="string">'male'</span>), <span class="string">'color'</span>] = <span class="string">'r'</span></span><br><span class="line">plt.scatter(titanic[<span class="string">'Age'</span>].dropna(), titanic[<span class="string">'Fare'</span>].dropna(), s=<span class="number">10</span>, c=titanic[color])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"船票与年龄"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Age"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Fare"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 显示图例</span></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><p>可利用<code>query()</code><strong>排除一些极端值的干扰</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可视化 消费金额和购买数量的关系散点图</span></span><br><span class="line">gu = grouped_user.sum().query(<span class="string">'order_amount &lt; 6000'</span>)</span><br><span class="line">plt.scatter(gu[<span class="string">'order_amount'</span>], gu[<span class="string">'order_products'</span>])</span><br></pre></td></tr></table></figure><hr><h4 id="自动计算数据"><a href="#自动计算数据" class="headerlink" title="自动计算数据"></a>自动计算数据</h4><p>下面是<strong>绘制1000个点</strong>的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = list(range(<span class="number">1</span>, <span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每个坐标轴的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">1100</span>, <span class="number">0</span>, <span class="number">1100000</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>由于这个数据集较大，我们<strong>将点设置得较小</strong>，并使用函数<code>axis()</code><strong>指定了每个坐标轴的取值范围</strong>。</p><hr><h4 id="删除数据点的轮廓"><a href="#删除数据点的轮廓" class="headerlink" title="删除数据点的轮廓"></a>删除数据点的轮廓</h4><p>matplotlib允许你<strong>给散点图中的各个点指定颜色</strong>，默认为<strong>蓝色点</strong>和<strong>黑色轮廓</strong>。在散点图包含的数据点不多时效果很好，但<strong>绘制很多点时，黑色轮廓可能会粘连在一起</strong>。</p><p>要删除数据点的轮廓，可在调用<code>scatter()</code>时传递实参<code>edgecolor=&#39;none&#39;</code>：</p><p><code>plt.scatter(x_values, y_values, edgecolor=&#39;none&#39;, s=40)</code></p><p>注意：matplotlib 2.0.0版本之后，<code>scatter()</code>函数的<strong>实参edgecolor默认为</strong><code>’none&#39;</code>。</p><hr><h4 id="自定义颜色"><a href="#自定义颜色" class="headerlink" title="自定义颜色"></a>自定义颜色</h4><p>要<strong>修改数据点的颜色</strong>，可向<code>scatter()</code>传递<strong>参数c</strong>，并将其<strong>设置为要使用的颜色的名称</strong>，如下所示：</p><p><code>plt.scatter(x_values, y_values, c=&#39;red&#39;, s=40)</code></p><p>还可以使用RGB颜色模式自定义颜色：</p><p><code>plt.scatter(x_values, y_values, c=(0, 0, 0.8), s=40)</code></p><p><strong>值越接近0，指定的颜色越深，值越接近1，指定的颜色越浅</strong>。</p><hr><h4 id="使用颜色映射"><a href="#使用颜色映射" class="headerlink" title="使用颜色映射"></a>使用颜色映射</h4><p><strong>颜色映射</strong>(<strong>colormap</strong>)是一系列颜色，它们<strong>从起始颜色渐变到结束颜色</strong>。在可视化中，<strong>颜色映射用于突出数据的规律</strong>，例如你可能用较浅的颜色来显示较小的值，并用较深的颜色来显示较大的值。</p><p><strong>模块pyplot内置了一组颜色映射</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = list(range(<span class="number">1</span>, <span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues,</span><br><span class="line">           s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><p>我们<strong>将参数c设置成了一个y值列表</strong>，并<strong>使用参数cmap告诉pyplot使用哪个颜色映射</strong>。y值较小的点显示为浅蓝色，y值较大的点显示为深蓝色。</p><p>注意：要了解pyplot中所有的颜色映射，访问<a href="https://matplotlib.org/gallery/color/colormap_reference.html#sphx-glr-gallery-color-colormap-reference-py" target="_blank" rel="noopener">Colormap reference</a></p><hr><h4 id="自动保存图表"><a href="#自动保存图表" class="headerlink" title="自动保存图表"></a>自动保存图表</h4><p>要让程序<strong>自动将图表保存到文件中</strong>，可将对<code>plt.show()</code>的调用替换为对<code>plt.savefig()</code>的调用：</p><p><code>plt.savefig(&#39;suqares_plot.png&#39;, bbox_inches=&#39;tight&#39;)</code></p><ul><li>第一个实参指定要以什么样的文件名保存图表，这个文件将<strong>存储到当前程序所在的目录中</strong>。</li><li>第二个实参指定<strong>将图表多余的空白区域剪掉</strong>。如果要保留图表周围多余的空白区域，可<strong>省略这个实参</strong>。</li></ul><hr><h3 id="绘制饼图"><a href="#绘制饼图" class="headerlink" title="绘制饼图"></a>绘制饼图</h3><p><a href="https://zhuanlan.zhihu.com/p/38160291" target="_blank" rel="noopener">matplotlib可视化饼图 - 知乎</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制一个展示男女乘客比例的扇形图</span></span><br><span class="line">males = (titanic[<span class="string">'Sex'</span>] == <span class="string">'male'</span>).sum()</span><br><span class="line">females = (titanic[<span class="string">'Sex'</span>] == <span class="string">'female'</span>).sum()</span><br><span class="line"></span><br><span class="line">proportions = [males, females]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制饼图</span></span><br><span class="line">plt.pie(</span><br><span class="line">    proportions,</span><br><span class="line">    </span><br><span class="line">    labels = [<span class="string">'Males'</span>, <span class="string">'Females'</span>],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#是否 添加阴影效果</span></span><br><span class="line">    shadow = <span class="literal">False</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定填充色</span></span><br><span class="line">    colors = [<span class="string">'blue'</span>, <span class="string">'red'</span>],</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每一块偏移中心的距离</span></span><br><span class="line">    explode = (<span class="number">0.15</span> , <span class="number">0.3</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 饼图的初始摆放角度，默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起</span></span><br><span class="line">    startangle = <span class="number">90</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示百分比, 小数点前后表示最少的位数 末尾两个%%是输出%自身</span></span><br><span class="line">    autopct = <span class="string">'%1.1f%%'</span></span><br><span class="line">    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># x，y轴刻度设置一致，保证饼图为圆形</span></span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题</span></span><br><span class="line">plt.title(<span class="string">"男女乘客比例"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tight_layout会自动调整子图参数，使之填充整个图像区域</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h3 id="随机漫步"><a href="#随机漫步" class="headerlink" title="随机漫步"></a>随机漫步</h3><p><strong>随机漫步</strong>是这样行走得到的<strong>路径</strong>：<strong>每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的</strong>。在自然界、物理学、生物学、化学和经济领域，随机漫步都有其实际用途。例如，漂浮在水滴上的花粉因不断受到水分子的挤压而在水面上移动。水滴中的分子运动是随机的，因此花粉在水面上的运动路径犹如随机漫步。</p><h4 id="创建-RandomWalk-类"><a href="#创建-RandomWalk-类" class="headerlink" title="创建 RandomWalk() 类"></a>创建 RandomWalk() 类</h4><p>创建一个<code>RandomWalk()</code>类，这个类需要三个属性：</p><ol><li>存储随机漫步次数的变量</li><li>随机漫步经过的每个点的x坐标</li><li>随机漫步经过的每个点的y坐标</li></ol><p><code>RandomWalk()</code>类只包含两个方法：</p><ol><li><code>__init__()</code></li><li><code>fill_walk()</code>：计算随机漫步<strong>经过的所有点</strong></li></ol><p>先来看看<code>__init__()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWalk</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一个生成随机漫步数据的类"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_points=<span class="number">5000</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化随机漫步的属性"""</span></span><br><span class="line">        self.num_points = num_points</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 所有随机漫步都始于(0, 0)</span></span><br><span class="line">        self.x_values = [<span class="number">0</span>]</span><br><span class="line">        self.y_values = [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>为做出随机决策，我们<strong>将所有可能的选择都存储在一个列表中</strong>，并<strong>在每次做决策时都使用<code>choice()</code>来决定使用哪种选择</strong>。</p><hr><h4 id="选择方向"><a href="#选择方向" class="headerlink" title="选择方向"></a>选择方向</h4><p>我们将使用<code>fill_walk()</code>来生成漫步包含的点，并决定每次漫步的方向，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""计算随机漫步包含的所有点"""</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 不断漫步，直到列表到达指定的长度</span></span><br><span class="line">        <span class="keyword">while</span> len(self.x_values) &lt; self.num_points:</span><br><span class="line">            <span class="comment"># 决定前进方向以及沿这个方向前进的距离</span></span><br><span class="line">            x_direction = choice([<span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line">            x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            x_step = x_direction * x_distance</span><br><span class="line">            </span><br><span class="line">            y_direction = choice([<span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line">            y_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            y_step = y_direction * y_distance</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 拒绝原地踏步</span></span><br><span class="line">            <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 计算下一个点的x和y值</span></span><br><span class="line">            next_x = self.x_values[<span class="number">-1</span>] + x_step</span><br><span class="line">            next_y = self.y_values[<span class="number">-1</span>] + y_step</span><br><span class="line">            </span><br><span class="line">            self.x_values.append(next_x)</span><br><span class="line">            self.y_values.append(next_y)</span><br></pre></td></tr></table></figure><ul><li><code>choice([-1, 1])</code>：<strong>从-1和1中随机选择一个值</strong></li><li><code>choice([0, 1, 2, 3, 4])</code>：<strong>从0~4中随机选择一个值</strong></li></ul><hr><h4 id="绘制随机漫步图"><a href="#绘制随机漫步图" class="headerlink" title="绘制随机漫步图"></a>绘制随机漫步图</h4><p><strong>rw_visual.py</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">rw = RandomWalk()</span><br><span class="line">rw.fill_walk()</span><br><span class="line">plt.scatter(rw.x_values, rw.y_values, s=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h4 id="模拟多次随机漫步"><a href="#模拟多次随机漫步" class="headerlink" title="模拟多次随机漫步"></a>模拟多次随机漫步</h4><p>要在不多次运行程序的情况下<strong>模拟多次随机漫步</strong>，一种办法是<strong>将这些代码放在一个while循环中</strong>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">rw = RandomWalk()</span><br><span class="line">rw.fill_walk()</span><br><span class="line">plt.scatter(rw.x_values, rw.y_values, s=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">keep_running = input(<span class="string">"Make another walk? (y/n): "</span>)</span><br><span class="line"><span class="keyword">if</span> keep_running == <span class="string">'n'</span>:</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr><h4 id="给点着色"><a href="#给点着色" class="headerlink" title="给点着色"></a>给点着色</h4><p>我们将使用<strong>颜色映射</strong>来指出漫步中各点的<strong>先后顺序</strong>。为根据漫步中各点的先后顺序进行着色，我们<strong>传递参数c</strong>，并将其<strong>设置为一个列表</strong>，其中<strong>包含各点的先后顺序</strong>。</p><p><strong>由于这些点是按顺序绘制的，因此给参数c指定的列表只需包含数字1~5000</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">rw = RandomWalk()</span><br><span class="line">rw.fill_walk()</span><br><span class="line">    </span><br><span class="line">point_numbers = list(range(rw.num_points))</span><br><span class="line">plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues, s=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">keep_running = input(<span class="string">"Make another walk? (y/n): "</span>)</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><hr><h4 id="重新绘制起点和终点"><a href="#重新绘制起点和终点" class="headerlink" title="重新绘制起点和终点"></a>重新绘制起点和终点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    --snip--</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues, s=<span class="number">15</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">'green'</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">'red'</span>, s=<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">    plt.show()</span><br><span class="line">    --snip--</span><br></pre></td></tr></table></figure><hr><h4 id="隐藏坐标轴"><a href="#隐藏坐标轴" class="headerlink" title="隐藏坐标轴"></a>隐藏坐标轴</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    --snip--</span><br><span class="line">    plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">'red'</span>, s=<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 隐藏坐标轴</span></span><br><span class="line">    plt.axes().get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    plt.axes().get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    plt.show()</span><br><span class="line">    --snip--</span><br></pre></td></tr></table></figure><p>为修改坐标轴，使用了函数<code>plt.axes()</code>来将每条坐标轴的可见性设置为False。</p><hr><h4 id="增加点数"><a href="#增加点数" class="headerlink" title="增加点数"></a>增加点数</h4><p>在创建RandomWalk实例时<strong>增大num_points的值，并在绘图时调整每个点的大小</strong>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw = RandomWalk(<span class="number">5000</span>)</span><br><span class="line">    rw.fill_walk()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 绘制点并将图形显示出来</span></span><br><span class="line">    point_numbers = list(range(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues, s=<span class="number">1</span>)</span><br><span class="line">    --snip--</span><br></pre></td></tr></table></figure><hr><h4 id="调整尺寸以适合屏幕"><a href="#调整尺寸以适合屏幕" class="headerlink" title="调整尺寸以适合屏幕"></a>调整尺寸以适合屏幕</h4><p>图表适合屏幕大小时，更能有效地将数据中的规律呈现出来。为<strong>让绘图窗口更适合屏幕大小</strong>，可像下面这样<strong>调整matplotlib输出的尺寸</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">rw = RandomWalk()</span><br><span class="line">rw.fill_walk()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置绘图窗口的尺寸</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">    --snip--</span><br></pre></td></tr></table></figure><p>函数<code>figure()</code>用于<strong>指定图表的宽度、高度、分辨率和背景色</strong>：</p><p>需要给形参<code>figsize</code><strong>指定一个元组</strong>，向matplotlib<strong>指出绘图窗口的尺寸</strong>，<strong>单位为英寸</strong>。</p><p>Python<strong>假定屏幕分辨率为80像素/英寸</strong>，如果知道自己系统的分辨率，可使用形参dpi向<code>figure()</code>传递该分辨率，以有效利用可用的屏幕空间：</p><p><code>plt.figure(dpi=128, figsize=(10, 6))</code></p><hr><h3 id="使用-Pygal-模拟掷骰子"><a href="#使用-Pygal-模拟掷骰子" class="headerlink" title="使用 Pygal 模拟掷骰子"></a>使用 Pygal 模拟掷骰子</h3><p>本节将使用Python<strong>可视化包Pygal</strong>来生成可缩放的<strong>矢量图形文件</strong>，它们将<strong>自动缩放</strong>，以适合观看者的屏幕。如果你打算以在线的方式使用图表，请考虑使用Pygal来生成它们，这样在任何设备上显示都会很美观。</p><p>在这个项目中，我们将对掷骰子的结果进行分析。为确定哪些点数出现的可能性最大，我们将<strong>生成一个表示掷骰子结果的数据集，并根据结果绘制出一个图形</strong>。</p><h4 id="安装-Pygal"><a href="#安装-Pygal" class="headerlink" title="安装 Pygal"></a>安装 Pygal</h4><p>在 Windows 系统中，命令：</p><p><code>python -m pip install --user pygal==1.7</code></p><hr><h4 id="Paygal-画廊"><a href="#Paygal-画廊" class="headerlink" title="Paygal 画廊"></a>Paygal 画廊</h4><p>要了解使用Pygal可创建什么样的图表，可以查看<a href="http://www.pygal.org/en/stable/documentation/types/index.html" target="_blank" rel="noopener">Chart types — pygal documentation</a></p><hr><h4 id="创建-Die-类"><a href="#创建-Die-类" class="headerlink" title="创建 Die 类"></a>创建 Die 类</h4><p>下面的类模拟掷一个骰子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Die</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""表示一个骰子的类"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_sides=<span class="number">6</span>)</span>:</span></span><br><span class="line">        <span class="string">"""骰子默认为6面"""</span></span><br><span class="line">        self.num_sides = num_sides</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个位于1和骰子面数之间的随机数"""</span></span><br><span class="line">        <span class="keyword">return</span> randint(<span class="number">1</span>, self.num_sides)</span><br></pre></td></tr></table></figure><ul><li>方法<code>roll()</code>使用函数<code>randint()</code>来<strong>返回一个1和面数之间的随机整数(包括起始值1和终止值num_sides)</strong></li></ul><p>骰子根据面数命名，6面的骰子命名为D6，8面的骰子命名为D8。</p><hr><h4 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h4><p>使用这个类来创建图表前，先来掷D6骰子，将结果打印出来，并检查结果是否合理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个D6</span></span><br><span class="line">die = Die()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 掷几次骰子，并将结果存储在一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    result = die.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line">    </span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure><hr><h4 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h4><p>为分析掷一个D6骰子的结果，我们<strong>计算每个点数出现的次数</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment"># 掷几次骰子，并将结果存储在一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    result = die.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, die.num_sides+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line">    </span><br><span class="line">print(frequencies)</span><br></pre></td></tr></table></figure><ul><li>为分析结果，我们创建了空列表frequencies，用于存储每种点数出现的次数</li></ul><hr><h4 id="绘制条形图-bar-chart"><a href="#绘制条形图-bar-chart" class="headerlink" title="绘制条形图(bar chart)"></a>绘制条形图(bar chart)</h4><p>有了频率列表后，我们就可以绘制一个表示结果的<strong>条形图(bar chart)</strong>，<strong>指出各种结果出现的频率</strong>。</p><ol><li><strong>利用pygal绘制</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, die.num_sides+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 对结果进行可视化</span></span><br><span class="line">bar = pygal.Bar()</span><br><span class="line"></span><br><span class="line">bar.title = <span class="string">"Results of rolling one D6 1000 times."</span></span><br><span class="line">bar.x_labels = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>]</span><br><span class="line">bar.x_title = <span class="string">"Result"</span></span><br><span class="line">bar.y_title = <span class="string">"Frequency of Result"</span></span><br><span class="line"></span><br><span class="line">bar.add(<span class="string">'D6'</span>, frequencies)</span><br><span class="line">bar.render_to_file(<span class="string">'die_visual.svg'</span>)</span><br></pre></td></tr></table></figure><ul><li>为创建<strong>条形图(bar diagram)</strong>，创建了一个<code>pygal.Bar()</code>实例</li><li>将D6骰子的可能结果用作x轴的标签</li><li>使用<code>add()</code>将一系列值添加到图表中(传递<strong>给添加的值指定的标签</strong>、<strong>将出现在图表中的值的列表</strong>)</li><li>将图表<strong>渲染为一个SVG文件</strong>(Scalable Vector Graphics，可缩放的矢量图形，是一种<strong>基于XML</strong>的<strong>图像文件格式</strong>)</li></ul><p>要查看生成的直方图，最简单的方式是使用Web浏览器。为此，在任意浏览器中新建一个标签页，再打开文件die_visual.svg，将看到对应的图表。</p><p>注意：Python让这个图表具有交互性：<strong>如果将鼠标指向该图表中的任何条形，将看到与之相关联的数据</strong>(若无效果，刷新)。</p><hr><h4 id="绘制直方图-histogram"><a href="#绘制直方图-histogram" class="headerlink" title="绘制直方图(histogram)"></a>绘制直方图(histogram)</h4><ol><li><strong>利用pyplot绘制</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 绘制一个展示船票价格的直方图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建直方图</span></span><br><span class="line"><span class="comment"># 参数：需要计算的series ，bins可以是直方图个数(默认为10)，也可以是自定义的序列</span></span><br><span class="line">plt.hist(titanic[<span class="string">'Fare'</span>], bins = range(<span class="number">0</span>,<span class="number">600</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the title and labels</span></span><br><span class="line">plt.xlabel(<span class="string">'Fare'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Frequency'</span>)</span><br><span class="line">plt.title(<span class="string">'船票价格分布'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show the plot</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户消费金额的分布图，利用query消除极值对可视化呈现效果的干扰</span></span><br><span class="line">plt.hist(grouped_user.sum().query(<span class="string">'order_amount &lt; 1000'</span>)[<span class="string">'order_amount'</span>], bins = <span class="number">20</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h4 id="同时掷两个骰子"><a href="#同时掷两个骰子" class="headerlink" title="同时掷两个骰子"></a>同时掷两个骰子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个D6骰子</span></span><br><span class="line">die_1 = Die()</span><br><span class="line">die_2 = Die()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 掷骰子多次，并将结果存储到一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    result = die_1.roll() + die_2.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line">max_result = die_1.num_sides + die_2.num_sides</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">2</span>, max_result+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">bar = pygal.Bar()</span><br><span class="line"></span><br><span class="line">bar.title = <span class="string">"Results of rolling two D6 dice 1000 times."</span></span><br><span class="line">bar.x_labels = [<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>, <span class="string">'11'</span>, <span class="string">'12'</span>]</span><br><span class="line">bar.x_title = <span class="string">"Result"</span></span><br><span class="line">bar.y_title = <span class="string">"Frequency of Result"</span></span><br><span class="line"></span><br><span class="line">bar.add(<span class="string">'D6 + D6'</span>, frequencies)</span><br><span class="line">bar.render_to_file(<span class="string">'dice_visual.svg'</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="同时掷两个面数不同的骰子"><a href="#同时掷两个面数不同的骰子" class="headerlink" title="同时掷两个面数不同的骰子"></a>同时掷两个面数不同的骰子</h4><p>下面来创建一个6面骰子和一个10面骰子，看看同时掷这两个骰子50000次的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个D6和一个D10</span></span><br><span class="line">die_1 = Die()</span><br><span class="line">die_2 = Die(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 掷骰子多次，并将结果存储到一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">50000</span>):</span><br><span class="line">    result = die_1.roll() + die_2.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line">max_result = die_1.num_sides + die_2.num_sides</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">2</span>, max_result+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">bar = pygal.Bar()</span><br><span class="line"></span><br><span class="line">bar.title = <span class="string">"Results of rolling a D6 and a D10 50,000 times."</span></span><br><span class="line">bar.x_labels = [str(value) <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">17</span>)]</span><br><span class="line">bar.x_title = <span class="string">"Result"</span></span><br><span class="line">bar.y_title = <span class="string">"Frequency of Result"</span></span><br><span class="line"></span><br><span class="line">bar.add(<span class="string">'D6 + D10'</span>, frequencies)</span><br><span class="line">bar.render_to_file(<span class="string">'dice_visual.svg'</span>)</span><br></pre></td></tr></table></figure><ul><li>通过<strong>列表解析</strong>调整x轴标签</li></ul><hr><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><p>网上的数据多得难以置信，且大多未经过仔细检查。如果能够对这些数据进行分析，你就能发现别人没有发现的规律和关联。</p><h3 id="CSV-文件格式"><a href="#CSV-文件格式" class="headerlink" title="CSV 文件格式"></a>CSV 文件格式</h3><p>要在<strong>文本文件</strong>中存储数据，最简单的方式是<strong>将数据作为一系列以逗号分隔的值</strong>(<strong>CSV</strong>, Comma-Separated Values)写入文件，这样的文件称为<strong>CSV文件</strong>。</p><p>例如，下面是一行CSV格式的天气数据：</p><p><code>2014-1-5,61,44,26,18,7,-1,56,30,9,30.34,30.27,30.15,,,,10,4,,0.00,0,,195</code></p><p>CSV文件对人来说阅读起来比较麻烦，但程序可轻松地提取并处理其中的值，这有助于加快数据分析过程。</p><ul><li>最好<strong>使用用文字编辑器打开csv文件查看</strong>，<strong>Excel可能会更改显示格式</strong></li></ul><h4 id="分析-CSV-文件头"><a href="#分析-CSV-文件头" class="headerlink" title="分析 CSV 文件头"></a>分析 CSV 文件头</h4><p>csv模块包含在Python标准库中，可用于分析CSV文件中的数据行，让我们能够快速提取感兴趣的值。下面先来看一下<code>sitka_weather_07-2014.csv</code>文件的<strong>第一行</strong>，其中<strong>包含一系列有关数据的描述</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    print(header_row)</span><br></pre></td></tr></table></figure><ul><li>调用<code>csv.reader()</code>，并将前面存储的<strong>文件对象作为实参传入</strong>，从而创建一个与该文件相关联的<strong>阅读器对象</strong></li><li><strong>模块csv的reader类</strong>包含<code>next()</code>方法，调用<strong>内置函数<code>next()</code></strong>并<strong>将一个阅读器对象作为参数传入，将调用阅读器对象的<code>next()</code>方法，从而返回文件中的下一行</strong>。</li><li>reader处理文件中<strong>以逗号分隔的第一行数据</strong>，并<strong>将每项数据都作为一个元素存储在列表中</strong>。</li></ul><p>注意：文件头的格式并非总是一致的， <strong>空格和单位可能出现在奇怪的地方，但不会带来任何问题</strong>。</p><hr><h4 id="打印文件头及其位置"><a href="#打印文件头及其位置" class="headerlink" title="打印文件头及其位置"></a>打印文件头及其位置</h4><p>为让文件头数据更容易理解，将列表中的<strong>每个文件头及其位置</strong>打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index, column_header <span class="keyword">in</span> enumerate(header_row):</span><br><span class="line">        print(index, column_header)</span><br></pre></td></tr></table></figure><ul><li>对列表调用了<code>enumerate()</code>(<strong>枚举</strong>)来获取每个元素的<strong>索引及其值</strong>。</li></ul><hr><h4 id="提取并读取数据"><a href="#提取并读取数据" class="headerlink" title="提取并读取数据"></a>提取并读取数据</h4><p>首先读取<strong>每天的最高气温</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中获取最高气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    </span><br><span class="line">    highs = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        highs.append(row[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    print(highs)</span><br></pre></td></tr></table></figure><ul><li><p><code>for row in reader</code>：<strong>遍历</strong>文件中余下的<strong>各行</strong></p><p>  每次执行上述循环，我们都将<strong>索引1处</strong>(<strong>第2列</strong>)的数据附加到highs末尾。</p></li></ul><p>下面使用<code>int()</code><strong>将这些字符串转换为数字</strong>，<strong>让matplotlib能够读取它们</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line">highs = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        high = int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">        </span><br><span class="line">    print(highs)</span><br></pre></td></tr></table></figure><hr><h4 id="绘制气温图表"><a href="#绘制气温图表" class="headerlink" title="绘制气温图表"></a>绘制气温图表</h4><p>为可视化这些气温数据，我们首先使用matplotlib创建一个<strong>显示每日最高气温的简单图形</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中获取最高气温</span></span><br><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(highs, c=<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high temperatures, July 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><p><strong>鉴于还没有添加日期，因此没有给x轴添加标签</strong></p></li><li><p><code>tick_params()</code>：</p><p>  which一共3个参数：[‘major’ , ‘minor’. ‘both’]<br>  默认是major，表示<strong>主刻度</strong>，后面分布为<strong>次刻度</strong>及<strong>主次刻度都显示.</strong></p></li><li><p><strong>调整x轴日期的显示间隔</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(pd.date_range(<span class="string">'1997-01-01'</span>, <span class="string">'1997-04-01'</span>, freq=<span class="string">'10d'</span>))</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="模块-datetime"><a href="#模块-datetime" class="headerlink" title="模块 datetime"></a>模块 datetime</h4><p>下面<strong>在图表中添加日期</strong>。在天气数据文件中，<strong>第一个日期在第二行</strong>：</p><p><strong>获取日期数据时，获得的是一个字符串</strong>，因此需要将字符串<code>&#39;2014-7-1&#39;</code><strong>转换为一个表示相应日期的对象</strong>。可使用<strong>模块datetime</strong>中的方法<code>strptime()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; first_date = datetime.strptime(&apos;2014-7-1&apos;, &apos;%Y-%m-%d&apos;)</span><br><span class="line">&gt;&gt;&gt; print(first_date)</span><br><span class="line">2014-07-01 00:00:00</span><br></pre></td></tr></table></figure><ul><li><p>传入方法<code>strptime()</code>的<strong>第2个实参</strong>告诉Python如何<strong>设置日期的格式</strong>。</p><ul><li><code>%Y-</code>让Python将字符串中<strong>第一个连字符前面的部分</strong>视为<strong>4位的年份</strong></li><li><code>%m-</code>让Python将<strong>第二个连字符前面的部分</strong>视为<strong>表示月份的数字</strong></li><li><code>%d</code>让Python将<strong>最后一部分</strong>视为<strong>月份中的一天</strong></li></ul></li><li><p>方法<code>strptime()</code>可接受各种实参，并根据它们来决定如何解读日期：</p><p>  | 实参   | 含义                                       |<br>  | —— | —————————————— |<br>  | %<strong>A</strong> | <strong>星期</strong>的名称，如Monday                   |<br>  | %<strong>B</strong> | <strong>月份</strong>名，如January                      |<br>  | %m     | 用<strong>数字表示的月份</strong> (<strong>0</strong>1~12)           |<br>  | %d     | 用<strong>数字表示</strong>月份中的<strong>一天</strong> (<strong>0</strong>1~31) |<br>  | %<strong>Y</strong> | <strong>四位</strong>的年份，如2015                     |<br>  | %<strong>y</strong> | <strong>两位</strong>的年份，如15                       |<br>  | %<strong>H</strong> | <strong>24小时制</strong>的小时数 (<strong>0</strong>0-23)           |<br>  | %<strong>I</strong> | <strong>12小时制</strong>的小时数 (<strong>0</strong>1~12)           |<br>  | %<strong>p</strong> | am或pm                                     |<br>  | %<strong>M</strong> | 分钟数 (<strong>0</strong>0~59)                         |<br>  | %<strong>S</strong> | 秒数 (<strong>0</strong>0~<strong>61</strong>)                       |</p></li></ul><hr><h4 id="在图表中添加日期"><a href="#在图表中添加日期" class="headerlink" title="在图表中添加日期"></a>在图表中添加日期</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中获取日期和最高气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">        </span><br><span class="line">    dates, highs = [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        </span><br><span class="line">        high = int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high temperatures, July 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.gcf().autofmt_xdate() <span class="comment"># 绘制斜的日期标签，以免它们彼此重叠</span></span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li>创建了两个空列表：<code>dates, highs = [], []</code></li><li>将包含日期信息的数据转换为datetime对象：<code>datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)</code></li><li>将日期和最高气温值传给<code>plot()</code>：<code>plt.plot(dates, highs, c=&#39;red&#39;)</code></li></ul><hr><h4 id="涵盖更长的时间"><a href="#涵盖更长的时间" class="headerlink" title="涵盖更长的时间"></a>涵盖更长的时间</h4><p>创建<strong>覆盖整年</strong>的天气图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment"># 从文件中获取日期和最高气温</span></span><br><span class="line">filename = <span class="string">'stika_weather_2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">--snip--</span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high temperatures - 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><hr><h4 id="再绘制一个数据系列"><a href="#再绘制一个数据系列" class="headerlink" title="再绘制一个数据系列"></a>再绘制一个数据系列</h4><p>从数据文件中提取最低气温，并添加到图表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    </span><br><span class="line">    dates, highs, lows = [], [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        </span><br><span class="line">        high = int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">        </span><br><span class="line">        low = int(rpw[<span class="number">3</span>])</span><br><span class="line">        lows.append(low)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">'blue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high and low temperatures - 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><hr><h4 id="给图表区域着色"><a href="#给图表区域着色" class="headerlink" title="给图表区域着色"></a>给图表区域着色</h4><p><strong>通过着色来呈现每天的气温范围</strong>，为此使用方法<code>fill_between()</code>，它<strong>接受一个x值系列和两个y值系列，并填充两个y值系列之间的空间</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>. alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">'blue'</span>. alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=<span class="string">'blue'</span>, alpha=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><ul><li>实参<code>alpha</code>指定<strong>颜色的透明度</strong><ul><li><strong>0</strong>表示完全<strong>透明</strong></li><li><strong>1(默认)</strong>表示完全<strong>不透明</strong></li></ul></li><li><code>fill_between()</code><ul><li>实参<code>facecolor</code>指定了<strong>填充区域的颜色</strong></li></ul></li></ul><hr><h4 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h4><p>我们应该能够使用有关任何地方的天气数据来运行highs_lows.py中的代码，但<strong>有些气象站会偶尔出现故障，未能收集部分或全部其应该收集的数据</strong>。<strong>缺失数据可能会引发异常，如果不妥善地处理，还可能导致程序崩溃</strong>。</p><p>例如，我们来看看生成加利福尼亚死亡谷的气温图时出现的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line">filename = <span class="string">'death_valley_2014.csv'</span></span><br><span class="line">withj open(filename) <span class="keyword">as</span> f:</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;highs_lows.py&quot;, line 17, in &lt;module&gt;</span><br><span class="line">    high = int(row[1])</span><br><span class="line">ValueError: invalid literal for int() with base 10: &apos;&apos;</span><br></pre></td></tr></table></figure><p>查看文件可知，没有记录<strong>2014年2月16日</strong>的数据，<strong>表示最高温度的字符串为空</strong>。为解决这种问题，我们<strong>从CSV文件中读取值时执行错误检查代码，对分析数据集时可能出现的异常进行处理</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line">filename = <span class="string">'death_valley_2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">        </span><br><span class="line">    dates, highs, lows = [], [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        high = int(row[<span class="number">1</span>])</span><br><span class="line">            low = int(row[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(current_date, <span class="string">'missing data'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dates.append(current_date)</span><br><span class="line">        highs.append(high)</span><br><span class="line">            lows.append(low)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">title = <span class="string">"Daily high and low temperatures - 2014\nDeath Valley, CA"</span></span><br><span class="line">plt.title(title, fontsize=<span class="number">20</span>)</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><p>在有些情况下，需要<strong>使用continue来跳过一些数据</strong>，或者<strong>使用<code>remove()</code>(删除列表值)或<code>del</code>(删除 键-值 对)将已提取的数据删除</strong>。可采用任何管用的方法，只要能进行精确而有意义的可视化就好。</p><hr><h3 id="16-2-比较锡特卡和死亡谷的气温："><a href="#16-2-比较锡特卡和死亡谷的气温：" class="headerlink" title="16-2  比较锡特卡和死亡谷的气温："></a>16-2  比较锡特卡和死亡谷的气温：</h3><p>为准确地比较锡特卡和死亡谷的气温范围，<strong>在y轴上使用相同的刻度</strong>，对两地的气温范围进行直接比较：</p><ul><li>pyplot的方法<code>ylim()</code>可以<strong>对y轴的刻度做限制</strong>；<code>xlim()</code>则可以对x轴的刻度做限制。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">--snip--</span><br><span class="line">plt.ylim(<span class="number">10</span>, <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>尝试<strong>在一个图表中呈现这两个数据集</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weather_data</span><span class="params">(filename, dates, highs, lows)</span>:</span></span><br><span class="line">    <span class="string">"""从文件中获取日期、最高气温和最低气温"""</span></span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        reader = csv.reader(f)</span><br><span class="line">        header_row = next(reader)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">                high = int(row[<span class="number">1</span>])</span><br><span class="line">                low = int(row[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                print(current_date, <span class="string">'missing data'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dates.append(current_date)</span><br><span class="line">                highs.append(high)</span><br><span class="line">                lows.append(low)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取锡特卡的气温数据</span></span><br><span class="line">dates, highs, lows = [], [], []</span><br><span class="line">get_weather_data(<span class="string">'stika_weather_2014.csv'</span>, dates, highs, lows)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据锡特卡数据绘制图形</span></span><br><span class="line">plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">'blue'</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=<span class="string">'blue'</span>, alpha=<span class="number">0.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取死亡谷的气温数据</span></span><br><span class="line">dates, highs, lows = [], [], []</span><br><span class="line">get_weather_data(<span class="string">'death_valley_2014.csv'</span>, dates, highs, lows)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将死亡谷数据的图形 添加到当前的绘制中</span></span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">'blue'</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=<span class="string">'blue'</span>, alpha=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">title = <span class="string">"Daily high and low temperatures - 2014"</span></span><br><span class="line">title += <span class="string">"\nSitka, AK and Death Valley, CA"</span></span><br><span class="line">plt.title(title, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.gcf().autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span>, <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h3 id="制作交易收盘价走势图：-JSON-格式"><a href="#制作交易收盘价走势图：-JSON-格式" class="headerlink" title="制作交易收盘价走势图： JSON 格式"></a>制作交易收盘价走势图： JSON 格式</h3><h4 id="下载收盘价数据"><a href="#下载收盘价数据" class="headerlink" title="下载收盘价数据"></a>下载收盘价数据</h4><p>btc_close_2017.json实际是一个很长的<strong>Python列表</strong>，其中<strong>每个元素都是一个包含五个键的字典</strong>：统计日期、月份、周数、周几以及收盘价。由于2017年1月1日是周日，作为2017年的第一周实在太短，。因此被计入2016年的第52周。于是2017年的第一周是从1月2日开始的。</p><p>可以将<a href="https://raw.githubusercontent.com/muxuezi/btc/master/btc_close_2017.json" target="_blank" rel="noopener">收盘价数据文件</a>直接下载到程序所在的文件夹中，也可以用Python <strong>2.x</strong>标准库中模块<strong>urllib2</strong>(Python <strong>3.x</strong>版本使用<strong>urllib</strong>)的函数<code>urlopen()</code>来做，还可以通过Python的<strong>第三方模块requests</strong>下载数据。</p><p>如果采用函数<code>urlopen()</code>来下载数据，可以使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> (absolute_import, division, print_function, unicode_literals)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Python 2.x 版本</span></span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="comment"># Python 3.x 版本</span></span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">json_url = <span class="string">'https://raw.githubusercontent.com/muxuezi/btc/master/btc_close_2017.json'</span></span><br><span class="line">response = urlopen(json_url)</span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">req = response.read()</span><br><span class="line"><span class="comment"># 将数据写入文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'btc_close_2017_urllib.json'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(req)</span><br><span class="line"><span class="comment"># 加载json格式</span></span><br><span class="line">file_urllib = json.loads(req)</span><br><span class="line">print(file_urllib)</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://blog.csdn.net/yizhuanlu9607/article/details/78084266" target="_blank" rel="noopener">python打开文件时w与wb的区别,r与rb的区别</a></p><p>  在<strong>Windows</strong>中的<strong>换行符</strong>是<code>\r\n</code>。</p><ul><li>以<strong>文本方式</strong>(<code>&#39;w&#39;</code>)<strong>写入</strong>，遇到<code>\n</code>会<strong>自动替换</strong>为<code>\r\n</code></li><li>以<strong>二进制文本方式</strong>(<code>&#39;wb&#39;</code>)写入，遇到<code>\n</code><strong>仍然按</strong><code>\n</code>记录</li></ul></li><li><p><code>json</code></p><ul><li><p><code>load()</code></p><p>  载入<strong>json文件</strong></p></li><li><p><code>loads()</code></p><p>  载入JSON格式的<strong>字符串</strong></p></li></ul></li></ul><p>函数urlopen的代码稍微复杂一些，<strong>第三方模块requests</strong>封装了许多常用的方法，<strong>让数据下载和读取方式变得非常简单</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">json_url = <span class="string">'https://raw.githubusercontent.com/muxuezi/btc/master/btc_close_2017.json'</span></span><br><span class="line">req = requests.get(json_url)</span><br><span class="line"><span class="comment"># 将数据写入文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'btc_close_2017_request.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(req.text)</span><br><span class="line">file_requests = req.json()</span><br></pre></td></tr></table></figure><ul><li><code>req.text</code>属性可以<strong>直接读取文件数据</strong>，<strong>返回格式是字符串</strong></li><li><code>req.json()</code>可以将json文件的数据<strong>转换为Python列表</strong>，与之前的<code>file_urllib</code><strong>内容相同</strong></li></ul><hr><h4 id="提取相关的数据"><a href="#提取相关的数据" class="headerlink" title="提取相关的数据"></a>提取相关的数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据加载到一个列表中</span></span><br><span class="line">filename = <span class="string">'btc_close_2017.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    btc_data = json.load(f)</span><br><span class="line"><span class="comment"># 打印每一天的信息</span></span><br><span class="line"><span class="keyword">for</span> btc_dict <span class="keyword">in</span> btc_data:</span><br><span class="line">    date = btc_dict[<span class="string">'date'</span>]</span><br><span class="line">    month = btc_dict[<span class="string">'month'</span>]</span><br><span class="line">    week = btc_dict[<span class="string">'week'</span>]</span><br><span class="line">    weekday = btc_dict[<span class="string">'weekday'</span>]</span><br><span class="line">    close = btc_dict[<span class="string">'close'</span>]</span><br><span class="line">    print(<span class="string">"&#123;&#125; is month &#123;&#125; week &#123;&#125;, &#123;&#125;, the close price is &#123;&#125; RMB"</span>.format(date, month, week, weekday, close))</span><br></pre></td></tr></table></figure><hr><h4 id="将字符串转换为数字值"><a href="#将字符串转换为数字值" class="headerlink" title="将字符串转换为数字值"></a>将字符串转换为数字值</h4><p>btc_close_2017.json中的每个键和值都是字符串。为了能在后边的内容中<strong>对交易数据进行计算</strong>，需要先将<strong>表示周数和收盘价的字符串转换为数值</strong>，因此使用函数<code>int()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每一天的信息</span></span><br><span class="line"><span class="keyword">for</span> btc_dict <span class="keyword">in</span> btc_data:</span><br><span class="line">    date = btc_dict[<span class="string">'date'</span>]</span><br><span class="line">    month = int(btc_dict[<span class="string">'month'</span>])</span><br><span class="line">    week = int(btc_dict[<span class="string">'week'</span>])</span><br><span class="line">    weekday = btc_dict[<span class="string">'weekday'</span>]</span><br><span class="line">    close = int(float(btc_dict[<span class="string">'close'</span>]))</span><br><span class="line">    print(<span class="string">"&#123;&#125; is month &#123;&#125; week &#123;&#125;, &#123;&#125;, the close price is &#123;&#125; RMB"</span>.format(date, month, week, weekday, close))</span><br></pre></td></tr></table></figure><ul><li><strong>在实际工作中，原始数据的格式经常是不统一的</strong>。此类数值类型转换造成的<strong>ValueError异常十分普遍</strong>。该例子中，<strong>无法将包含小数点的字符串转换为整数</strong>，因此需要<strong>先转换为浮点数再转换为整数</strong>：<code>int(float(btc_dict[&#39;close&#39;]))</code></li></ul><p>有了这些数据之后，可以<strong>结合Pygal的可视化功能来探索一些有趣的信息</strong>。</p><hr><h4 id="绘制收盘价折线图"><a href="#绘制收盘价折线图" class="headerlink" title="绘制收盘价折线图"></a>绘制收盘价折线图</h4><p>之前章节介绍过<strong>用Pygal绘制条形图(bar chart)</strong>的方法，也介绍了<strong>用matplotlib绘制折线图(line chart)</strong>的方法。下面用<strong>Pygal</strong>来实现收盘价的<strong>折线图</strong>。</p><p>绘制折线图之前，需要<strong>获取x轴与y轴数据</strong>，因此我们<strong>创建了几个列表来存储数据</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建5个列表，分别存储日期和收盘价</span></span><br><span class="line">dates = []</span><br><span class="line">months = []</span><br><span class="line">weeks = []</span><br><span class="line">weekdays = []</span><br><span class="line">close = []</span><br><span class="line"><span class="comment"># 每一天的信息</span></span><br><span class="line"><span class="keyword">for</span> btc_dict <span class="keyword">in</span> btc_data:</span><br><span class="line">    dates.append(btc_dict[<span class="string">'date'</span>])</span><br><span class="line">    months.append(int(btc_dict[<span class="string">'month'</span>]))</span><br><span class="line">    weeks.append(int(btc_dict[<span class="string">'week'</span>]))</span><br><span class="line">    weekdays.append(btc_dict[<span class="string">'weekday'</span>])</span><br><span class="line">    close.append(int(float(btc_dict[<span class="string">'close'</span>])))</span><br></pre></td></tr></table></figure><p>由于<strong>数据点比较多，x轴要显示346个日期，因此需要利用Pygal的配置参数，对图形进行适当的调整</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line">line_chart = pygal.Line(x_label_rotation=<span class="number">20</span>, show_mirror_x_labels=<span class="literal">False</span>)</span><br><span class="line">line_chart.title = <span class="string">'收盘价（￥）'</span></span><br><span class="line">line_chart.x_labels = dates</span><br><span class="line">N = <span class="number">20</span> <span class="comment"># x轴坐标每隔20天显示一次</span></span><br><span class="line">line_chart.x_labels_major = dates[::N]</span><br><span class="line">line_chart.add(<span class="string">'收盘价'</span>, close)</span><br><span class="line">line_chart.render_to_file(<span class="string">'收盘价折线图（￥）.svg'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>pygal.Line()</code>创建Line实例<ul><li><code>x_label_rotation=20</code>：让x轴上的标签<strong>顺时针旋转20°</strong></li><li><code>show_mirror_x_labels=False</code>：告诉图形<strong>不用显示所有的x轴标签</strong></li></ul></li><li><code>line_chart.x_labels_major = dates[:20]</code>：x轴坐标<strong>每隔20天显示一次</strong></li></ul><p>下面<strong>对价格做一些简单的探索</strong></p><hr><h4 id="时间序列特征初探"><a href="#时间序列特征初探" class="headerlink" title="时间序列特征初探"></a>时间序列特征初探</h4><p>进行<strong>时间序列分析</strong>总是期望发现<strong>趋势(trend)</strong>、<strong>周期性(seasonality)</strong>和<strong>噪声(noise)</strong>，从而能够<strong>描述事实、预测未来、做出决策</strong>。</p><p>从收盘价的折线图可以看出，2017年的<strong>总体趋势</strong>时非线性的，而且增长幅度不断增大，似乎呈<strong>指数分布</strong>。但是，在<strong>每个季度末</strong>(3月、6月、9月)似乎<strong>有一些相似的波动</strong>，<strong>为了验证周期性的假设，需要先将非线性的趋势(指数增长部分)消除</strong>。<strong>对数变换(log transformation)</strong>是常用的处理方法之一。</p><p>用<strong>Python标准库的数学模块math</strong>来解决这个问题。math里有许多常用的数学函数，这里<strong>以10为底的对数函数math.log10计算收盘价</strong>，日期仍然保持不变——这种方式称为<strong>半对数(semi-logarithmic)变换</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">line_chart = pygal.Line(x_label_rotation=<span class="number">20</span>, show_mirror_x_labels=<span class="literal">False</span>)</span><br><span class="line">line_chart.title = <span class="string">'收盘价对数变换（￥）'</span></span><br><span class="line">line_chart.x_labels = dates</span><br><span class="line">N = <span class="number">20</span> <span class="comment"># x轴坐标每隔20天显示一次</span></span><br><span class="line">line_chart.x_labels_major = dates[::N]</span><br><span class="line">close_log = [math.log10(_) <span class="keyword">for</span> _ <span class="keyword">in</span> close]</span><br><span class="line">line_chart.add(<span class="string">'log收盘价'</span>, close_log)</span><br><span class="line">line_chart.render_to_file(<span class="string">'收盘价对数变换折线图（￥）.svg'</span>)</span><br></pre></td></tr></table></figure><p><strong>剔除非线性趋势</strong>之后，<strong>整体的趋势更接近线性增长</strong>，且收盘价在每个季度末似乎有<strong>显著的周期性</strong>。那么，12月会不会再现这一场景？下面来看看收盘价的<strong>月日均值</strong>与<strong>周日均值</strong>的表现。</p><hr><h4 id="收盘价均值"><a href="#收盘价均值" class="headerlink" title="收盘价均值"></a>收盘价均值</h4><p>再利用btc_close_2017.json文件中的数据，绘制2017年<strong>前11个月</strong>的日均值、<strong>前49周(01-02~12-10)</strong>的日均值，以及<strong>每周各天</strong>的日均值。虽然这些日均值的数值不同，但都是一段时间的均值，计算方法都是一样的。因此，可以<strong>将绘图代码封装成函数</strong>，以便重复使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_line</span><span class="params">(x_data, y_data, title, y_legend)</span>:</span></span><br><span class="line">    xy_map = []</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> groupby(sorted(zip(x_data, y_data)), key=<span class="keyword">lambda</span> _: _[<span class="number">0</span>]):</span><br><span class="line">    y_list = [v <span class="keyword">for</span> _, v <span class="keyword">in</span> y]</span><br><span class="line">    xy_map.append([x, sum(y_list) / len(y_list)])</span><br><span class="line">x_unique, y_mean = [*zip(*xy_map)]</span><br><span class="line">line_chart = pygal.Line()</span><br><span class="line">line_chart.title = title</span><br><span class="line">line_chart.x_labels = x_unique</span><br><span class="line">line_chart.add(y_legend, y_mean)</span><br><span class="line">line_chart.render_to_file(title+<span class="string">'.svg'</span>)</span><br><span class="line"><span class="keyword">return</span> line_chart</span><br></pre></td></tr></table></figure><ul><li>由于<strong>需要将数据按月份、周数、周几分组，再计算每组的均值</strong>，因此导入<strong>Python标准库中模块itertools的函数groupby</strong>。</li><li>将x轴与y轴的<strong>数据合并</strong>、<strong>排序</strong>，再<strong>用函数groupby分组</strong></li><li>分组之后，求出每组的平均值，存储到xy_map中</li><li>最后，将xy_map中存储的x轴与y轴数据分离，就可以像之前一样用Pygal画图了</li></ul><p>下面画出收盘价<strong>月日均值</strong>，由于12月的数据不完整，只取1月到11月的数据。<strong>通过dates查找2017-12-01索引的位置，确定周数和收盘价的取值范围</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idx_month = dates.index(<span class="string">'2017-12-01'</span>)</span><br><span class="line">line_chart_month = draw_line(months[:idx_month], close[:idx_month], <span class="string">'收盘价月日均值（￥）'</span>,</span><br><span class="line">                            <span class="string">'月日均值'</span>)</span><br><span class="line">line_chart_month</span><br></pre></td></tr></table></figure><hr><h4 id="收盘价数据仪表盘"><a href="#收盘价数据仪表盘" class="headerlink" title="收盘价数据仪表盘"></a>收盘价数据仪表盘</h4><p>每个SVG文件打开之后都是独立的页面，如果能<strong>整合</strong>在一起，就可以方便地进行<strong>长期管理、监测和分析</strong>。另外，<strong>新的图表也可以方便地加入进来</strong>，这样就形成了一个<strong>数据仪表盘</strong>(<strong>dashboard</strong>)。下面，将之前绘制的图整合起来，做一个收盘价数据仪表盘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'收盘价Dashboard.html'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> html_file:</span><br><span class="line">    html_file.write(</span><br><span class="line">        <span class="string">'&lt;html&gt;&lt;head&gt;&lt;title&gt;收盘价Dashboard&lt;/title&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> svg <span class="keyword">in</span> [</span><br><span class="line">        <span class="string">'收盘价折线图（¥）.svg'</span>, <span class="string">'收盘价对数变换折线图（¥）.svg'</span>, <span class="string">'收盘价月日均值（¥）.svg'</span>,</span><br><span class="line">        <span class="string">'收盘价周日均值（¥）.svg'</span>, <span class="string">'收盘价星期均值（¥）.svg'</span></span><br><span class="line">    ]:</span><br><span class="line">        html_file.write(</span><br><span class="line">            <span class="string">'    &lt;object type="image/svg+xml" data="&#123;0&#125;" height=500&gt;&lt;/object&gt;\n'</span>.format(svg))</span><br><span class="line">    html_file.write(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure><p>和常见网络应用的数据仪表盘一样，这个数据仪表盘也是一个完整的网页。</p><hr><h2 id="使用-API"><a href="#使用-API" class="headerlink" title="使用 API"></a>使用 API</h2><h3 id="使用-Web-API"><a href="#使用-Web-API" class="headerlink" title="使用 Web API"></a>使用 Web API</h3><p>Web API是网站的一部分，用于 与使用非常具体的URL<strong>请求特定信息</strong>的程序 <strong>交互</strong>。这种请求称为<strong>API调用</strong>。请求的数据将<strong>以易于处理的格式(如JSON或CSV)返回</strong>。</p><p><strong>依赖于外部数据源</strong>的大多数应用程序都<strong>依赖于API调用</strong>，如集成社交媒体网站的应用程序。</p><h4 id="Git-和-GitHub"><a href="#Git-和-GitHub" class="headerlink" title="Git 和 GitHub"></a>Git 和 GitHub</h4><p>本章的可视化将基于来自GitHub的信息。我们将<strong>使用GitHub的API来请求有关该网站中Python项目的信息</strong>，然后<strong>使用Pygal生成交互式可视化，以呈现这些项目的受欢迎程度</strong>。</p><p>本章将编写一个程序，它<strong>自动下载GitHub上星级最高的Python项目的信息，并对这些信息进行可视化</strong>。</p><hr><h4 id="使用-API-调用请求数据"><a href="#使用-API-调用请求数据" class="headerlink" title="使用 API 调用请求数据"></a>使用 API 调用请求数据</h4><p>GitHub的API让你能够通过API调用来请求各种信息。要知道API调用是什么样的，在浏览器中访问如下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.github.com/search/repositories?q=language:python&amp;sort=starshttps://api.github.com/</span><br></pre></td></tr></table></figure><ul><li>第一部分<code>https://api.github.com/</code>：将请求发送到GitHub网站中响应API调用的部分</li><li>接下来的部分<code>search/repositories</code>：让API<strong>搜索GitHub上的所有仓库</strong></li><li>repositories后面的<strong>问号</strong>指出我们<strong>要传递一个实参</strong>。<ul><li><code>q=</code>：<strong>q</strong>表示<strong>查询</strong>，<strong>等号</strong>让我们能够开始<strong>指定查询</strong></li><li>通过使用<code>language:python</code>，我们指出<strong>只想获取主要语言为Python的仓库的信息</strong></li></ul></li><li>最后一部分<code>&amp;sort=stars</code>：指定将<strong>项目按其获得的星级排序</strong></li></ul><hr><h4 id="安装-requests"><a href="#安装-requests" class="headerlink" title="安装 requests"></a>安装 requests</h4><p><strong>requests包</strong>让Python程序能够<strong>轻松地向网站请求信息以及检查返回的响应</strong>。要安装requests，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user requests</span><br></pre></td></tr></table></figure><hr><h4 id="处理-API-响应"><a href="#处理-API-响应" class="headerlink" title="处理 API 响应"></a>处理 API 响应</h4><p>下面来编写一个程序，它执行API调用并处理结果，找出GitHub上星级最高的Python项目：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行API调用并存储响应</span></span><br><span class="line">url = <span class="string">'https://api.github.com/search/repositories?=language:python&amp;sort=stars'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(<span class="string">"Status code:"</span>, r.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将API响应存储在一个变量中</span></span><br><span class="line">response_dict = r.json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理结果</span></span><br><span class="line">print(response_dict.keys())</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>requests.get()</code>执行<strong>API调用</strong></p><p>  <strong>响应对象包含</strong>一个名为<code>status_code</code>的属性</p><ul><li>状态码<strong>200</strong>表示<strong>请求成功</strong></li></ul></li><li><p>这个API返回JSON格式的信息。因此我们<strong>使用方法<code>json()</code>将这些信息转换为一个Python字典</strong></p></li></ul><hr><h4 id="处理响应字典"><a href="#处理响应字典" class="headerlink" title="处理响应字典"></a>处理响应字典</h4><p>下面来生成一些概述API调用返回的信息的输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行API调用并存储响应</span></span><br><span class="line">url = <span class="string">'https://api.github.com/search/repositories?q=language:python&amp;sort=stars'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(<span class="string">"Status code:"</span>, r.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将API响应存储在一个变量中</span></span><br><span class="line">response_dict = r.json()</span><br><span class="line">print(<span class="string">"Total repositories:"</span>, response_dict[<span class="string">'total_count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 探索有关仓库的信息</span></span><br><span class="line">repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line">print(<span class="string">"Repositories returned:"</span>, len(repo_dicts))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 研究第一个仓库</span></span><br><span class="line">repo_dict = repo_dicts[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">"\nKeys:"</span>, len(repo_dict))</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> sorted(repo_dict.keys()):</span><br><span class="line">    print(key)</span><br></pre></td></tr></table></figure><ul><li>与<code>&#39;items&#39;</code>关联的值是<strong>一个列表</strong>，其中包含很多字典，<strong>每个字典都包含有关一个Python仓库的信息</strong>。</li></ul><p>下面来提取repo_dict中与一些键相关联的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 研究第一个仓库</span></span><br><span class="line">repo_dict = repo_dicts[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nSelected information about first repository:"</span>)</span><br><span class="line">print(<span class="string">'Name:'</span>, repo_dict[<span class="string">'name'</span>])</span><br><span class="line">print(<span class="string">'Owner:'</span>, repo_dict[<span class="string">'owner'</span>][<span class="string">'login'</span>])</span><br><span class="line">print(<span class="string">'Stars:'</span>, repo_dict[<span class="string">'stargazers_count'</span>])</span><br><span class="line">print(<span class="string">'Reposiory:'</span>, repo_dict[<span class="string">'html_url'</span>])</span><br><span class="line">print(<span class="string">'Created:'</span>, repo_dict[<span class="string">'created_at'</span>])</span><br><span class="line">print(<span class="string">'Updated:'</span>, repo_dict[<span class="string">'updated_at'</span>])</span><br><span class="line">print(<span class="string">'Description:'</span>, repo_dict[<span class="string">'description'</span>])</span><br></pre></td></tr></table></figure><hr><h4 id="概述最受欢迎的仓库"><a href="#概述最受欢迎的仓库" class="headerlink" title="概述最受欢迎的仓库"></a>概述最受欢迎的仓库</h4><p>对这些数据进行<strong>可视化</strong>时，我们需要<strong>涵盖多个仓库</strong>。下面就来编写一个循环，打印API调用返回的每个仓库的特定信息，以便能够在可视化中包含所有这些信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment"># 研究有关仓库的信息</span></span><br><span class="line">repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line">print(<span class="string">"Repositories returned:"</span>, len(repo_dicts))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nSelected information about each repository:"</span>)</span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">    print(<span class="string">'\nName:'</span>, repo_dict[<span class="string">'name'</span>])</span><br><span class="line">    print(<span class="string">'Owner:'</span>, repo_dict[<span class="string">'owner'</span>][<span class="string">'login'</span>])</span><br><span class="line">    print(<span class="string">'Stars:'</span>, repo_dict[<span class="string">'stargazers_count'</span>])</span><br><span class="line">    print(<span class="string">'Reposiory:'</span>, repo_dict[<span class="string">'html_url'</span>])</span><br><span class="line">    print(<span class="string">'Description:'</span>, repo_dict[<span class="string">'description'</span>])</span><br></pre></td></tr></table></figure><hr><h4 id="监视-API-的速率限制"><a href="#监视-API-的速率限制" class="headerlink" title="监视 API 的速率限制"></a>监视 API 的速率限制</h4><p>大多数API都存在<strong>速率限制</strong>，即你<strong>在特定时间内可执行的请求数存在限制</strong>。要获悉你是否接近了GitHub的限制，在浏览器中输入<code>https://api.github.com/rate_limit</code>，将得到类似于下面的响应：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"resources"</span>:&#123;</span><br><span class="line">        <span class="attr">"core"</span>:&#123;</span><br><span class="line">            <span class="attr">"limit"</span>:<span class="number">60</span>,</span><br><span class="line">            <span class="attr">"remaining"</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">"reset"</span>:<span class="number">1593698255</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"graphql"</span>:&#123;</span><br><span class="line">            <span class="attr">"limit"</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">"remaining"</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">"reset"</span>:<span class="number">1593700880</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"integration_manifest"</span>:&#123;</span><br><span class="line">            <span class="attr">"limit"</span>:<span class="number">5000</span>,</span><br><span class="line">            <span class="attr">"remaining"</span>:<span class="number">5000</span>,</span><br><span class="line">            <span class="attr">"reset"</span>:<span class="number">1593700880</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"search"</span>:&#123;</span><br><span class="line">            <span class="attr">"limit"</span>:<span class="number">10</span>,</span><br><span class="line">            <span class="attr">"remaining"</span>:<span class="number">10</span>,</span><br><span class="line">            <span class="attr">"reset"</span>:<span class="number">1593697340</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rate"</span>:&#123;</span><br><span class="line">        <span class="attr">"limit"</span>:<span class="number">60</span>,</span><br><span class="line">        <span class="attr">"remaining"</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">"reset"</span>:<span class="number">1593698255</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们关心的信息是<strong>搜索API</strong>的速率限制。从18~22行可知，极限为<strong>每分钟</strong>10个请求；当前这一分钟内，还可执行10个请求；<code>reset</code>值指的是<strong>配额将重置的Unix时间或新纪元时间(1970-01-01午夜后多少秒)</strong>。用完配额后，将收到一条简单的响应，由此知道已到达API极限。<strong>到达极限后</strong>，<strong>必须等待配额重置</strong>。</p><p>注意：<strong>很多API都要求你注册获得密钥后才能执行API调用</strong>。GitHub没有这样的要求，但获得API密钥后，配额将高得多。</p><hr><h3 id="使用-Pygal-可视化仓库"><a href="#使用-Pygal-可视化仓库" class="headerlink" title="使用 Pygal 可视化仓库"></a>使用 Pygal 可视化仓库</h3><p>我们来进行可视化，<strong>呈现GitHub上Python项目的受欢迎程度</strong>。创建一个交互式条形图，<strong>条形的高度表示项目获得了多少颗星。单击条形将进入项目在GitHub上的主页</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle <span class="keyword">as</span> LCS, LightenStyle <span class="keyword">as</span> LS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行API调用并存储响应</span></span><br><span class="line">url = <span class="string">'https://api.github.com/search/repositories?q=language:python&amp;sort=stars'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(<span class="string">"Status code:"</span>, r.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将API响应存储在一个变量中</span></span><br><span class="line">response_dict = r.json()</span><br><span class="line">print(<span class="string">"Total repositories:"</span>, response_dict[<span class="string">'total_count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 研究有关仓库的信息</span></span><br><span class="line">repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line"></span><br><span class="line">names, stars = [], []</span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">    names.append(repo_dict[<span class="string">'name'</span>])</span><br><span class="line">    stars.append(repo_dict[<span class="string">'stargazers_count'</span>])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">my_style = LS(<span class="string">'#333366'</span>, base_style=LCS)</span><br><span class="line">chart = pygal.Bar(style=my_style, x_label_rotation=<span class="number">45</span>, show_legend=<span class="literal">False</span>)</span><br><span class="line">chart.title = <span class="string">'Most-Starred Python Projects on GitHub'</span></span><br><span class="line">chart.x_labels = names</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">''</span>, stars)</span><br><span class="line">chart.render_to_file(<span class="string">'python_repos.svg'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>LS(&#39;#333366&#39;, base_style=LCS)</code>：使用<strong>LightenStyle</strong>(别名LS)<strong>定义了一种样式</strong>，并将<strong>基色设置为深蓝色</strong>；还传递了实参<code>base_style</code>，以<strong>使用LightColorizedStyle类</strong>(别名LCS)</li><li><code>show_legend=False</code>隐藏了图例，因为只在图表中绘制一个数据系列</li><li>由于<strong>不需要给这个数据系列添加标签</strong>，因此<strong>添加数据时，将标签设置成了空字符串</strong>。</li></ul><h4 id="改进-Pygal-图表"><a href="#改进-Pygal-图表" class="headerlink" title="改进 Pygal 图表"></a>改进 Pygal 图表</h4><p>我们将进行多个方面的定制，因此先来稍微调整代码结构，<strong>创建一个配置对象</strong>，其中包含要传递给<code>Bar()</code>的所有定制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">my_style = LS(<span class="string">'#333366'</span>, base_style=LCS)</span><br><span class="line"></span><br><span class="line">my_config = pygal.Config()</span><br><span class="line">my_config.x_label_rotation = <span class="number">45</span></span><br><span class="line">my_config.show_legend = <span class="literal">False</span></span><br><span class="line">my_config.title_font_size = <span class="number">24</span></span><br><span class="line">my_config.label_font_size = <span class="number">14</span></span><br><span class="line">my_config.major_label_font_size = <span class="number">18</span></span><br><span class="line">my_config.truncate_label = <span class="number">15</span></span><br><span class="line">my_config.show_y_guides = <span class="literal">False</span></span><br><span class="line">my_config.width = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">chart = pygal.Bar(my_config, style=my_style)</span><br><span class="line">chart.title = <span class="string">'Most-Starred Python Projects on GitHub'</span></span><br><span class="line">chart.x_labels = names</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">''</span>, stars)</span><br><span class="line">chart.render_to_file(<span class="string">'python_repos.svg'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>9~11行设置了图表标题、副标签和主标签的字体大小。</p><p>  在<strong>这个图表中</strong>，<strong>副标签</strong>是x轴上的项目名和y轴上的<strong>大部分</strong>数字；<strong>主标签</strong>是y轴上为<strong>5000整数倍的刻度</strong>，这些标签更大，以与副标签区分开。</p></li><li><p><code>truncate_label=15</code><strong>将较长的项目缩短</strong>为15个字符(将鼠标指向被截短的项目名，将显示完整的项目名)</p></li><li><p><code>show_y_guides=False</code>：<strong>隐藏图表中的水平线</strong>。</p></li><li><p><code>width=1000</code>：自定义的宽度，让图表更充分地利用浏览器中的可用空间</p></li></ul><hr><h4 id="添加自定义工具提示"><a href="#添加自定义工具提示" class="headerlink" title="添加自定义工具提示"></a>添加自定义工具提示</h4><p>在Python中，<strong>将鼠标指向条形将显示它表示的信息</strong>，这通常称为<strong>工具提示</strong>。下面来创建一个自定义工具提示，以同时显示项目的描述。</p><p>来看一个简单的示例，它可视化前三个项目，并给每个项目对应的条形都指定自定义标签。为此，我们向<code>add()</code><strong>传递一个字典列表</strong>，而不是值列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle <span class="keyword">as</span> LCS, LightenStyle <span class="keyword">as</span> LS</span><br><span class="line"></span><br><span class="line">my_style = LS(<span class="string">'#333366'</span>, base_style=LCS)</span><br><span class="line">chart = pygal.Bar(style=my_style, x_label_rotation=<span class="number">45</span>, show_legend=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">chart.title = <span class="string">'Python Projects'</span></span><br><span class="line">chart.x_labels = [<span class="string">'httpie'</span>, <span class="string">'django'</span>, <span class="string">'flask'</span>]</span><br><span class="line"></span><br><span class="line">plot_dicts = [</span><br><span class="line">    &#123;<span class="string">'value'</span>: <span class="number">16101</span>， <span class="string">'label'</span>: <span class="string">'Description of httpie.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'value'</span>: <span class="number">15028</span>, <span class="string">'label'</span>: <span class="string">'Description of django.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'value'</span>: <span class="number">14798</span>, <span class="string">'label'</span>: <span class="string">'Description of flask.'</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">''</span>, plot_dicts)</span><br><span class="line">chart.render_to_file(<span class="string">'bar_descriptions.svg'</span>)</span><br></pre></td></tr></table></figure><ul><li>plot_dicts列表包含三个字典，<code>&#39;value&#39;</code>对应的值<strong>确定条形高度</strong>；<code>&#39;label&#39;</code>对应的值给条形<strong>创建工具提示</strong>。</li></ul><hr><h4 id="根据数据绘图"><a href="#根据数据绘图" class="headerlink" title="根据数据绘图"></a>根据数据绘图</h4><p>为根据数据绘图，我们将自动生成plot_dicts。其中包含API调用返回的30个项目的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment"># 研究有关仓库的信息</span></span><br><span class="line">repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line">print(<span class="string">"Number of items:"</span>, len(repo_dicts))</span><br><span class="line"></span><br><span class="line">names, plot_dicts = [], []</span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">    names.append(repo_dict[<span class="string">'name'</span>])</span><br><span class="line">    </span><br><span class="line">    plot_dict = &#123;</span><br><span class="line">        <span class="string">'value'</span>: repo_dict[<span class="string">'stargazers_count'</span>],</span><br><span class="line">        <span class="string">'label'</span>: repo_dict[<span class="string">'description'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    plot_dicts.append(plot_dict)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">my_style = LS(<span class="string">'#333366'</span>, base_style=LCS)</span><br><span class="line">--snip--</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">''</span>, plot_dicts)</span><br><span class="line">chart.render_to_file(<span class="string">'python_repos.svg'</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="在图表中添加可单击的链接"><a href="#在图表中添加可单击的链接" class="headerlink" title="在图表中添加可单击的链接"></a>在图表中添加可单击的链接</h4><p>Pygal还允许<strong>将图表中的每个条形用作网站的链接</strong>。为此，在为每个项目创建的字典中，添加一个键为<code>&#39;xlink&#39;</code>的 键-值 对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line">names, plot_dicts = [], []</span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">    names.append(repo_dict[<span class="string">'name'</span>])</span><br><span class="line">    </span><br><span class="line">    plot_dict = &#123;</span><br><span class="line">        <span class="string">'value'</span>: repo_dict[<span class="string">'stargazers_count'</span>],</span><br><span class="line">        <span class="string">'label'</span>: repo_dict[<span class="string">'description'</span>],</span><br><span class="line">        <span class="string">'xlink'</span>: repo_dict[<span class="string">'html_url'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    plot_dicts.append(plot_dict)</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><p>单击图表中的任何条形，都将在浏览器中打开一个新的标签页，并在其中显示相应项目的GitHub页面。</p><hr><h3 id="Hacker-News-API"><a href="#Hacker-News-API" class="headerlink" title="Hacker News API"></a>Hacker News API</h3><p><del>为探索如何使用其他网站的API调用，我们来看看</del></p><p><del>Hacker News网站，用户分享编程和技术方面的文章，并就这些文章展开积极的讨论。Hacker News的API让你能够访问有关该网站所有文章和评论的信息，且不要求通过注册获得密钥。</del></p><p>已被墙。</p><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Jupyter-Notebook-用matplotlib作图显示中文乱码"><a href="#Jupyter-Notebook-用matplotlib作图显示中文乱码" class="headerlink" title="Jupyter Notebook 用matplotlib作图显示中文乱码"></a>Jupyter Notebook 用matplotlib作图显示中文乱码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.rc(<span class="string">'font'</span>, family=<span class="string">'SimHei'</span>, size=<span class="number">7</span>)  <span class="comment">##显示中文，字体大小根据需要调整</span></span><br></pre></td></tr></table></figure><hr><h3 id="存在极端值干扰"><a href="#存在极端值干扰" class="headerlink" title="存在极端值干扰"></a>存在极端值干扰</h3><ul><li><p>使用<code>query()</code>做范围的筛选</p></li><li><p>根据<strong>切比雪夫定理</strong>做筛选：</p><ul><li>所有数据中，至少有75%的数据位于<strong>平均数</strong>2个<strong>标准差</strong>范围内</li></ul></li><li>所有数据中，至少有88.9%的数据位于平均数3个标准差范围内<ul><li>所有数据中，至少有96%的数据位于平均数5个标准差范围内</li></ul></li></ul><hr><h3 id="条形图和直方图的区别"><a href="#条形图和直方图的区别" class="headerlink" title="条形图和直方图的区别"></a>条形图和直方图的区别</h3><ul><li><p><strong>条形图</strong>(<strong>bar</strong> chart)</p><ol><li>用<strong>条形的高度</strong>表示<strong>各类别频数的多少</strong>，其<strong>宽度</strong>(<strong>表示类别</strong>)则是<strong>固定</strong>的；</li><li>条形图各矩形<strong>分开排列(有间隙)</strong></li><li>主要用于展示<strong>分类数据</strong></li></ol></li><li><p><strong>直方图</strong>(<strong>Histogram</strong>)</p><ol><li>用<strong>面积</strong>表示<strong>各组频数的多少</strong>，矩形的<strong>高度</strong>表示<strong>每一组的频数或频率</strong>，<strong>宽度</strong>则表示<strong>各组的组距</strong></li><li><strong>分组数据具有连续性</strong>，直方图各矩形通常是<strong>连续排列</strong></li><li>主要用于展示<strong>数值型数据</strong></li></ol></li></ul><hr><h3 id="绘图时x轴-y轴的刻度标签重叠"><a href="#绘图时x轴-y轴的刻度标签重叠" class="headerlink" title="绘图时x轴/y轴的刻度标签重叠"></a>绘图时x轴/y轴的刻度标签重叠</h3><p><a href="https://cloud.tencent.com/developer/article/1441795" target="_blank" rel="noopener">Matplotlib绘图时x轴标签重叠的解决办法 - 云+社区 - 腾讯云</a></p><ul><li><p>方法一：</p><p>  拉长画布</p></li><li><p>方法二：</p><p>  调整刻度标签的字体大小：<code>plt.tick_params(axis=&#39;x&#39;, labelsize=8)</code></p></li><li><p>方法三：</p><p>  将纵向图改为横向，如条形图：<code>plt.barh()</code></p></li><li><p><strong>方法四</strong>：</p><p>  <strong>旋转刻度标签的角度</strong>：<code>plt.xticks(rotation=30)</code></p></li></ul><hr><h2 id="Pandas常用图表简介"><a href="#Pandas常用图表简介" class="headerlink" title="Pandas常用图表简介"></a><a href="https://www.kesci.com/home/project/5dc00c36080dc300371f867e" target="_blank" rel="noopener">Pandas常用图表简介</a></h2><h3 id="箱线图-箱型图-盒型图"><a href="#箱线图-箱型图-盒型图" class="headerlink" title="箱线图(箱型图/盒型图)"></a>箱线图(箱型图/盒型图)</h3><p><strong>直方图</strong>用于显示一组数据的<strong>分布情况</strong>，而<strong>箱线图</strong>用于显示一组数据<strong>内部的分散情况</strong>。例如： <strong>最大值、最小值，中位数，4分位数、异常值</strong>等等。</p><ul><li><p>箱线图各部位的含义</p><p>  <img src="https://i.loli.net/2020/08/23/sQpFl2vnWYNZ4x7.png" alt="箱线图各部位的含义"></p><ul><li><p><strong>上四分位</strong>数(Q<strong>U</strong>)：第75%位数</p></li><li><p><strong>下四分位</strong>数(Q<strong>L</strong>)：第25%位数</p></li><li><p>异常值的标准：</p><ul><li><p><strong>IQR</strong>(Inter-Quatile range)：<strong>四分位距</strong></p><p>  <strong>IQR = QU - QL</strong>，<strong>IQR包含了全部观察值的一半</strong></p></li><li><p><strong>过小</strong>的异常值为 $&lt;$ <strong>QL-1.5IQR</strong>的值</p></li><li><p><strong>过大</strong>的异常值 $&gt;$ <strong>QU+1.5IQR</strong>的值</p></li></ul><p>Matplotlib中绘制箱线图的函数为<code>DataFrame.boxplot()</code></p></li></ul></li></ul><hr><h2 id="一文学会matplotlib绘图"><a href="#一文学会matplotlib绘图" class="headerlink" title="一文学会matplotlib绘图"></a><a href="https://www.jianshu.com/p/985bc26672ce" target="_blank" rel="noopener">一文学会matplotlib绘图</a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> matplotlib </tag>
            
            <tag> svg </tag>
            
            <tag> CSV </tag>
            
            <tag> pyplot </tag>
            
            <tag> pygal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat使用技巧</title>
      <link href="/2020/06/17/Navicat%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/06/17/Navicat%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + R</td><td><strong>运行</strong>查询语句</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Navicat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL练习题</title>
      <link href="/2020/06/17/SQL%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2020/06/17/SQL%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><h4 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students</span><br><span class="line">(sno <span class="built_in">VARCHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">sname <span class="built_in">VARCHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">ssex <span class="built_in">VARCHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">sbirthday DATETIME,</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">VARCHAR</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> courses</span><br><span class="line">(cno <span class="built_in">VARCHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">cname <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">tno <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> scores</span><br><span class="line">(sno <span class="built_in">VARCHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">cno <span class="built_in">VARCHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">degree <span class="built_in">NUMERIC</span>(<span class="number">10</span>, <span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teachers </span><br><span class="line">(tno <span class="built_in">VARCHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">tname <span class="built_in">VARCHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, tsex <span class="built_in">VARCHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">tbirthday DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>, prof <span class="built_in">VARCHAR</span>(<span class="number">6</span>), </span><br><span class="line">depart <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (sno, sname, ssex, sbrithday, <span class="keyword">class</span>) <span class="keyword">VALUES</span> (<span class="number">108</span> ,<span class="string">'曾华'</span> ,<span class="string">'男'</span> ,<span class="string">'1977-09-01'</span>,<span class="number">95033</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (sno, sname, ssex, sbrithday, <span class="keyword">class</span>) <span class="keyword">VALUES</span> (<span class="number">105</span> ,<span class="string">'匡明'</span> ,<span class="string">'男'</span> ,<span class="string">'1975-10-02'</span>,<span class="number">95031</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (sno, sname, ssex, sbrithday, <span class="keyword">class</span>) <span class="keyword">VALUES</span> (<span class="number">107</span> ,<span class="string">'王丽'</span> ,<span class="string">'女'</span> ,<span class="string">'1976-01-23'</span>,<span class="number">95033</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (sno, sname, ssex, sbrithday, classS) <span class="keyword">VALUES</span> (<span class="number">101</span> ,<span class="string">'李军'</span> ,<span class="string">'男'</span> ,<span class="string">'1976-02-20'</span>,<span class="number">95033</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (sno, sname, ssex, sbrithday, <span class="keyword">class</span>) <span class="keyword">VALUES</span> (<span class="number">109</span> ,<span class="string">'王芳'</span> ,<span class="string">'女'</span> ,<span class="string">'1975-02-10'</span>,<span class="number">95031</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (sno, sname, ssex, sbrithday, <span class="keyword">class</span>) <span class="keyword">VALUES</span> (<span class="number">103</span> ,<span class="string">'陆君'</span> ,<span class="string">'男'</span> ,<span class="string">'1974-06-03'</span>,<span class="number">95031</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COURSES(cno, cname, tno) <span class="keyword">VALUES</span> (<span class="string">'3-105'</span> ,<span class="string">'计算机导论'</span>,<span class="number">825</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COURSES(cno, cname, tno) <span class="keyword">VALUES</span> (<span class="string">'3-245'</span> ,<span class="string">'操作系统'</span> ,<span class="number">804</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COURSES(cno, cname, tno) <span class="keyword">VALUES</span> (<span class="string">'6-166'</span> ,<span class="string">'数据电路'</span> ,<span class="number">856</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COURSES(cno, cname, tno) <span class="keyword">VALUES</span> (<span class="string">'9-888'</span> ,<span class="string">'高等数学'</span> ,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">103</span>,<span class="string">'3-245'</span>,<span class="number">86</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">105</span>,<span class="string">'3-245'</span>,<span class="number">75</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">109</span>,<span class="string">'3-245'</span>,<span class="number">68</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">103</span>,<span class="string">'3-105'</span>,<span class="number">92</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">105</span>,<span class="string">'3-105'</span>,<span class="number">88</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">109</span>,<span class="string">'3-105'</span>,<span class="number">76</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">101</span>,<span class="string">'3-105'</span>,<span class="number">64</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">107</span>,<span class="string">'3-105'</span>,<span class="number">91</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">108</span>,<span class="string">'3-105'</span>,<span class="number">78</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">101</span>,<span class="string">'6-166'</span>,<span class="number">85</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">107</span>,<span class="string">'6-166'</span>,<span class="number">79</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SCORES(sno, cno, degree) <span class="keyword">VALUES</span> (<span class="number">108</span>,<span class="string">'6-166'</span>,<span class="number">81</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEACHERS(tno, tname, tsex, tbirthday, prof, depart) <span class="keyword">VALUES</span> (<span class="number">804</span>,<span class="string">'李诚'</span>,<span class="string">'男'</span>,<span class="string">'1958-12-02'</span>,<span class="string">'副教授'</span>,<span class="string">'计算机系'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEACHERS(tno, tname, tsex, tbirthday, prof, depart) <span class="keyword">VALUES</span> (<span class="number">856</span>,<span class="string">'张旭'</span>,<span class="string">'男'</span>,<span class="string">'1969-03-12'</span>,<span class="string">'讲师'</span>,<span class="string">'电子工程系'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEACHERS(tno, tname, tsex, tbirthday, prof, depart) <span class="keyword">VALUES</span> (<span class="number">825</span>,<span class="string">'王萍'</span>,<span class="string">'女'</span>,<span class="string">'1972-05-05'</span>,<span class="string">'助教'</span>,<span class="string">'计算机系'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEACHERS(tno, tname, tsex, tbirthday, prof, depart) <span class="keyword">VALUES</span> (<span class="number">831</span>,<span class="string">'刘冰'</span>,<span class="string">'女'</span>,<span class="string">'1977-08-14'</span>,<span class="string">'助教'</span>,<span class="string">'电子工程系'</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>查询student表中的所有记录的sname、ssex和class列。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname, ssex, <span class="keyword">class</span></span><br><span class="line"><span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure></li><li><p>查询教师所有的单位，即<strong>不重复</strong>的depart列。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> depart</span><br><span class="line"><span class="keyword">FROM</span> teachers;</span><br></pre></td></tr></table></figure></li><li><p>查询students表的<strong>所有</strong>记录。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure></li><li><p>查询scores表中<strong>成绩在60到80之间</strong>的所有记录。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> degree &gt;= <span class="number">60</span> <span class="keyword">AND</span> degree &lt;= <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> degree <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure></li><li><p>★查询scores表中<strong>成绩为85，86或88的记录</strong>。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> degree <span class="keyword">IN</span> (<span class="number">85</span>, <span class="number">86</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> degree = <span class="number">85</span> <span class="keyword">OR</span> degree = <span class="number">86</span> <span class="keyword">OR</span> degree = <span class="number">88</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询students表中<strong>“95031”班</strong>或<strong>性别为“女”</strong>的同学记录。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">class</span> = <span class="string">'95031'</span> <span class="keyword">OR</span> ssex = <span class="string">'女'</span>;</span><br></pre></td></tr></table></figure></li><li><p>以<strong>class降序</strong>查询students表的所有记录。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">class</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>★以<strong>cno升序</strong>、<strong>degree降序</strong>查询scores表的所有记录。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> con, degree <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询student表中“95031”班的学生<strong>人数</strong>。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> stu_num</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">class</span> = <span class="string">'95031'</span>;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询<strong>scores</strong>表中的<strong>最高分</strong>的学生学号和课程号。</p><p>解答：<strong>子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno, cno</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> degree = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(degree)</span><br><span class="line">                <span class="keyword">FROM</span> scores);</span><br></pre></td></tr></table></figure></li><li><p>★查询scores表中‘3-105’号课程的<strong>平均分</strong>。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(degree)</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> cno = <span class="string">'3-105'</span>;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询scores表中<strong>至少有5名学生选修</strong>的并<strong>以3开头的课程</strong>的<strong>平均分数</strong>。</p><p>解答：<strong>分组</strong>（<strong>HAVING子句</strong>用于过滤分组）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">SELECT</span> cno, <span class="keyword">AVG</span>(degree) <span class="keyword">AS</span> avg_degree</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> cno <span class="keyword">LIKE</span> <span class="string">'3%'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">SELECT</span> cno, <span class="keyword">AVG</span>(degree) <span class="keyword">AS</span> avg_degree</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">5</span> <span class="keyword">AND</span> cno <span class="keyword">LIKE</span> <span class="string">'3%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询scores表中<strong>最低分大于70</strong>，<strong>最高分小于90</strong>的sno列。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MIN</span>(degree) &gt; <span class="number">70</span> <span class="keyword">AND</span> <span class="keyword">MAX</span>(degree) &lt; <span class="number">90</span>;</span><br></pre></td></tr></table></figure></li><li><p>★★查询所有学生的sname、cno和degree列。</p><p>解答：</p><ul><li><strong>外部</strong>联结(OUTER JOIN, <strong>OUTER可省略</strong>)</li><li><strong>内部</strong>联结(INNER JOIN)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：外部联结, LEFT JOIN 左边的表 所有记录都会列出</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.sname, sco.cno, sco.degree</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> scores <span class="keyword">AS</span> sco</span><br><span class="line"><span class="keyword">ON</span> stu.sno = sco.sno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sname;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：内部联结， INNER JOIN 只返回两个表中联结字段相等的行</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.sname, sco.cno, sco.degree</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> stu <span class="keyword">INNER</span> <span class="keyword">JOIN</span> scores <span class="keyword">AS</span> sco</span><br><span class="line"><span class="keyword">ON</span> stu.sno = sco.sno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sname;</span><br></pre></td></tr></table></figure></li><li><p>★查询所有学生的sno、cname和degree列。</p><p>解答：外部联结</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sno, c.cname, s.degree</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses <span class="keyword">AS</span> c <span class="keyword">ON</span> s.cno = c.cno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sno;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询所有学生的sname、cname和degree列。</p><p>解答：外部联结</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> st.sname, c.cname, sc.degree</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> st </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> scores <span class="keyword">AS</span> sc <span class="keyword">ON</span> st.sno = sc.sno</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses <span class="keyword">AS</span> c <span class="keyword">ON</span> sc.cno = c.cno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sname;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询“95033”班<strong>所选课程</strong>的平均分。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname, <span class="keyword">AVG</span>(degree)</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> st</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> scores <span class="keyword">AS</span> sc <span class="keyword">ON</span> st.sno = sc.sno</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses <span class="keyword">AS</span> c <span class="keyword">ON</span> sc.cno = c.cno</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">class</span> = <span class="string">'95033'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.cno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cname;</span><br></pre></td></tr></table></figure></li><li><p>★★★假设使用如下命令建立了一个grade表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade(<span class="keyword">low</span> <span class="built_in">INT</span>(<span class="number">3</span>), upp <span class="built_in">INT</span>(<span class="number">3</span>), <span class="keyword">rank</span> <span class="built_in">CHAR</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(<span class="number">90</span>,<span class="number">100</span>,<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(<span class="number">80</span>,<span class="number">89</span>,<span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(<span class="number">70</span>,<span class="number">79</span>,<span class="string">'C'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(<span class="number">60</span>,<span class="number">69</span>,<span class="string">'D'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(<span class="number">0</span>,<span class="number">59</span>,<span class="string">'E'</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>现查询所有同学的sno、cno和rank列。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno, cno, <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">INNER</span> <span class="keyword">JOIN</span> grade</span><br><span class="line"><span class="keyword">ON</span> scores.degree <span class="keyword">BETWEEN</span> grade.low <span class="keyword">AND</span> grade.upp</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sno;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询<strong>选修“3-105”课程</strong>的<strong>成绩高于“109”号同学成绩</strong>的所有同学的记录。</p><p>解答：</p><ul><li><strong>自联结</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname, s1.degree</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">AS</span> s1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> scores <span class="keyword">AS</span> s2 <span class="keyword">ON</span> s1.cno = s2.cno <span class="keyword">AND</span>  s1.degree &gt; s2.degree</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> students <span class="keyword">AS</span> st <span class="keyword">ON</span> s1.sno = st.sno</span><br><span class="line"><span class="keyword">WHERE</span> s1.cno = <span class="string">'3-105'</span> <span class="keyword">AND</span> s2.sno = <span class="string">'109'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s1.degree;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询scores中<strong>选学一门以上课程</strong>的同学中分数为<strong>非最高分成绩</strong>的记录。</p><p>解答：</p><ul><li>条件：<ol><li>选学一门以上课程</li><li>列出这些同学的所有非最高分成绩</li></ol></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> scores.sno, cno, degree, max_degree</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">INNER</span> <span class="keyword">JOIN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> sno, <span class="keyword">MAX</span>(degree) <span class="keyword">AS</span> max_degree </span><br><span class="line">             <span class="keyword">FROM</span> scores </span><br><span class="line">             <span class="keyword">GROUP</span> <span class="keyword">BY</span> sno </span><br><span class="line">             <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>) <span class="keyword">AS</span> <span class="keyword">max</span> </span><br><span class="line"><span class="keyword">ON</span> scores.sno = max.sno <span class="keyword">AND</span> degree &lt; max_degree</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sno;</span><br></pre></td></tr></table></figure></li></ol><ol start="21"><li><p>查询成绩高于<strong>学号为“109”、课程号为“3-105”的成绩</strong>的所有记录。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> st.sname, s1.cno, s1.degree</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> scores <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.cno = s2.cno <span class="keyword">AND</span> s1.degree &gt; s2.degree</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> students <span class="keyword">AS</span> st</span><br><span class="line"><span class="keyword">ON</span> s1.sno = st.sno</span><br><span class="line"><span class="keyword">WHERE</span> s1.cno = <span class="string">'3-105'</span> <span class="keyword">AND</span> s2.sno = <span class="string">'109'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s1.degree;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询和学号为108的同学<strong>同年出生</strong>的所有学生的sno、sname和sbirthday列。</p><p>解答：函数<code>YEAR(d)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.sno, s1.sname, s1.sbirthday</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> students <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">YEAR</span>(s1.sbirthday) = <span class="keyword">YEAR</span>(s2.sbirthday)</span><br><span class="line"><span class="keyword">WHERE</span> s2.sno = <span class="string">'108'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sbirthday;</span><br></pre></td></tr></table></figure></li></ol><ol start="23"><li><p>查询“张旭“教师任课的学生成绩。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno, degree</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses</span><br><span class="line"><span class="keyword">ON</span> scores.cno = courses.cno</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> teachers</span><br><span class="line"><span class="keyword">ON</span> courses.tno = teachers.tno</span><br><span class="line"><span class="keyword">WHERE</span> teachers.tname = <span class="string">'张旭'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> degree;</span><br></pre></td></tr></table></figure></li><li><p>查询选修某课程的同学人数<strong>多于5人</strong>的<strong>教师姓名</strong>。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tname</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">AS</span> s <span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> s.cno = c.cno</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> teachers <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> t.tno = c.tno</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.cno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(c.cno) &gt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询95033班和95031班<strong>全体学生的记录</strong>。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">class</span> <span class="keyword">IN</span> (<span class="string">'95033'</span>, <span class="string">'95031'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">class</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询<strong>有85分以上成绩</strong>的课程cno。</p><p>解答：<strong>DISTINCT</strong>关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c.cno</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> degree &gt; <span class="number">85</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询出“计算机系“教师所教课程的成绩表。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.tname, s.cno, cname, sno, degree</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">AS</span> s <span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> s.cno = c.cno</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> teachers <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> t.tno = c.tno</span><br><span class="line"><span class="keyword">WHERE</span> t.depart = <span class="string">'计算机系'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t.tname, cname, degree <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询“计算机系”中与“电子工程系“的教师<strong>不同职称</strong>教师的tname和prof。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tname, prof</span><br><span class="line"><span class="keyword">FROM</span> teachers</span><br><span class="line"><span class="keyword">WHERE</span> depart = <span class="string">'计算机系'</span> <span class="keyword">AND</span> prof <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> prof</span><br><span class="line">                                <span class="keyword">FROM</span> teachers</span><br><span class="line">                                <span class="keyword">WHERE</span> depart = <span class="string">'电子工程系'</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询选修编号为“3-105”课程且成绩至少<strong>高于任意</strong>选修编号为“3-245”的同学的成绩的cno、sno和degree。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cno, sno, degree</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> cno = <span class="string">'3-105'</span> <span class="keyword">AND</span> degree &gt; (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(degree)</span><br><span class="line">    <span class="keyword">FROM</span> scores</span><br><span class="line">    <span class="keyword">WHERE</span> cno = <span class="string">'3-245'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> degree <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询选修编号为”3-105“且成绩<strong>高于所有</strong>选修编号为”3-245“课程的同学的cno、sno和degree。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cno, sno, degree</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">WHERE</span> cno = <span class="string">'3-105'</span> <span class="keyword">AND</span> degree &gt; (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(degree)</span><br><span class="line">    <span class="keyword">FROM</span> scores</span><br><span class="line">    <span class="keyword">WHERE</span> cno = <span class="string">'3-245'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> degree <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询<strong>所有教师和同学</strong>的name、sex和birthday。</p><p>解答：<strong>组合查询UNION</strong></p><ul><li>UNION中<strong>每个查询必须包含相同的列、表达式或聚集函数</strong>（不过各个列<strong>不需要以相同的次序列出</strong>）。</li><li>列数据类型必须<strong>兼容</strong>。类型不必完全相同，但必须是DBMS可以隐含地转换的类型(如<strong>不同的数值类型</strong>或<strong>不同的日期类型</strong>)。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tname <span class="keyword">AS</span> <span class="keyword">name</span>, tsex <span class="keyword">AS</span> sex, tbirthday <span class="keyword">AS</span> birthday</span><br><span class="line"><span class="keyword">FROM</span> teachers</span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> sname <span class="keyword">AS</span> <span class="keyword">name</span>, ssex <span class="keyword">AS</span> sex, sbirthday <span class="keyword">AS</span> birthday</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday;</span><br></pre></td></tr></table></figure></li><li><p>查询所有“女”教师和“女”同学的name、sex和birthday。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tname <span class="keyword">AS</span> <span class="keyword">name</span>, tsex <span class="keyword">AS</span> sex, tbirthday <span class="keyword">AS</span> birthday</span><br><span class="line"><span class="keyword">FROM</span> teachers <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">WHERE</span> t.tsex = <span class="string">'女'</span></span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> sname <span class="keyword">AS</span> <span class="keyword">name</span>, ssex <span class="keyword">AS</span> sex, sbirthday <span class="keyword">AS</span> birthday</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">WHERE</span> s.ssex = <span class="string">'女'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday;</span><br></pre></td></tr></table></figure></li><li><p>★★★查询成绩<strong>比该课程平均成绩低</strong>的同学的成绩表。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.*, avg_degree</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> cno, <span class="keyword">AVG</span>(degree) <span class="keyword">AS</span> avg_degree</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cno) <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.cno = s2.cno <span class="keyword">AND</span> s1.degree &lt; s2.avg_degree;</span><br></pre></td></tr></table></figure></li><li><p>查询所有<strong>任课教师</strong>的tname和depart。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> tname, depart</span><br><span class="line"><span class="keyword">FROM</span> courses <span class="keyword">AS</span> c <span class="keyword">INNER</span> <span class="keyword">JOIN</span> teachers <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> c.tno = t.tno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> tname, depart</span><br><span class="line"><span class="keyword">FROM</span> teachers</span><br><span class="line"><span class="keyword">WHERE</span> tno <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> tno</span><br><span class="line"><span class="keyword">FROM</span> courses)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tname;</span><br></pre></td></tr></table></figure></li><li><p>★查询所有<strong>未讲课</strong>的教师的Tname和Depart。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tname, depart</span><br><span class="line"><span class="keyword">FROM</span> teachers</span><br><span class="line"><span class="keyword">WHERE</span> tno <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> tno</span><br><span class="line"><span class="keyword">FROM</span> courses)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tname;</span><br></pre></td></tr></table></figure></li><li><p>★★查询<strong>至少有2名</strong>男生的班号。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> ssex = <span class="string">'男'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>★查询students表中<strong>不姓“王”</strong>的同学记录。</p><p>解答：</p><ul><li>LIKE操作符</li><li>通配符%</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">'王%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>★★查询students表中每个学生的姓名和<strong>年龄</strong>。</p><p>解答：</p><ul><li>当前<strong>日期</strong>函数CURDATE()</li><li>当前<strong>日期和时间</strong>函数NOW()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname, <span class="keyword">TIMESTAMPDIFF</span>(<span class="keyword">YEAR</span>, sbirthday, <span class="keyword">CURDATE</span>()) <span class="keyword">AS</span> age</span><br><span class="line"><span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure></li><li><p>★★查询students表中<strong>最大</strong>和<strong>最小</strong>的sbirthday<strong>日期</strong>值。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DATE</span>(<span class="keyword">MAX</span>(Sbirthday)) <span class="keyword">AS</span> max_birthday, <span class="built_in">DATE</span>(<span class="keyword">MIN</span>(Sbirthday)) <span class="keyword">AS</span> min_birthday,</span><br><span class="line"><span class="keyword">FROM</span> Students;</span><br></pre></td></tr></table></figure></li><li><p>以<strong>班号</strong>和<strong>年龄</strong>从大到小的顺序查询students表中的全部记录。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">class</span> <span class="keyword">DESC</span>, <span class="keyword">TIMESTAMPDIFF</span>(<span class="keyword">YEAR</span>, sbirthday, <span class="keyword">CURDATE</span>()) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询“男”教师及其<strong>所上的课程</strong>。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tname, cname</span><br><span class="line"><span class="keyword">FROM</span> teachers <span class="keyword">AS</span> t <span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> t.tno = c.tno</span><br><span class="line"><span class="keyword">WHERE</span> tsex=<span class="string">'男'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tname;</span><br></pre></td></tr></table></figure></li><li><p>★查询<strong>最高分</strong>同学的sno、cno和degree列。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno, cno, degree</span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cno</span><br><span class="line"><span class="keyword">HAVING</span> degree=<span class="keyword">MAX</span>(degree);</span><br></pre></td></tr></table></figure></li><li><p>查询和“李军”<strong>同性别</strong>的所有同学的sname。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> ssex = (</span><br><span class="line"><span class="keyword">SELECT</span> ssex</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> sname = <span class="string">'李军'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二 联结表</span></span><br><span class="line"><span class="keyword">SELECT</span> s1.Sname</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> students <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.ssex=s2.ssex</span><br><span class="line"><span class="keyword">WHERE</span> s2.sname = <span class="string">'李军'</span>;</span><br></pre></td></tr></table></figure></li><li><p>★★查询和“李军”<strong>同性别</strong>并<strong>同班</strong>的同学sname。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> students <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.ssex = s2.ssex <span class="keyword">AND</span> s1.class = s2.class</span><br><span class="line"><span class="keyword">WHERE</span> s2.sname = <span class="string">'李军'</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询所有<strong>选修“计算机导论”课程</strong>的<strong>“男”</strong>同学的成绩表。</p><p>解答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname, degree</span><br><span class="line"><span class="keyword">FROM</span> scores <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> s1.cno = c.cno</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> students <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.sno = s2.sno</span><br><span class="line"><span class="keyword">WHERE</span> c.cname = <span class="string">'计算机导论'</span> <span class="keyword">AND</span> s2.ssex = <span class="string">'男'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> degree <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><h3 id="准备数据-1"><a href="#准备数据-1" class="headerlink" title="准备数据"></a>准备数据</h3><h4 id="建表语句-1"><a href="#建表语句-1" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userinfo (</span><br><span class="line">  userId <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  sex <span class="built_in">varchar</span>(<span class="number">2</span>),</span><br><span class="line">  birth <span class="built_in">date</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (userId)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderinfo (</span><br><span class="line">  orderId <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  userId <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  isPaid <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  price <span class="built_in">float</span>(<span class="number">11</span>, <span class="number">2</span>),</span><br><span class="line">  paidTime <span class="built_in">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (orderId)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><ul><li><p>获取链接：<a href="https://pan.baidu.com/s/11ZtjKnv5-nwyf6cMyk_3JQ#list/path=%2F" target="_blank" rel="noopener">用户消费行为分析数据</a>；提取码：yu63</p></li><li><p>数据文件</p><ul><li><code>user_info_utf.csv</code></li><li><code>order_info_utf.csv</code></li></ul></li><li><p>通过navicat，选择对应的数据库表，选择<strong>导入</strong>：</p><ol><li><p>导入类型：CSV File</p></li><li><ul><li>导入从：选择需要导入的数据文件</li><li>编码：UTF-8(<strong>默认</strong>)</li></ul></li><li>记录分隔符：CRLF(<strong>默认</strong>)</li><li><ul><li>字段名行：若数据文件<strong>不包含数据表的列名</strong>，则输入<strong>0</strong>(<strong>默认</strong>为第<strong>1</strong>行)；</li><li>第一个数据行：若文件<strong>不包含数据表的列名</strong>，则输入<strong>1</strong>(<strong>默认</strong>为第<strong>2</strong>行)；</li><li><strong>日期排序</strong>：注意<strong>年月日的顺序</strong></li></ul></li><li>确认目标表</li><li>确认对应的<strong>目标字段</strong></li><li>将记录<strong>添加</strong>到目标表/<strong>删除目标表中原数据</strong>，用导入的记录代替</li><li>开始执行</li></ol></li></ul><hr><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>统计不同月份的下单人数</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(paidTime), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> userId)</span><br><span class="line"><span class="keyword">FROM</span> orderinfo</span><br><span class="line"><span class="keyword">WHERE</span> isPaid = <span class="string">'已支付'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">MONTH</span>(paidTime);</span><br></pre></td></tr></table></figure></li><li><p>统计用户<strong>三月份</strong>的<strong>复购</strong>率和<strong>回购</strong>率(三月份购买的用户，<strong>四月份也购买</strong>)</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复购率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(cnt) <span class="keyword">AS</span> 下单用户数, <span class="keyword">COUNT</span>(<span class="keyword">IF</span>(cnt &gt; <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>)) <span class="keyword">AS</span> 复购用户数</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> userId, <span class="keyword">COUNT</span>(userId) <span class="keyword">as</span> cnt</span><br><span class="line">      <span class="keyword">FROM</span> orderinfo</span><br><span class="line">      <span class="keyword">WHERE</span> isPaid = <span class="string">'已支付'</span> <span class="keyword">AND</span> <span class="keyword">MONTH</span>(paidTime) = <span class="number">3</span></span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> userId) <span class="keyword">AS</span> t;</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 3月份的回购率</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.m, <span class="keyword">COUNT</span>(t1.m), <span class="keyword">COUNT</span>(t2.m) </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> userId, <span class="keyword">DATE_FORMAT</span>(paidTime, <span class="string">'%Y-%m-01'</span>) <span class="keyword">AS</span> m</span><br><span class="line"><span class="keyword">FROM</span> orderinfo</span><br><span class="line"><span class="keyword">WHERE</span> isPaid = <span class="string">'已支付'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> userId, <span class="keyword">DATE_FORMAT</span>(paidTime, <span class="string">'%Y-%m-01'</span>)) <span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> userId, <span class="keyword">DATE_FORMAT</span>(paidTime, <span class="string">'%Y-%m-01'</span>) <span class="keyword">AS</span> m</span><br><span class="line"><span class="keyword">FROM</span> orderinfo</span><br><span class="line"><span class="keyword">WHERE</span> isPaid = <span class="string">'已支付'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> userId, <span class="keyword">DATE_FORMAT</span>(paidTime, <span class="string">'%Y-%m-01'</span>)) <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.userId = t2.userId <span class="keyword">AND</span> t1.m = <span class="keyword">DATE_ADD</span>(t2.m, <span class="built_in">INTERVAL</span> <span class="number">-1</span> <span class="keyword">MONTH</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.m;</span><br></pre></td></tr></table></figure></li><li><p>统计男女用户的<strong>消费频次</strong>(<strong>平均数</strong>)是否有差异</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sex, <span class="keyword">AVG</span>(cnt)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> o.userId, sex, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt  <span class="comment"># count(*)的作用为 统计消费次数</span></span><br><span class="line">      <span class="keyword">FROM</span> orderinfo <span class="keyword">AS</span> o</span><br><span class="line">      <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> *</span><br><span class="line">                  <span class="keyword">FROM</span> userinfo</span><br><span class="line">                  <span class="keyword">WHERE</span> sex != <span class="string">''</span>) <span class="keyword">AS</span> t</span><br><span class="line">      <span class="keyword">ON</span> o.userId = t.userId</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> o.userId, sex) <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br></pre></td></tr></table></figure></li><li><p>统计<strong>多次消费</strong>的用户，第一次和最后一次消费间隔是多少</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> userId, <span class="keyword">DATEDIFF</span>(<span class="keyword">MAX</span>(paidTime), <span class="keyword">MIN</span>(paidTime)) </span><br><span class="line"><span class="keyword">FROM</span> orderinfo</span><br><span class="line"><span class="keyword">WHERE</span> isPaid = <span class="string">'已支付'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> userId</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>统计不同<strong>年龄段</strong>，用户的消费金额是否有差异？</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ageGroup, <span class="keyword">AVG</span>(cnt)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> o.userId, ageGroup, <span class="keyword">count</span>(o.userId) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> orderinfo <span class="keyword">AS</span> o</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> userId, <span class="keyword">CEIL</span>((<span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) - <span class="keyword">YEAR</span>(birth)) / <span class="number">10</span>) <span class="keyword">AS</span> ageGroup</span><br><span class="line"><span class="keyword">FROM</span> userinfo</span><br><span class="line"><span class="keyword">WHERE</span> birth &gt; <span class="string">'1901-00-00'</span>) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> o.userId = t.userId</span><br><span class="line"><span class="keyword">WHERE</span> isPaid = <span class="string">'已支付'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> o.userId, ageGroup) <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ageGroup;</span><br></pre></td></tr></table></figure></li><li><p>统计消费的<strong>二八法则</strong>，消费的top20%用户，贡献了多少额度</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(userId), <span class="keyword">SUM</span>(total)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> userId, <span class="keyword">SUM</span>(price) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orderinfo <span class="keyword">AS</span> o</span><br><span class="line"><span class="keyword">WHERE</span> isPaid = <span class="string">'已支付'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> userId</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">17000</span>) <span class="keyword">AS</span> t;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><h3 id="准备数据-2"><a href="#准备数据-2" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> datafrog_test1</span><br><span class="line">(userid <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">changjing <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">int_time <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datafrog_test1 </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1001</span>,<span class="number">1400</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="number">1002</span>,<span class="number">1401</span>),</span><br><span class="line">        (<span class="number">1</span>,<span class="number">1002</span>,<span class="number">1402</span>),</span><br><span class="line">        (<span class="number">1</span>,<span class="number">1001</span>,<span class="number">1402</span>),</span><br><span class="line">        (<span class="number">2</span>,<span class="number">1003</span>,<span class="number">1403</span>),</span><br><span class="line">        (<span class="number">2</span>,<span class="number">1004</span>,<span class="number">1404</span>),</span><br><span class="line">        (<span class="number">3</span>,<span class="number">1003</span>,<span class="number">1400</span>),</span><br><span class="line">        (<span class="number">4</span>,<span class="number">1004</span>,<span class="number">1402</span>),</span><br><span class="line">        (<span class="number">4</span>,<span class="number">1003</span>,<span class="number">1403</span>),</span><br><span class="line">        (<span class="number">4</span>,<span class="number">1001</span>,<span class="number">1403</span>),</span><br><span class="line">        (<span class="number">4</span>,<span class="number">1002</span>,<span class="number">1404</span>),</span><br><span class="line">        (<span class="number">5</span>,<span class="number">1002</span>,<span class="number">1402</span>),</span><br><span class="line">        (<span class="number">5</span>,<span class="number">1002</span>,<span class="number">1403</span>),</span><br><span class="line">        (<span class="number">5</span>,<span class="number">1001</span>,<span class="number">1404</span>),</span><br><span class="line">        (<span class="number">5</span>,<span class="number">1003</span>,<span class="number">1405</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>求用户id对应的<strong>前两个不同场景</strong>。(场景重复的话，选场景的第一个访问时间，场景不足两个也输出其场景)</p><hr><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><hr><h2 id="Leetcode-上的SQL题"><a href="#Leetcode-上的SQL题" class="headerlink" title="Leetcode 上的SQL题"></a>Leetcode 上的SQL题</h2><ul><li><a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">176. 第二高的薪水</a></li><li><p><code>LIMIT/OFFSET</code></p></li><li><p><code>IFNULL()/ISNULL()</code>函数</p></li><li><p><a href="https://leetcode-cn.com/problems/nth-highest-salary/submissions/" target="_blank" rel="noopener">177. 第N高的薪水</a></p></li><li><p><code>CREATE FUNCTION</code></p><ul><li><code>LIMIT/OFFSET</code>之后<strong>不能包含运算表达式</strong></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/department-top-three-salaries/submissions/" target="_blank" rel="noopener">185. 部门工资前三高的所有员工 </a></p><ul><li><strong>窗口函数</strong>——<code>DENSE_RANK()</code>：<strong>有并列名次的行，不占用下一名次的位置</strong></li></ul></li></ul><hr><ul><li><p><a href="https://leetcode-cn.com/problems/rank-scores/submissions/" target="_blank" rel="noopener">178. 分数排名</a></p><ul><li><strong>窗口函数</strong>——<code>DENSE_RANK()</code></li><li>MySQL如果<strong>要 将保留字转义 用作列名</strong>，可以<strong>在关键字之前和之后使用撇号</strong>。例如<strong>`Rank`</strong></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/consecutive-numbers/solution/sql-server-jie-fa-by-neilsons/" target="_blank" rel="noopener">SQL SERVER 解法 - 连续出现的数字 - 力扣（LeetCode）</a></p></li><li><p>※<a href="https://leetcode-cn.com/problems/consecutive-numbers/" target="_blank" rel="noopener">180. 连续出现的数字</a></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">Num</span> <span class="keyword">AS</span> ConsecutiveNums</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">Num</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_cnt </span><br><span class="line">      <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">num</span>, </span><br><span class="line">            (ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>) - ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">num</span> </span><br><span class="line">                                                               <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>)) <span class="keyword">AS</span> orde</span><br><span class="line">           <span class="keyword">FROM</span> <span class="keyword">logs</span>) <span class="keyword">AS</span> W</span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">num</span>, orde) <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> num_cnt &gt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">181. 超过经理收入的员工</a></p></li><li><p><a href="https://leetcode-cn.com/problems/customers-who-never-order/submissions/" target="_blank" rel="noopener">183. 从不订购的客户</a></p><ul><li><strong>空值的筛选</strong>为<code>IS NULL</code>/<code>IS NOT NULL</code>，不是<code>= NULL</code></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/department-highest-salary/submissions/" target="_blank" rel="noopener">184. 部门工资最高的员工</a></p><ul><li><strong>每个组内比较</strong>，使用<strong>子查询</strong></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/delete-duplicate-emails/" target="_blank" rel="noopener">196. 删除重复的电子邮箱 </a></p><ul><li>子查询</li><li>EXISTS 和 IN的运用(<strong>EXISTS 更高效</strong>)</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/rising-temperature/" target="_blank" rel="noopener">197. 上升的温度</a></p><ul><li>时间处理函数<code>DATE_ADD()</code></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/trips-and-users/submissions/" target="_blank" rel="noopener">262. 行程和用户</a></p><ul><li><code>BETWEEN ... AND ...</code></li><li>IF表达式</li><li>ROUND函数<strong>舍入小数</strong></li><li><code>COUNT</code>函数/<code>AVG</code>函数</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/big-countries/" target="_blank" rel="noopener">595. 大的国家</a></p><ul><li>UNION和OR的选择</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/swap-salary/" target="_blank" rel="noopener">627. 交换工资</a></p><ul><li><code>CASE... WHEN</code></li></ul></li></ul><hr><h2 id="牛客网上的SQL题"><a href="#牛客网上的SQL题" class="headerlink" title="牛客网上的SQL题"></a>牛客网上的SQL题</h2><ul><li><p><a href="https://www.nowcoder.com/practice/c1472daba75d4635b7f8540b837cc719?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">获取当前薪水第二多的员工的emp_no以及其对应的薪水salary</a></p></li><li><p>不让使用ORDER BY排序时，<strong>利用子查询</strong>和<code>MAX()</code></p></li><li><p>⭐<a href="https://www.nowcoder.com/practice/fc7344ece7294b9e98401826b94c6ea5?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">查找所有员工自入职以来的薪水涨幅情况</a></p><ul><li>嵌套查询</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">对所有员工的薪水按照salary进行按照1-N的排名</a></p><ul><li>窗口函数</li><li><strong>排序细节</strong></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/8fe212a6c71b42de9c15c56ce354bebe?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">获取所有非manager员工当前的薪水情况</a></p><ul><li>使用INNER JOIN而不是LEFT JOIN</li><li>一个部门里可能有多个manager，所以用<code>NOT IN</code>比用<code>!=</code>更合理</li></ul></li><li><p>⭐<a href="https://www.nowcoder.com/practice/f858d74a030e48da8e0f69e21be63bef?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">获取员工其当前的薪水比其manager当前薪水还高的相关信息</a></p><ul><li><strong>创建两张表（一张记录当前所有员工的工资，另一张只记录部门经理的工资）进行比较</strong></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/eb9b13e5257744db8265aa73de04fd44?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">给出每个员工每年薪水涨幅超过5000的员工编号emp_no</a></p><ul><li>题意模糊：应该为<strong>给出薪水与去年相比丈夫超过5000的员工编号</strong></li><li>使用INNER JOIN而不是LEFT JOIN</li><li><strong>时间线的判断方法很有参考价值</strong></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/3a303a39cc40489b99a7e1867e6507c5?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">查找描述信息中包含robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量&gt;=5部</a></p><ul><li><strong>筛选方法</strong></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/ac233de508ef4849b0eeb4f38dcf09cf?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">创建一个actor表，包含如下列信息</a></p><ul><li>创建表的时候，有些地方必须<strong>加括号</strong></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/153c8a8e7805400ba8e384e03acc6b3e?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">批量插入数据，不使用replace操作</a></p><ul><li>MySQL插入数据，如果数据已存在则忽略的语句是<code>INSERT IGNORE table_name VALUES(...);</code></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/e1824daa0c49404aa602cf0cb34bdd75?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">对first_name创建唯一索引uniq_idx_firstname</a></p><ul><li><strong>创建索引</strong></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/b9db784b5e3d488cbd30bd78fdb2a862?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">针对actor表创建视图actor_name_view</a></p><ul><li>创建视图</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/f9fa9dc1a1fc4130b08e26c22c7a1e5f?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">针对上面的salaries表emp_no字段创建索引idx_emp_no</a></p><ul><li>强制索引(MySQL 为 <strong>FORCE INDEX</strong>)</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/7e920bb2e1e74c4e83750f5c16033e2e?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatu=0&amp;rp=1" target="_blank" rel="noopener">构造一个触发器audit_log</a></p><ul><li><strong>此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新的行数据还没有生成</strong>。<ul><li>通常，<strong>将BEFORE用于数据验证和净化</strong></li></ul></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/3d92551a6f6d4f1ebde272d20872cf05?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">删除emp_no重复的记录，只保留最小的id对应的记录</a></p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> xxx</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/859f28f43496404886a77600ea68ef59?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">将所有to_date为9999-01-01的全部更新为NULL</a></p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> xxx</span><br><span class="line"><span class="keyword">WHERE</span> xxx;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/2bec4d94f525458ca3d0ebf3bc8cd240?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005</a></p><ul><li><code>REPLACE(s, s1, s2)</code>函数</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/5277d7f92aa746ab8aa42886e5d570d4?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">将titles_test表名修改为titles_2017</a></p><ul><li>修改表名的两种方式<ul><li><code>RENAME TABLE table_name1 TO table_name2;</code></li><li><code>ALTER TABLE table_name1 RENAME TO table_name2;</code></li></ul></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/aeaa116185f24f209ca4fa40e226de48?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">在audit表上创建外键约束，其emp_no对应employees_test表的主键id</a></p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> fk_name] <span class="comment">-- CONSTRAINT fk_name 定义外键名，可不定义</span></span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (xx) <span class="keyword">REFERENCES</span> another_table (xx);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://www.nowcoder.com/practice/d3b058dcc94147e09352eb76f93b3274?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">将所有获取奖金的员工当前的薪水增加10%</a></p><ul><li>MySQL不支持<code>*=</code>这样的简化字符使用</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/c39cbfbd111a4d92b221acec1c7c1484?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=&amp;rp=1" target="_blank" rel="noopener">使用含有关键字exists查找未分配具体部门的员工的所有信息</a></p><ul><li>EXISTS和IN的选择</li><li>EXISTS的用法</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/5cdbf1dcbe8d4c689020b6b2743820bf?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">获取有奖金的员工相关信息</a></p><ul><li>CASE语句</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/58824cd644ea47d7b2b670c506a159a6?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">统计salary的累计和running_total</a></p><ul><li>窗口函数</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/e3cf1171f6cc426bac85fd4ffa786594?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">对于employees表中，给出奇数行的first_name</a></p><ul><li>窗口函数</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/cd2e10a588dc4c1db0407d0bf63394f3?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">刷题通过的题目排名</a></p><ul><li>窗口函数</li><li>排序</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/d6dd656483b545159d3aa89b4c26004e?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">异常的邮件概率</a></p><ul><li>COUNT函数非NULL的都会计数</li></ul></li><li><p><a href="https://www.nowcoder.com/practice/16d41af206cd4066a06a3a0aa585ad3d?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">牛客每个人最近的登录日期(三)</a></p><ul><li>在执行乘法<code>*</code>前，<strong>注意括号的使用</strong></li><li><code>WHERE XX IN XXX</code><strong>可以用于对一个组合的查询</strong></li></ul></li><li><p>⭐<a href="https://www.nowcoder.com/practice/e524dc7450234395aa21c75303a42b0a?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">牛客每个人最近的登录日期(四)</a></p><ul><li>解法一：LEFT JOIN + IFNULL函数<ul><li>笛卡尔积<strong>如果WHERE不满足，整个所生成的元组就不会显示</strong>，<strong>如果要显示的话,就必须使用JOIN连接</strong></li></ul></li><li>解法二：窗口函数 + SUM函数</li></ul></li><li><p>⭐⭐<a href="https://www.nowcoder.com/practice/ea0c56cd700344b590182aad03cc61b8?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">牛客每个人最近的登录日期(五)</a></p></li><li><p>⭐<a href="https://www.nowcoder.com/practice/572a027e52804c058e1f8b0c5e8a65b4?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">牛客每个人最近的登录日期(六)</a></p></li></ul><hr><h2 id="最近登陆时间，增量更新："><a href="#最近登陆时间，增量更新：" class="headerlink" title="最近登陆时间，增量更新："></a>最近登陆时间，增量更新：</h2><p>table_1是一个按天分区的 用户日志表，每次一个用户登陆都会新加一行：</p><p>day           timestamp             uid</p><p>2018-08-01     2018-08-01 11:00:00    1</p><p>2018-08-01     2018-08-01 14:00:00    1</p><p>需要根据table_1新建一个table_2:</p><p>Day           uid        latest_login_time</p><p>2018-08-01    1          2018-08-01 14:00:00 </p><p>每天新增一个昨日的分区的全量用户表，其中latest_login_time是自用户登录起最近一次登录的时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tabel2 (</span><br><span class="line">    <span class="keyword">day</span><span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    uid<span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`latest login time`</span> <span class="built_in">TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2(<span class="keyword">day</span>,</span><br><span class="line">                  uid,</span><br><span class="line">                  <span class="string">`latest login time`</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">day</span>, uid, <span class="keyword">MAX</span>(<span class="string">`timestamp`</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATEDIFF</span>(<span class="keyword">CURDATE</span>(), <span class="keyword">day</span>) = <span class="number">1</span> <span class="comment">-- 昨天</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> uid;</span><br></pre></td></tr></table></figure><hr><h2 id="累计用户数计算"><a href="#累计用户数计算" class="headerlink" title="累计用户数计算"></a>累计用户数计算</h2><p>table a是一个用户<strong>注册时间</strong>的记录表,一个用户只有一条数据，a表如下：</p><p>create_time                      uid </p><p>2018-08-01 14:07:09     111</p><p>2018-08-02 14:07:09     134</p><p>需要计算<strong>8月份累计注册用户数</strong>(从8月1日开始累计计算，8月1日为8月1日注册用户数，8月2日为8月1日-2日两天的注册用户数），计算结果格式如下：</p><p>时间 累计用户数</p><p>2018-08-01     2000000</p><p>2018-08-02     2100000</p><p>…………….</p><p>2018-08-31 10000000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DATE</span>(create_time) <span class="keyword">AS</span> 时间, </span><br><span class="line"><span class="keyword">COUNT</span>(uid) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> creat_time) <span class="keyword">AS</span> 累计用户数</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`table a`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(create_time) = <span class="number">2018</span> <span class="keyword">AND</span> <span class="keyword">MONTH</span>(create_time) = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="连续访问天数"><a href="#连续访问天数" class="headerlink" title="连续访问天数"></a>连续访问天数</h2><p>table a 是一个用户登陆时间记录表，每登陆一次会记录一条记录，a表如下：</p><p>log_time                             uid</p><p>2018-07-01 12:00:00     123</p><p>2018-07-01 13:00:00     123</p><p>2018-07-02 14:08:09     456</p><p>需要计算出7月1日登陆的用户，在后续连续登陆7天，14天，30天的人数</p><p>计算结果格式如下：</p><p>7月1日登陆总用户数 连续登陆7天用户数 连续登陆14天用户数 。。。。</p><p>1000 500 200</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(table_a.uid) <span class="keyword">AS</span> <span class="string">'7月1日登录总用户数'</span>, <span class="keyword">COUNT</span>(table_b.uid) <span class="keyword">AS</span> <span class="string">'连续登录7天的用户数'</span>, <span class="keyword">COUNT</span>(table_c.uid) <span class="keyword">AS</span> <span class="string">'连续登录14天的用户数'</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> uid</span><br><span class="line"><span class="keyword">FROM</span> consecutive_task</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">DATE</span>(login_time) = <span class="string">'2018-07-01'</span>) table_a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> uid, (login_date - rank_num) <span class="keyword">AS</span> rnk</span><br><span class="line">           <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> uid, login_date, (ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid</span><br><span class="line">                                                             <span class="keyword">ORDER</span> <span class="keyword">BY</span> login_date)) <span class="keyword">AS</span> rank_num</span><br><span class="line">                 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> uid, <span class="built_in">DATE</span>(login_time) <span class="keyword">AS</span> login_date</span><br><span class="line">                       <span class="keyword">FROM</span> consecutive_task</span><br><span class="line">                       <span class="keyword">WHERE</span> <span class="built_in">DATE</span>(login_time) <span class="keyword">BETWEEN</span> <span class="string">'2018-07-01'</span> <span class="keyword">AND</span> <span class="string">'2018-07-07'</span></span><br><span class="line">                       <span class="keyword">GROUP</span> <span class="keyword">BY</span> uid, login_date) b1 ) b2</span><br><span class="line">           <span class="keyword">GROUP</span> <span class="keyword">BY</span> uid, rnk</span><br><span class="line">           <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(rnk) = <span class="number">7</span>) table_b</span><br><span class="line"><span class="keyword">ON</span> table_a.uid = table_b.uid</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> uid, (login_date - rank_num) <span class="keyword">AS</span> rnk</span><br><span class="line">           <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> uid, login_date, (ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid</span><br><span class="line">                                                             <span class="keyword">ORDER</span> <span class="keyword">BY</span> login_date)) <span class="keyword">AS</span> rank_num</span><br><span class="line">                 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> uid, <span class="built_in">DATE</span>(login_time) <span class="keyword">AS</span> login_date</span><br><span class="line">                       <span class="keyword">FROM</span> consecutive_task</span><br><span class="line">                       <span class="keyword">WHERE</span> <span class="built_in">DATE</span>(login_time) <span class="keyword">BETWEEN</span> <span class="string">'2018-07-01'</span> <span class="keyword">AND</span> <span class="string">'2020-07-14'</span></span><br><span class="line">                       <span class="keyword">GROUP</span> <span class="keyword">BY</span> uid, login_date) c1 ) c2</span><br><span class="line">           <span class="keyword">GROUP</span> <span class="keyword">BY</span> uid, rnk</span><br><span class="line">           <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(rnk) = <span class="number">14</span>) table_c</span><br><span class="line"><span class="keyword">ON</span> table_a.uid = table_c.uid;</span><br></pre></td></tr></table></figure><hr><h2 id="新增用户的近7日留存率"><a href="#新增用户的近7日留存率" class="headerlink" title="新增用户的近7日留存率"></a>新增用户的近7日留存率</h2><p>table1：用户新增表，一个设备首次激活都新加一行：</p><p>timestamp，device 【新增的日期，新增的设备】</p><p>table2: 是一个<strong>按天分区</strong>的用户活跃表，每次一个用户登陆都会新加一行：</p><p>day，device 【活跃的日期，活跃的设备】</p><p>需要计算用户新增用户的留存数，留存率【1-7日】</p><p>计算结果格式如下：</p><p>新增日期     新增设备数     次日留存数     次日留存率     2日留存数     2日留存率 ….</p><p>timestamp     1000                 500                     50%                 450                 45%</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.first <span class="keyword">AS</span> 新增日期, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> a.device) <span class="keyword">AS</span> 新增设备数, </span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">first</span> - b.day = <span class="number">1</span>, a.device, <span class="literal">NULL</span>)) <span class="keyword">AS</span> 次日留存数, </span><br><span class="line">            <span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">first</span> - b.day = <span class="number">1</span>, a.device, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> a.device) * <span class="number">100</span>, <span class="number">0</span>), <span class="string">'%'</span>) <span class="keyword">AS</span> 次日留存率 </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> a.device, <span class="built_in">DATE</span>(a.timestamp) <span class="keyword">AS</span> <span class="keyword">first</span>, b.day </span><br><span class="line">      <span class="keyword">FROM</span> table1 a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 b </span><br><span class="line">      <span class="keyword">ON</span> a.device = b.device) c</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> a.first; <span class="comment">-- 按 新增用户的日期 分组</span></span><br></pre></td></tr></table></figure><hr><h2 id="计算日活用户签到，开宝箱，阅读行为的用户各自占比"><a href="#计算日活用户签到，开宝箱，阅读行为的用户各自占比" class="headerlink" title="计算日活用户签到，开宝箱，阅读行为的用户各自占比"></a>计算日活用户签到，开宝箱，阅读行为的用户各自占比</h2><p>table1: 是一个按天分区的<strong>用户活跃表</strong>，每次一个用户<strong>登陆</strong>都会新加一行：</p><p>day，uid 【活跃的日期，活跃的用户id】 </p><p>table2：是一个按天分区的<strong>用户行为表</strong>，每一种<strong>行为</strong>都会新加一行：</p><p>day ,uid,type 【日期，用户id，type类型：1表示签到，2表示开宝箱，3表示阅读】 </p><p>需要计算，<strong>签到占日活的比例</strong>，开宝箱占日活的比例，阅读占日活的比例</p><p>计算结果格式如下：</p><p>日期        活跃用户数        签到占日活的比例        开宝箱占日活的比例        阅读占日活的比例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">day</span> <span class="keyword">AS</span> 日期, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> uid) <span class="keyword">AS</span> 活跃用户数, </span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">IF</span>(<span class="keyword">type</span> = <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(uid) <span class="keyword">AS</span> 签到占日活的比例,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">IF</span>(<span class="keyword">type</span> = <span class="number">2</span>, <span class="number">1</span>, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(uid) <span class="keyword">AS</span> 开宝箱占日活的比例,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">IF</span>(<span class="keyword">type</span> = <span class="number">3</span>, <span class="number">1</span>, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(uid) <span class="keyword">AS</span> 阅读占日活的比例</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> a.*, b.type </span><br><span class="line">      <span class="keyword">FROM</span> table_1 <span class="keyword">AS</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_2 <span class="keyword">AS</span> b </span><br><span class="line">      <span class="keyword">ON</span> a.uid = b.uid <span class="keyword">AND</span> a.day = b.day) c</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h2><h3 id="准备数据-3"><a href="#准备数据-3" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee </span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">salary <span class="built_in">INT</span>(<span class="number">20</span>),</span><br><span class="line">departmentid <span class="built_in">INT</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">"Joe"</span>,<span class="number">70000</span>,<span class="number">1</span>), </span><br><span class="line">(<span class="number">2</span>,<span class="string">"Henry"</span>,<span class="number">80000</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">"Sam"</span>,<span class="number">60000</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">"Max"</span>,<span class="number">90000</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Department </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Department </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">"IT"</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">"Sales"</span>);</span><br></pre></td></tr></table></figure><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><p>找出每个部门工资最高的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.name Department, e.name Employee, <span class="keyword">MAX</span>(Salary) Salary</span><br><span class="line"><span class="keyword">FROM</span> Employee e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Department d</span><br><span class="line"><span class="keyword">ON</span> e.departmentid = d.id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.id;</span><br></pre></td></tr></table></figure><hr><h3 id="准备数据-4"><a href="#准备数据-4" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">Id</span> <span class="built_in">INT</span>(<span class="number">10</span>),</span><br><span class="line">Email <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customer</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'a@b.com'</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">'c@d.com'</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">'a@b.com'</span>);</span><br></pre></td></tr></table></figure><h3 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h3><p>查找 customer 表中所有重复的电子邮箱</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Email</span><br><span class="line"><span class="keyword">FROM</span> customer</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Email</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(Email)&gt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="准备数据-5"><a href="#准备数据-5" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers</span><br><span class="line">( </span><br><span class="line">    <span class="keyword">Id</span> <span class="built_in">INT</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">Name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'Joe'</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">'Henry'</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">'Sam'</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">'Max'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line"><span class="keyword">Id</span> <span class="built_in">INT</span>(<span class="number">10</span>),</span><br><span class="line">CustomerId <span class="built_in">INT</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>练习题：找出所有<strong>从不订购任何东西</strong>的客户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">AS</span> customers</span><br><span class="line"><span class="keyword">FROM</span> customers c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders o</span><br><span class="line"><span class="keyword">ON</span> c.id = o.customerId</span><br><span class="line"><span class="keyword">WHERE</span> o.id <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">AS</span> customers</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> customerid</span><br><span class="line"><span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure><hr><h3 id="准备数据-6"><a href="#准备数据-6" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Scores</span><br><span class="line">( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>), </span><br><span class="line">    score <span class="built_in">FLOAT</span>(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> scores </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">3.5</span>), </span><br><span class="line">(<span class="number">2</span>,<span class="number">3.65</span>), </span><br><span class="line">(<span class="number">3</span>,<span class="number">4.00</span>), </span><br><span class="line">(<span class="number">4</span>,<span class="number">3.85</span>), </span><br><span class="line">(<span class="number">5</span>,<span class="number">4.00</span>),</span><br><span class="line">(<span class="number">6</span>,<span class="number">3.65</span>);</span><br></pre></td></tr></table></figure><p>练习题：通过查询实现分数排名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口函数 ROW_NUMBER()</span></span><br><span class="line"><span class="keyword">SELECT</span> score, ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> <span class="string">`Rank`</span></span><br><span class="line"><span class="keyword">FROM</span> scores</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ROW_NUMBER() 对应 使用变量 的做法</span></span><br><span class="line"><span class="keyword">SELECT</span> score, @curRank=@curRank+<span class="number">1</span> <span class="keyword">AS</span> <span class="string">`Rank`</span></span><br><span class="line"><span class="keyword">FROM</span> scores, (<span class="keyword">SELECT</span> @<span class="keyword">RANK</span>:=<span class="number">0</span>) r</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- RANK() (有并列名次的行，会占用下一名次的位置)对应使用变量的做法</span></span><br><span class="line"><span class="keyword">SELECT</span> score, <span class="string">`rank`</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> score, @curRank = <span class="keyword">IF</span>(@preScore = score, @curRank, @incRank) <span class="keyword">AS</span> <span class="string">`rank`</span>, <span class="comment">-- 同分同排名，不同分下一排名</span></span><br><span class="line">                @incRank:=@incRank+<span class="number">1</span>; <span class="comment">-- 作用等同于 ROW_NUMBER()</span></span><br><span class="line">                @preScore:=score</span><br><span class="line">      FROM scores, (<span class="keyword">SELECT</span> @curRank:=<span class="number">0</span>, @preScore:=<span class="literal">NULL</span>, @incRank:=<span class="number">1</span>) r</span><br><span class="line">      <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) s;</span><br><span class="line">      </span><br><span class="line"><span class="comment">-- DENSE_RANK() 对应使用变量的做法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> score, <span class="string">`rank`</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> score, @curRank=<span class="keyword">IF</span>(@preScore=score, @curRank, @curRank+<span class="number">1</span>) <span class="keyword">AS</span> <span class="string">`rank`</span>,</span><br><span class="line">@preScore=score</span><br><span class="line">  <span class="keyword">FROM</span> scores, (<span class="keyword">SELECT</span> @curRank:=<span class="number">0</span>, @preScore:=<span class="literal">NULL</span>) r</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> socre <span class="keyword">DESC</span>) s;</span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 使用CASE WHEN更简洁</span></span><br><span class="line"><span class="keyword">SELECT</span> score, <span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> score=@preScore <span class="keyword">THEN</span> @curRank</span><br><span class="line">                <span class="keyword">WHEN</span> @preScore:=score <span class="keyword">THEN</span> @curRank:=@curRank+<span class="number">1</span> <span class="comment">-- @preScore:=score 赋值语句必为true</span></span><br><span class="line">              <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">`rank`</span></span><br><span class="line"><span class="keyword">FROM</span> scores, (<span class="keyword">SELECT</span> @curRank:=<span class="number">0</span>, @preScore:=<span class="literal">NULL</span>) r</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="准备数据-7"><a href="#准备数据-7" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seat </span><br><span class="line">( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">20</span>),</span><br><span class="line">student <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seat </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'Abbot'</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">'Doris'</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">'Emerson'</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">'Green'</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="string">'Jeames'</span>);</span><br></pre></td></tr></table></figure><p>练习题：座位id 是连续递增的，改变相邻俩学生的座位。<br> <strong>要求:</strong></p><ul><li><strong>如果学生人数是奇数，则不需要改变最后一个同学的座位。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">CASE</span></span><br><span class="line">            <span class="keyword">WHEN</span> <span class="keyword">id</span> % <span class="number">2</span> = <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">id</span> != cnt <span class="keyword">THEN</span> <span class="keyword">id</span>+<span class="number">1</span> <span class="comment">-- 奇数且不是最后一个</span></span><br><span class="line">            <span class="keyword">WHEN</span> <span class="keyword">id</span> % <span class="number">2</span> = <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">id</span> = cnt <span class="keyword">THEN</span> <span class="keyword">id</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="keyword">id</span> - <span class="number">1</span> <span class="comment">-- 偶数</span></span><br><span class="line">        <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="keyword">id</span>, student</span><br><span class="line"><span class="keyword">FROM</span> seat, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt <span class="comment">-- 用于判断当前是否是最后一个学生(奇数的特殊判断)</span></span><br><span class="line">            <span class="keyword">FROM</span> seat) t</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="准备数据-8"><a href="#准备数据-8" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> Employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">( </span><br><span class="line"><span class="keyword">Id</span> <span class="built_in">INT</span>(<span class="number">10</span>), </span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">Salary <span class="built_in">INT</span>(<span class="number">20</span>), </span><br><span class="line">ManagerId <span class="built_in">INT</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'Joe'</span>, <span class="number">70000</span>, <span class="number">3</span>), </span><br><span class="line">(<span class="number">2</span>, <span class="string">'Henry'</span>, <span class="number">80000</span>, <span class="number">4</span>), </span><br><span class="line">(<span class="number">3</span>, <span class="string">'Sam'</span>, <span class="number">60000</span>, <span class="literal">NULL</span>), </span><br><span class="line">(<span class="number">4</span>, <span class="string">'Max'</span>, <span class="number">90000</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>练习题：编写一个 SQL 查询，获取收入超过他们经理的员工的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.Name</span><br><span class="line"><span class="keyword">FROM</span> Employee e1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Employee e2</span><br><span class="line"><span class="keyword">ON</span> e1.ManagerId = e2.Id</span><br><span class="line"><span class="keyword">WHERE</span> e1.Salary &gt; e2.Salary;</span><br></pre></td></tr></table></figure><hr><h2 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h2><p><strong>题目:</strong>X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)。<br> 请编写一个查询语句，找出<strong>人流量的高峰期</strong>。<br> <strong>要求:</strong></p><ul><li>高峰期时，<strong>至少连续三行</strong>记录中的<strong>人流量不少于100</strong></li><li><strong>每天只有一行记录</strong>，日期随着 id 的增加而增加</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stadium </span><br><span class="line">( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">20</span>), </span><br><span class="line">visit_date <span class="built_in">DATE</span>, </span><br><span class="line">people <span class="built_in">INT</span>(<span class="number">20</span>)</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stadium </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2017-01-01'</span>,<span class="number">10</span>), </span><br><span class="line">(<span class="number">2</span>,<span class="string">'2017-01-02'</span>,<span class="number">109</span>), </span><br><span class="line">(<span class="number">3</span>,<span class="string">'2017-01-03'</span>,<span class="number">150</span>), </span><br><span class="line">(<span class="number">4</span>,<span class="string">'2017-01-04'</span>,<span class="number">99</span>), </span><br><span class="line">(<span class="number">5</span>,<span class="string">'2017-01-05'</span>,<span class="number">145</span>), </span><br><span class="line">(<span class="number">6</span>,<span class="string">'2017-01-06'</span>,<span class="number">1455</span>), </span><br><span class="line">(<span class="number">7</span>,<span class="string">'2017-01-07'</span>,<span class="number">199</span>), </span><br><span class="line">(<span class="number">8</span>,<span class="string">'2017-01-08'</span>,<span class="number">188</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法一：朴实的自联结</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> t1.*</span><br><span class="line"><span class="keyword">FROM</span> stadium t1, stadium t2, stadium t3</span><br><span class="line"><span class="keyword">WHERE</span> (t1.people &gt;= <span class="number">100</span>     <span class="comment">-- 筛选表中 人流量&gt;=100 的行</span></span><br><span class="line"><span class="keyword">AND</span> t2.people &gt;= <span class="number">100</span></span><br><span class="line"><span class="keyword">AND</span> t3.people &gt;= <span class="number">100</span></span><br><span class="line"><span class="keyword">AND</span> ( (t1.id - t2.id = <span class="number">1</span> <span class="comment">-- 错位联结，从t1的id开始连续3天有人流高峰</span></span><br><span class="line"> <span class="keyword">AND</span> t1.id - t3.id = <span class="number">2</span></span><br><span class="line">  <span class="keyword">AND</span> t2.id - t3.id = <span class="number">1</span></span><br><span class="line">                ) </span><br><span class="line">             <span class="keyword">OR</span> (t2.id - t1.id = <span class="number">1</span> <span class="comment">-- 补充 t1之后只有1天人流高峰，但之前也有连续高峰 的情况</span></span><br><span class="line"> <span class="keyword">AND</span> t2.id - t3.id = <span class="number">2</span></span><br><span class="line"> <span class="keyword">AND</span> t1.id - t3.id = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">OR</span> (t3.id - t2.id = <span class="number">1</span> <span class="comment">-- 补充t1为人流高峰最后一天 的情况</span></span><br><span class="line"> <span class="keyword">AND</span> t2.id - t1.id = <span class="number">1</span></span><br><span class="line"> <span class="keyword">AND</span> t3.id - t1.id = <span class="number">2</span>) </span><br><span class="line">             )</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.id; </span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line"><span class="comment">-- 方法二：MySQL 8.0 之后开始支持 WITH AS 语句(子查询部分，作用类似于一个视图，但with as 属于一次性的，而且必须和其他sql一起使用才行) WITH子句的查询必须用括号括起来</span></span><br><span class="line"><span class="keyword">WITH</span> t1 <span class="keyword">AS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">id</span>, visit_date, people,</span><br><span class="line">        (<span class="keyword">id</span> - ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>)) rk</span><br><span class="line"><span class="keyword">FROM</span> stadium</span><br><span class="line"><span class="keyword">WHERE</span> people &gt;= <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, visit_date, people</span><br><span class="line"><span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> rk <span class="keyword">IN</span> (<span class="keyword">SELECT</span> rk </span><br><span class="line">            <span class="keyword">FROM</span> t1</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> rk</span><br><span class="line">            <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="挑战题"><a href="#挑战题" class="headerlink" title="挑战题"></a>挑战题</h3><p><img src="https://i.loli.net/2020/09/13/2pa43QDgf8wzReU.png" alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 日期, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> a.uid) 活跃用户数, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">day</span>-<span class="keyword">first</span>=<span class="number">1</span>, a.uid, <span class="literal">NULL</span>)) 次日留存用户数,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">day</span>-<span class="keyword">first</span>=<span class="number">3</span>), a.uid, <span class="literal">NULL</span>) 三日留存用户数,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">day</span>-<span class="keyword">first</span>=<span class="number">7</span>), a.uid, <span class="literal">NULL</span>) 七日留存用户数,</span><br><span class="line"><span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">day</span>-<span class="keyword">first</span>=<span class="number">1</span>, a.uid, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> a.uid), <span class="number">2</span>), <span class="string">'%'</span>) 次日留存率, <span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">day</span>-<span class="keyword">first</span>=<span class="number">3</span>, a.uid, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> a.uid), <span class="number">2</span>), <span class="string">'%'</span>) 三日留存率, <span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">day</span>-<span class="keyword">first</span>=<span class="number">7</span>, a.uid, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> a.uid), <span class="number">2</span>), <span class="string">'%'</span>) 七日留存率</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> uid, <span class="keyword">DATE_FORMAT</span>(dayno, <span class="string">'%Y-%m-%d'</span>) <span class="keyword">AS</span> <span class="keyword">first</span></span><br><span class="line">      <span class="keyword">FROM</span> act_user_info</span><br><span class="line">      <span class="keyword">WHERE</span> app_name = <span class="string">'相机'</span>) a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> uid, <span class="keyword">DATE_FORMAT</span>(dayno, <span class="string">'%Y-%m-%d'</span>) <span class="keyword">AS</span> <span class="keyword">day</span></span><br><span class="line">                                           <span class="keyword">FROM</span> act_user_info</span><br><span class="line">                                           <span class="keyword">WHERE</span> app_name = <span class="string">'相机'</span>) b</span><br><span class="line"><span class="keyword">ON</span> a.uid = b.uid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">first</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="PDD笔试题"><a href="#PDD笔试题" class="headerlink" title="PDD笔试题"></a>PDD笔试题</h2><h3 id="2-用户行为分析"><a href="#2-用户行为分析" class="headerlink" title="2. 用户行为分析"></a>2. 用户行为分析</h3><p>表1——用户行为表tracking_log，大概字段有（user_id‘用户编号’,opr_id‘操作编号’,log_time‘操作时间’）</p><ul><li>统计<strong>每天</strong>符合以下条件的<strong>用户数</strong>：<strong>A操作之后是B操作</strong>，AB操作必须相连</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用窗口函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DATE</span>(log_time), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> user_id)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="built_in">DATE</span>(log_time), user_id, opr_id,</span><br><span class="line">     <span class="keyword">LEAD</span>(opr_id, <span class="number">1</span>) <span class="keyword">OVER</span>() <span class="keyword">AS</span> pre_opr</span><br><span class="line">     <span class="keyword">FROM</span> tracking_log) table_1</span><br><span class="line"><span class="keyword">WHERE</span> opr_id=<span class="string">'A'</span> <span class="keyword">AND</span> pre_opr=<span class="string">'B'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">DATE</span>(log_time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用用户变量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DATE</span>(log_time), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> user_id)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="built_in">DATE</span>(log_time), user_id,</span><br><span class="line">     (<span class="keyword">CASE</span></span><br><span class="line">     <span class="keyword">WHEN</span> @pre_opr=<span class="string">'A'</span> <span class="keyword">AND</span> opr_id=<span class="string">'B'</span> <span class="keyword">THEN</span> @isJoin:=<span class="literal">True</span> <span class="keyword">AND</span> @pre_opr:=opr_id</span><br><span class="line">      <span class="keyword">ELSE</span> @pre_opr:=opr_id</span><br><span class="line">      <span class="keyword">END</span>) isJoin</span><br><span class="line">      <span class="keyword">FROM</span> tracking_log, (<span class="keyword">SELECT</span> @pre_opr:=<span class="literal">NULL</span>, @isJoin:=<span class="literal">FALSE</span>) a) table_1</span><br><span class="line"><span class="keyword">WHERE</span> isJoin=<span class="literal">True</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">DATE</span>(log_time);</span><br></pre></td></tr></table></figure><hr><h3 id="3-用户新增留存分析"><a href="#3-用户新增留存分析" class="headerlink" title="3. 用户新增留存分析"></a>3. 用户新增留存分析</h3><p>表1——用户登陆表user_log，大概字段有（user_id‘用户编号’，log_time‘登陆时间’）</p><ul><li>获取每日新增用户数，以及第2天、第30天的回访比例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(user_id) 新增用户数, </span><br><span class="line">(<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">DATEDIFF</span>(<span class="built_in">DATE</span>(log_time), 注册日期)=<span class="number">1</span>, u1.user_id, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(user_id)) <span class="keyword">AS</span> 第<span class="number">2</span>天回访比例, </span><br><span class="line">(<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">IF</span>(<span class="keyword">DATEDIFF</span>(<span class="built_in">DATE</span>(log_time), 注册日期)=<span class="number">29</span>, u1.user_id, <span class="literal">NULL</span>)) / <span class="keyword">COUNT</span>(user_id)) <span class="keyword">AS</span> 第<span class="number">30</span>天回访比例</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> user_id, <span class="built_in">DATE</span>(<span class="keyword">MIN</span>(log_time)) <span class="keyword">AS</span> 注册日期</span><br><span class="line">      <span class="keyword">FROM</span> user_log</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id) u1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_log u2</span><br><span class="line"><span class="keyword">ON</span> u1.user_id = u2.user_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 注册日期;</span><br></pre></td></tr></table></figure><h3 id="4-贝叶斯公式的应用"><a href="#4-贝叶斯公式的应用" class="headerlink" title="4. 贝叶斯公式的应用"></a>4. 贝叶斯公式的应用</h3><p><a href="https://zhuanlan.zhihu.com/p/80835787" target="_blank" rel="noopener">数据分析笔试题(1) - 知乎</a></p><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Partition_date, </span><br><span class="line">(<span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">DATEDIFF</span>(t2.Partition_date, t1.Partition_date)=<span class="number">1</span> <span class="keyword">THEN</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> t1.user_id) </span><br><span class="line"><span class="keyword">END</span>) <span class="keyword">AS</span> <span class="string">'流失1天'</span>,</span><br><span class="line">(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="keyword">DATEDIFF</span>(t2.Partition_date, t1.Partition_date)=<span class="number">2</span> <span class="keyword">THEN</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> t1.user_id) </span><br><span class="line">        <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="string">'流失2天'</span>,</span><br><span class="line">(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="keyword">DATEDIFF</span>(t2.Partition_date, t1.Partition_date)=<span class="number">3</span> <span class="keyword">THEN</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> t1.user_id) </span><br><span class="line">        <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="string">'流失3天'</span>,</span><br><span class="line">(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="keyword">DATEDIFF</span>(t2.Partition_date, t1.Partition_date)&gt;=<span class="number">30</span> <span class="keyword">THEN</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> t1.user_id) </span><br><span class="line">        <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="string">'流失30天以上'</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> user_id, Partition_date</span><br><span class="line">      <span class="keyword">FROM</span> user_active</span><br><span class="line">      <span class="keyword">WHERE</span> daily_active_status_map=<span class="number">1</span>) t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> user_id, Partition_date</span><br><span class="line">                                                     <span class="keyword">FROM</span> usre_active</span><br><span class="line">                                                     <span class="keyword">WHERE</span> daily_active_status_map=<span class="number">1</span>) t2</span><br><span class="line"><span class="keyword">ON</span> t1.user_id=t2.user_id</span><br><span class="line"><span class="keyword">WHERE</span> t2.user_id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Partition_date</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Partition_date <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL报错的分类与解决方法</title>
      <link href="/2020/06/16/MySQL%E6%8A%A5%E9%94%99%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/16/MySQL%E6%8A%A5%E9%94%99%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="无法插入中文字符"><a href="#无法插入中文字符" class="headerlink" title="无法插入中文字符"></a>无法插入中文字符</h2><ul><li><p>报错内容：</p><blockquote><p>1366 - Incorrect string value: ‘\xE6\x9B\xBE\xE5\x8D\x8E’ for column ‘sname’ at row 1</p></blockquote></li><li><p>原因</p><p>MySQL默认配置：</p><p>| variable_name          | value      |<br>| ———————- | ———- |<br>| character_set_database | <strong>latin1</strong> |<br>| character_set_server   | <strong>latin1</strong> |</p><p>可通过<code>SHOW VARIABLES LIKE &#39;%char%&#39;;</code>查看。</p></li><li><p>解决方法</p><ol><li><p>修改<code>C:\ProgramData\MySQL\MySQL Server 5.7\my.ini</code>：</p><ul><li><p>找到<code>[mysql]</code></p><p>在下方添加<code>default-character-set=utf8</code></p></li><li><p>找到<code>[mysqld]</code></p><p>在下方添加<code>character-set-server=utf8</code></p></li><li><p>找到<code>[client]</code></p><p>在下方添加<code>default-character-set=utf8</code></p></li></ul></li><li><p>重启MySQL，重新登录</p><ul><li><p><code>Win</code> + <code>R</code> - services.msc</p></li><li><p>找到<strong>MySQL</strong>57(57为版本号)，右键选择重新启动</p></li><li><p><code>Win</code> + <code>R</code> - cmd（或cmder）</p><p>通过<code>mysql -u -root -p</code>命令并输入密码后访问数据库。</p></li><li><p>通过<code>SHOW VARIABLES LIKE &#39;%char%&#39;;</code>查看，字符集变为utf8即成功修改。</p></li></ul></li></ol></li></ul><hr><h2 id="Navicat连接数据库报错"><a href="#Navicat连接数据库报错" class="headerlink" title="Navicat连接数据库报错"></a>Navicat连接数据库报错</h2><ul><li><p>报错内容：</p><blockquote><p>2059 - Authentication plugin ‘caching_sha2_password’ cannot be loaded</p></blockquote></li><li><p>原因：</p><p>  MySQL<strong>8之前</strong>的版本中加密规则为<strong>mysql_native_password</strong>，而在MySQL<strong>8以后</strong>的加密规则为<strong>caching_sha2_password</strong>。</p></li><li><p>解决方法：</p><p>  在命令行中<strong>登录MySQL后</strong>，使用命令行：</p><p>  <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL必知必会</title>
      <link href="/2020/06/14/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2020/06/14/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-了解SQL"><a href="#第1章-了解SQL" class="headerlink" title="第1章 了解SQL"></a>第1章 了解SQL</h2><ul><li><p>数据库软件应称为DBMS（数据库管理系统）。</p></li><li><p>数据库是通过DBMS创建和操纵的容器。</p></li><li><p>在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。</p></li><li><p>模式（schema）： 关于<strong>数据库</strong>和<strong>表</strong>的<strong>布局及特性</strong>的信息。</p></li><li><p>有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。</p></li><li><p>主键（primary key）</p></li><li><p>SQL（发音为字母S-Q-L或sequel）是<strong>结构化查询语言（Structured Query Language）</strong>的缩写。</p></li></ul><h2 id="第2章-MySQL简介"><a href="#第2章-MySQL简介" class="headerlink" title="第2章 MySQL简介"></a>第2章 MySQL简介</h2><ul><li>DBMS可分为两类：一类为<strong>基于共享文件系统</strong>的DBMS，另一类为<strong>基于客户机——服务器</strong>的DBMS。前者（包括诸如<strong>Microsoft Access</strong>和<strong>FileMaker</strong>）用于<strong>桌面用途</strong>，通常不用于高端或更关键的应用。</li><li>MySQL、Oracle以及Microsoft SQL Server等数据库是基于客户机——服务器的数据库。客户机—服务器应用分为两个不同的部分。<strong>服务器</strong>部分是负责<strong>所有数据访问和处理</strong>的一个软件。</li><li>为进行所有数据库交互，客户机软件都要与服务器软件进行通信。</li><li>每个MySQL安装都有一个名为mysql的简单命令行实用程序。</li></ul><hr><h3 id="配置MySQL环境变量"><a href="#配置MySQL环境变量" class="headerlink" title="配置MySQL环境变量"></a>配置MySQL环境变量</h3><ul><li><code>Win</code> + <code>Pause Break</code> 打开<strong>系统</strong>窗口。</li><li>高级系统设置 - 高级 - 环境变量 - 系统变量</li><li>找到<strong>Path</strong>，点击<strong>编辑</strong> - 浏览</li><li>选择MySQL安装目录下的bin文件夹所在路径，默认路径为<code>C:\Program Files\MySQL\MySQL Server 5.7\bin</code></li><li>一路确定，即完成环境变量的配置。此时打开命令行窗口，即通过<code>mysql -u root -p</code>命令并输入密码后访问数据库。</li></ul><hr><h3 id="统一字符集为UTF-8"><a href="#统一字符集为UTF-8" class="headerlink" title="统一字符集为UTF-8"></a>统一字符集为UTF-8</h3><p>为了中文字符的顺利存储，需要将数据库的字符集统一为UTF-8。</p><p>修改<code>C:\ProgramData\MySQL\MySQL Server 5.7\my.ini</code>：</p><ul><li><p>找到<code>[mysql]</code></p><p>在下方添加<code>default-character-set=utf8</code></p></li><li><p>找到<code>[mysqld]</code></p><p>在下方添加<code>character-set-server=utf8</code></p></li><li><p>找到<code>[client]</code></p><p>在下方添加<code>default-character-set=utf8</code></p></li></ul><hr><ul><li>在操作系统命令提示符下输入mysql将出现一个如下的简单提示：<ul><li>为了指定<strong>用户登录名</strong>ben，应该使用<code>mysql -u ben</code>。为了给出<strong>用户名</strong>、<strong>主机名</strong>、<strong>端口</strong>和<strong>口令</strong>，应该使用<code>mysql -u ben -p -h myserver -P 9999</code>。<strong>完整的命令行选项和参数列表</strong>可用<code>mysql --help</code>获得。</li></ul></li><li>命令用<code>；</code>或<code>\g</code><strong>结束</strong>，换句话说，<strong>仅按Enter不执行命令</strong>；</li><li>输入<code>quit</code>或<code>exit</code><strong>退出命令行实用程序</strong>。</li></ul><h2 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h2><ul><li><p>在最初安装MySQL时，很可能会要求你输入一个管理登录（通常为root）和一个口令。如果你使用的是自己的本地服务器，并且是简单地试验一下MySQL，使用上述登录就可以了。但现实中，管理登录受到密切保护</p></li><li><p>在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作前，需要选择一个数据库。为此，可使用<strong>USE关键字</strong>。</p></li><li><p>决不要用<strong>关键字</strong>命名一个表或列。附录E列出了MySQL的关键字。</p></li><li><p><strong>USE语句</strong>并不返回任何结果。依赖于使用的客户机，显示某种形式的通知。例如，这里显示出的Database changed消息是mysql命令行实用程序在数据库选择成功后显示的。</p></li><li><p>双击Schemata列表中列出的任一数据库以使用它。你看不到USE命令的实际执行，但会看到被选择的数据库（黑体加亮），而且应用标题栏将显示所选择的数据库名。</p></li><li><p>必须先使用USE打开数据库，才能读取其中的数据。</p></li><li><p>数据库、表、列、用户、权限等的信息被存储在数据库和表中（MySQL使用MySQL来存储这些信息）</p></li><li><p>可用MySQL的<strong>SHOW命令</strong>来显示这些信息（MySQL从内部表中提取这些信息）</p><ul><li><p><code>SHOW DATABASES;</code></p><p>返回<strong>可用数据库</strong>的一个列表。包含在这个列表中的可能是MySQL内部使用的数据库</p></li><li><p><code>SHOW TABLES;</code></p><p>获得<strong>当前选择的数据库内可用表</strong></p></li><li><p><code>SHOW COLUMNS FROM xxx;</code></p><p>要求给出一个表名，<strong>显示对应的所有表列及其具体属性</strong></p><p><code>DESCRIBE customers;</code>是<code>SHOW COLUMNS FROM customers;</code>的一种<strong>快捷方式</strong>。</p></li><li><p><code>SHOW STATUS;</code></p><p>用于显示广泛的<strong>服务器状态</strong>信息</p></li><li><p><code>SHOW CREATE DATABASE;</code>和<code>SHOW CREATE TABLE;</code></p><p>分别用来显示<strong>创建特定数据库或表的MySQL语句</strong>。</p></li><li><p><code>SHOW GRANTS;</code></p><p>用来<strong>显示授予用户（所有用户或特定用户）的安全权限</strong>；</p></li><li><p><code>SHOW ERRORS;</code>和<code>SHOW WARNINGS;</code></p><p>用来<strong>显示服务器错误</strong>或<strong>警告消息</strong>。 </p></li><li><p><code>SHOW PROCESSLIST;</code></p><p>  显示<strong>所有活动进程</strong>(以及它们的线程ID和执行时间)</p></li></ul></li><li><p><strong>自动增量</strong>：</p><p>在<strong>每个行添加到表中</strong>时，MySQL可以<strong>自动地为每个行分配下一个可用编号</strong>，<strong>不用在添加一行时手动分配唯一值</strong>。如果需要它，则必须在<strong>用CREATE语句创建表时</strong>把它作为<strong>表定义的组成部分</strong>。</p></li></ul><blockquote><p>MySQL 5支持一个新的INFORMA-TION_SCHEMA命令，可用它来获得和过滤模式信息。</p></blockquote><ul><li>MySQL用<code>#</code>标记<strong>注释</strong></li></ul><h2 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h2><blockquote><p>。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名</p></blockquote><blockquote><p>如果没有明确排序查询结果（下一章介绍），则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。</p></blockquote><blockquote><p>多条SQL语句必须以分号（;）分隔。MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号</p></blockquote><blockquote><p>即使不一定需要，但加上分号肯定没有坏处</p></blockquote><blockquote><p>如果你使用的是mysql命令行，必须加上分号来结束SQL语句</p></blockquote><blockquote><p>，SQL语句不区分大小写</p></blockquote><blockquote><p>。许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。</p></blockquote><blockquote><p>在SELECT关键字后给出多个列名，列名之间必须以逗号分隔。</p></blockquote><blockquote><p>但最后一个列名后不加。如果在最后一个列名后加了逗号，将出现错误。</p></blockquote><blockquote><p>SQL语句一般返回原始的、无格式的数据。数据的格式化是一个表示问题，而不是一个检索问题</p></blockquote><blockquote><p>SELECT语句还可以检索所有的列而不必逐个列出它们。这可以通过在实际列名的位置使用星号（*）通配符来达到</p></blockquote><blockquote><p>列的顺序一般是列在表定义中出现的顺序。但有时候并不是这样的，表的模式的变化（如添加或删除列）可能会导致顺序的变化。</p></blockquote><blockquote><p>虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。</p></blockquote><blockquote><p>避免相同内容重复显示如何检索出有不同值的列表呢？<br>解决办法是使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。</p></blockquote><blockquote><p>如何检索出有不同值的列表呢？解决办法是使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。</p></blockquote><blockquote><p>DISTINCT 只作用于当前列，与逗号之后的列无关不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列</p></blockquote><blockquote><p>不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列</p></blockquote><blockquote><p>SELECT语句返回所有匹配的行</p></blockquote><blockquote><p>为了返回第一行或前几行，可使用LIMIT子句。</p></blockquote><blockquote><p>LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数</p></blockquote><blockquote><p>所以，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。</p></blockquote><blockquote><p>检索出来的第一行为行0而不是行1</p></blockquote><blockquote><p>MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。</p></blockquote><blockquote><p>也可能会使用完全限定的名字来引用列（同时使用表名和列字）</p></blockquote><blockquote><p>表名也可以是完全限定</p></blockquote><h2 id="第5章-排序检索数据"><a href="#第5章-排序检索数据" class="headerlink" title="第5章 排序检索数据"></a>第5章 排序检索数据</h2><ul><li>关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义</li><li>为了明确地<strong>排序</strong>用SELECT语句检索出的数据，可使用<strong>ORDER BY</strong>子句</li><li>取一个或多个列的名字，据此对输出进行排序</li><li>也可以<strong>通过非选择列进行排序</strong>：</li><li>为了按<strong>多个列</strong>排序，只要<strong>指定列名</strong>，列名之间<strong>用逗号分开</strong>即可（就像选择多个列时所做的那样）</li><li>在按多个列排序时，排序完全按所规定的顺序进行</li><li><strong>升序</strong>排序（从A到Z）。这只是<strong>默认</strong>的排序顺序</li><li>为了进行<strong>降序</strong>排序，必须指定<strong>DESC</strong>关键字</li><li><strong>DESC</strong>关键字<strong>只应用到直接位于其前面</strong>的列名</li><li>如果想在多个列上进行降序排序，<strong>必须对每个列指定DESC关键字</strong>。</li><li>在字典（dictionary）排序顺序中，<strong>A被视为与a相同</strong>，这是<strong>MySQL</strong>（和大多数DBMS）的<strong>默认</strong>行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。</li><li>如果使用<strong>LIMIT</strong>，它<strong>必须位于ORDER BY之后</strong>。使用子句的次序不对将产生错误消息。</li></ul><hr><h2 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h2><blockquote><p>只检索所需数据需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）。在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名（FROM子句）之后给出</p></blockquote><blockquote><p>应该让ORDER BY位于WHERE之后，否则将会产生错误</p></blockquote><ul><li><p>MySQL支持下列所有条件操作符：</p><p>| 操作符    | 说明                   |<br>| ——— | ———————- |<br>| <code>=</code>       | 等于                   |<br>| <code>&lt;&gt;</code>/<code>!=</code> | <strong>不等于</strong>             |<br>| <code>&lt;</code>       | 小于                   |<br>| <code>&lt;=</code>      | 小于等于               |<br>| <code>&gt;</code>       | 大于                   |<br>| <code>&gt;=</code>      | 大于等于               |<br>| <code>BETWEEN</code> | <strong>在指定的两个值之间</strong> |</p></li></ul><ul><li>MySQL在<strong>执行匹配时</strong>默认<strong>不区分大小写</strong></li></ul><blockquote><p>不匹配检查以下例子列出不是由供应商1003制造的所有产品：</p></blockquote><ul><li><p><strong>单引号</strong>用来<strong>限定字符串</strong>。(Python既可以用单引号，也可以用双引号)</p></li><li><p>在使用<code>BETWEEN</code>时，必须<strong>指定两个值</strong>——所需范围的低端值和高端值。<strong>这两个值必须用AND关键字分隔</strong>。BETWEEN匹配范围中所有的值，<strong>包括指定的开始值</strong>和<strong>结束值</strong>。</p></li><li><p>SELECT语句有一个特殊的WHERE子句，可用来<strong>检查具有NULL值的列</strong>。这个WHERE子句就是<strong>IS NULL子句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>在通过过滤选择出不具有特定值的行时，<strong>你可能希望返回具有NULL值的行，但是，不行</strong>。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。</p></li></ul><h2 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h2><h3 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h3><ul><li>MySQL允许给出多个WHERE子句。这些子句可以两种方式使用：以<strong>AND子句</strong>的方式或<strong>OR子句</strong>的方式使用。</li></ul><h4 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h4><ul><li><p>SQL（像多数语言一样）<strong>在处理OR操作符前，优先处理AND操作符</strong>，为了使机器能够理解，应<strong>使用圆括号明确地分组相应的操作符</strong>。如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SLECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;</span><br></pre></td></tr></table></figure></li><li><p><strong>任何时候</strong>使用具有<strong>AND</strong>和<strong>OR</strong>操作符的WHERE子句，<strong>都应该使用圆括号明确地分组操作符</strong>，消除歧义。</p></li></ul><hr><h3 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h3><ul><li><p>IN操作符后跟<strong>由逗号分隔</strong>的合法值清单，<strong>整个清单必须括在圆括号中</strong>。<strong>IN操作符完成与OR相同的功能</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure></li><li><p>为什么要使用IN操作符？其优点具体如下。</p><ol><li>在使用<strong>长的合法选项清单</strong>时，IN操作符的<strong>语法更清楚且更直观</strong>。</li><li>在使用IN时，<strong>计算的次序更容易管理</strong>（因为<strong>使用的操作符更少</strong>）。</li><li>IN操作符<strong>一般比OR操作符清单执行更快</strong>。</li><li>IN的最大优点是<strong>可以包含其他SELECT语句</strong>，使得<strong>能够更动态地建立WHERE子句</strong>。第14章将对此进行详细介绍。</li></ol></li></ul><h3 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h3><ul><li><p>NOT操作符有且只有一个功能，那就是<strong>否定它之后所跟的任何条件</strong>。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure></li><li><p>对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，<strong>在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单</strong>。</p></li><li><p>MySQL支持使用NOT对IN、BETWEEN和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。</p></li></ul><h2 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h2><h3 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h3><ul><li><p>怎样搜索<strong>产品名中包含文本anvil</strong>的所有产品？用简单的比较操作符肯定不行，<strong>必须使用通配符</strong>。利用通配符可创建比较特定数据的搜索模式</p></li><li><p><strong>搜索模式</strong>（<strong>search pattern</strong>）：</p><p>由<strong>字面值</strong>、<strong>通配符</strong>或<strong>两者组合构成的搜索条件</strong></p></li><li><p>通配符本身实际是SQL的WHERE子句中<strong>有特殊含义的字符</strong>，SQL支持几种通配符。</p></li><li><p>为在搜索子句中使用通配符，必须使用<strong>LIKE操作符</strong>。LIKE指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。</p></li><li><p>操作符何时不是操作符？答案是在它作为谓词（<strong>predi-cate</strong>）时。<strong>从技术上说，LIKE是谓词而不是操作符</strong>。虽然最终的结果是相同的，但应该对此术语有所了解，以免在SQL文档中遇到此术语时不知道。</p></li></ul><h4 id="百分号-通配符"><a href="#百分号-通配符" class="headerlink" title="百分号(%)通配符"></a>百分号(%)通配符</h4><ul><li><p>最常使用的通配符是百分号（%）。在搜索串中，<strong>%表示任何字符出现任意次数</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>| prod_id | prod_name    |<br>| ——- | ———— |<br>| JP1000  | JetPack 1000 |<br>| JP2000  | JetPack 2000 |</p></li><li><p>根据MySQL的配置方式，<strong>搜索可以是区分大小写的</strong>。如果区分大小写，<code>&#39;jet%&#39;</code>与JetPack 1000将不匹配。</p></li><li><p>通配符<strong>可以在搜索模式中任意位置使用</strong>，并且<strong>可以使用多个通配符</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'%anvil%'</span>;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>| prod_id | prod_name    |<br>| ——- | ———— |<br>| ANV01   | .5 ton anvil |<br>| ANV02   | 1 ton anvil  |<br>| ANV03   | 2 ton anvil  |</p></li></ul><ul><li><p>重要的是要注意到，<strong>除了一个或多个字符外，%还能匹配0个字符</strong>。<strong>%代表搜索模式中给定位置的0个、1个或多个字符</strong>。</p></li><li><p>注意<strong>尾空格</strong>：</p><p>尾空格可能会<strong>干扰通配符匹配</strong>。例如，在保存词anvil时，如果它后面有一个或多个空格，则子句WHERE prod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l后有多余的字符。<strong>解决这个问题的一个简单的办法是在搜索模式最后附加一个%</strong>。一个<strong>更好的办法是使用函数</strong>（第11章将会介绍）<strong>去掉首尾空格</strong>。</p></li><li><p>虽然<strong>似乎%通配符可以匹配任何东西</strong>，但有一个例外，即<strong>NULL</strong>。<strong>即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行</strong>。</p></li></ul><hr><h4 id="下划线-通配符"><a href="#下划线-通配符" class="headerlink" title="下划线(_)通配符"></a>下划线(_)通配符</h4><ul><li>下划线的<strong>用途与%一样</strong>，但下划线<strong>只匹配单个字符</strong>。</li></ul><hr><h3 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h3><ol><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。<strong>把通配符置于搜索模式的开始处，搜索起来是最慢的(会使索引失效)</strong>。</li></ol><h2 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h2><h3 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h3><p>正则表达式(<strong>Reg</strong>ular <strong>Exp</strong>ression)是用来<strong>匹配文本</strong>的特殊的串（字符集合）。</p><p><strong>所有种类</strong>的程序设计语言、文本编辑器、操作系统等<strong>都支持正则表达式</strong>。</p><hr><h3 id="使用MySQL正则表达式"><a href="#使用MySQL正则表达式" class="headerlink" title="使用MySQL正则表达式"></a>使用MySQL正则表达式</h3><p>MySQL用<strong>WHERE子句对正则表达式提供了初步的支持</strong>，允许你指定正则表达式，过滤SELECT检索出的数据。</p><ul><li>MySQL<strong>仅支持</strong>多数正则表达式实现的<strong>一个很小的子集</strong></li></ul><h4 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h4><p><strong>例1：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'1000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure><ul><li>除<strong>关键字LIKE被REGEXP替代</strong>外，这条语句看上去非常像使用LIKE的语句（第8章）。它告诉MySQL，<strong>REGEXP后所跟的东西作为正则表达式</strong>（与文字正文1000匹配的一个正则表达式）处理。</li></ul><p><strong>例2：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'.000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><ul><li><code>.</code>是正则表达式语言中一个<strong>特殊的字符</strong>，它表示<strong>匹配任意一个字符</strong>。</li></ul><p><strong>LIKE 与 REGEXP 的重要区别</strong></p><p><strong>例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'1000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'1000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><ul><li><p>LIKE匹配<strong>整个列</strong></p><p>  如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）</p></li><li><p>REGEXP<strong>在列值内进行匹配</strong></p><p>  如果被匹配的文本在列值中出现，REGEXP将会找到它，返回相应行。</p></li></ul><p>那么，<strong>REGEXP能不能用来匹配整个列值（从而起与LIKE相同的作用）</strong>？答案是肯定的，使用<code>^</code>和<code>$</code><strong>定位符</strong>（anchor）即可，本章后面介绍。</p><ul><li>MySQL中的正则表达式匹配（自版本3.23.4后）<strong>不区分大小写</strong>（即，大写和小写都匹配）。为<strong>区分大小写</strong>，可使用<strong>BINARY关键字</strong>，如<code>WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;</code>。</li></ul><hr><h4 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h4><p>为<strong>搜索两个串之一</strong>（或者为这个串，或者为另一个串），使用<code>|</code>。</p><ul><li><p><code>REGEXP &#39;1000|2000&#39;</code>。</p><p>  <code>|</code>为正则表达式的<strong>OR操作符</strong>，它表示<strong>匹配其中之一</strong>。</p></li><li><p><code>&#39;1000|2000|3000’</code>将匹配1000或2000或3000。</p></li></ul><hr><h4 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h4><p><code>.</code>用于匹配<strong>任一</strong>字符，如果你只想<strong>匹配特定的字符</strong>，怎么办？可通过<strong>指定一组用<code>[]</code>括起来的字符</strong>来完成:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[123] Ton'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><ul><li><p><code>[123]</code>定义一组字符，它的意思是<strong>匹配1或2或3</strong></p></li><li><p>正如所见，<code>[]</code>是另一种形式的OR语句。事实上，正则表达式<code>[123] Ton</code>为<code>[1|2|3] Ton</code>的<strong>缩写</strong>，也可以使用后者</p></li><li><p>字符集合也可以被否定，即，它们将匹配<strong>除指定字符外</strong>的任何东西。为<strong>否定一个字符集</strong>，在集合的开始处放置一个<code>^</code>即可。因此，尽管[123]匹配字符1、2或3，但<code>[^123]</code>却<strong>匹配除1、2、3字符外的任何东西</strong></p></li></ul><hr><h4 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h4><ul><li><p>集合可用来定义要匹配的一个或多个字符。集合<code>[0123456789]</code>将<strong>匹配数字0到9</strong>。为<strong>简化</strong>这种类型的集合，可使用<code>-</code>来定义一个范围：<code>[0-9]</code>功能上等同于上述数字列表。</p></li><li><p>范围不限于完整的集合，<code>[1-3]</code>和<code>[6-9]</code>也是合法的范围。此外，范围不一定只是数值的，<code>[a-z]</code>匹配任意字母字符。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[1-5] Ton'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h4><p>为了匹配特殊字符，必须用<code>\\</code>为前导。<code>\\-</code>表示查找<code>-</code>, <code>\\.</code>表示查找<code>.</code>。</p><p>这种处理就是所谓的<strong>转义（escaping）</strong>，<strong>正则表达式内具有特殊意义的所有字符都必须以这种方式转义</strong>。</p><p><strong>多数正则表达式实现</strong>使用<strong>单个反斜杠</strong>转义特殊字符，以便能使用这些字符本身。但<strong>MySQL要求两个反斜杠</strong>（MySQL自己解释一个，正则表达式库解释另一个）。</p><hr><h4 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a>匹配字符类</h4><p>为更方便工作，可以使用<strong>预定义的字符集，称为字符类（character class）</strong>。下表列出字符类以及它们的含义：</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>[:alpha:]</code></td><td>任意<strong>字母</strong><br>(同<code>[a-zA-Z]</code>)</td></tr><tr><td><code>[:lower:]</code></td><td>任意<strong>小写</strong>字母</td></tr><tr><td><code>[:upper:]</code></td><td>任意<strong>大写</strong>字母</td></tr><tr><td><code>[:digit:]</code></td><td>任意<strong>数字</strong><br>(同<code>[0-9]</code>)</td></tr><tr><td><code>[:alnum:]</code></td><td>任意<strong>字母和数字</strong><br>(同<code>[a-zA-Z0-9]</code>)</td></tr><tr><td><code>[:blank:]</code></td><td><strong>空格和制表</strong><br>(同<code>[\\t]</code>)</td></tr><tr><td><code>[:cntrl:]</code></td><td>ASCⅡ控制字符(ASCⅡ 0到31以及127)</td></tr><tr><td><code>[:print:]</code></td><td>任意<strong>可打印字符</strong></td></tr><tr><td><code>[:graph:]</code></td><td>与<code>[:print:]</code>相同，但<strong>不包括空格</strong></td></tr><tr><td><code>[:space:]</code></td><td><strong>包括空格</strong>在内的任意<strong>空白字符</strong></td></tr><tr><td><code>[:punct:]</code></td><td>既不在<code>[:alnum:]</code>又不在<code>[:cntrl:]</code>中的任意字符</td></tr><tr><td><code>[:xdigit:]</code></td><td>任意<strong>十六进制数字</strong><br>(同<code>[a-fA-F0-9]</code>)</td></tr></tbody></table><hr><h4 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h4><p>你可能需要<strong>寻找所有的数</strong>，<strong>不管数中包含多少数字</strong>，或者你可能想<strong>寻找一个单词</strong>并且<strong>还能够适应一个尾随的s（如果存在）</strong>，等等。这可以用下表列出的<strong>正则表达式重复元字符</strong>来完成：</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td><strong>0个</strong>或多个匹配</td></tr><tr><td><code>+</code></td><td><strong>1个</strong>或多个匹配<br>(等于<code>{1,}</code>)</td></tr><tr><td><code>?</code></td><td><strong>0个或1个</strong>匹配<br>(等于<code>{0,1}</code>)</td></tr><tr><td><code>{n}</code></td><td><strong>指定数目</strong>的匹配</td></tr><tr><td><code>{n,}</code></td><td><strong>不少于指定数目</strong>的匹配</td></tr><tr><td><code>{n,m}</code></td><td>匹配数目的范围<br>(m<strong>不超过255</strong>)</td></tr></tbody></table><ul><li><p>例1：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'\\([0-9] sticks?\\)'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p>  其中<code>?</code><strong>作用于之前的一个字符</strong>，即<code>s</code>，获取到两个prod_name：</p><ol><li><code>TNT (1 stick)</code></li><li><code>TNT (5 sticks)</code></li></ol></li><li><p>例2：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[[:digit:]&#123;4&#125;]'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p>  匹配<strong>连在一起的4个</strong>数字，得到如下prod_name：</p><ol><li><code>JetPack 1000</code></li><li><p><code>JetPack 2000</code></p><p>需要注意的是，在使用正则表达式时，<strong>编写某个特殊的表达式几乎总是有不止一种方法</strong>，本例还可以这样编写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[0-9][0-9][0-9][0-9]'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>上述所有例子都是<strong>匹配一个串中任意位置</strong>的文本。为了<strong>匹配特定位置的文本</strong>，需要使用下表出的<strong>定位符</strong>：</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td><code>^</code></td><td><strong>文本</strong>的开始</td></tr><tr><td><code>$</code></td><td><strong>文本</strong>的结尾</td></tr><tr><td><code>[[:&lt;:]]</code></td><td><strong>词</strong>的开始</td></tr><tr><td><code>[[:&gt;:]]</code></td><td><strong>词</strong>的结尾</td></tr></tbody></table><ul><li><p>例如，想找出<strong>以一个数(包括以小数点开始的数)开始</strong>的所有产品：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'^[0-9\\.]'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p>  <code>^</code>匹配<strong>串的开始</strong>。</p></li><li><p><code>^</code>的<strong>双重用途</strong></p><ol><li>在<strong>集合中</strong>（用<code>[]</code>定义），用它来<strong>否定该集合</strong>（如<code>[^123]</code>）</li><li>用来指串的开始处。</li></ol></li><li><p><strong>使REGEXP起类似LIKE的作用</strong></p><p>  <code>LIKE</code><strong>匹配整个串</strong>，而<code>REGEXP</code><strong>匹配子串</strong>。利用定位符，通过<strong>用<code>^</code>开始每个表达式，用<code>$</code>结束每个表达式</strong>，可以使REGEXP的作用与LIKE一样。</p></li><li><p><strong>简单的正则表达式测试</strong></p><p>  REGEXP检查总是返回<code>0</code>（<strong>没有匹配</strong>）或<code>1</code>（<strong>匹配</strong>）。可以<strong>用带文字串的REGEXP来测试表达式</strong>，并试验它们。相应的语法如下：</p><p>  <code>SELECT &#39;Hello&#39; REGEXP &#39;[0-9]&#39;</code>，这个例子显然返回0。 </p></li></ul><h2 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h2><h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h3><p>计算字段的作用是<strong>将数据库中几列所需的数据进行连接，直接从数据库中检索出转换、计算或格式化过的数据；而不是检索出数据后，在客户端应用程序中重新格式化</strong>。一般来说，在数据库服务器上完成这些操作比在客户端中完成要快得多，因为DBMS是设计来快速有效地完成这种处理的。</p><p><strong>计算字段并不实际存在于数据库表中，是运行时在SELECT语句内创建的</strong>。</p><hr><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p><strong>拼接</strong>(<strong>concat</strong>enate)：将值联结到一起构成单个值，具体就是<strong>把两个列拼接起来</strong>。</p><p><strong>多数DBMS使用<code>+</code>或<code>||</code>来实现拼接，MySQL则使用<code>Concat()</code>函数来实现</strong>。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>)</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure><ul><li><code>Concat()</code>需要一个或多个指定的串，各个串之间<strong>用逗号分隔</strong>。</li></ul><p>在第8章中曾提到通过<strong>删除数据右侧多余的空格</strong>来整理数据，这可以使用MySQL的<code>RTrim()</code>函数(第11章 文本处理函数)来完成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name), <span class="string">'('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">')'</span>)</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure><hr><h2 id="第11章-使用数据处理函数"><a href="#第11章-使用数据处理函数" class="headerlink" title="第11章 使用数据处理函数"></a>第11章 使用数据处理函数</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>相对来说，多数<strong>SQL语句是可移植的</strong>，在SQL实现之间有差异时，这些差异通常不那么难处理。而<strong>函数的可移植性却不强</strong>。几乎每种主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大。</p></li><li><p>为了代码的可移植，许多SQL程序员不赞成使用特殊实现的功能。虽然这样做很有好处，但不总是利于应用程序的性能。</p></li><li><p>如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p></li></ul><hr><h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><p>大多数SQL实现支持以下类型的函数。</p><ol><li>用于<strong>处理文本串</strong>（如<strong>删除或填充值</strong>，<strong>转换值为大写或小写</strong>）的<strong>文本处理函数</strong>。</li><li>用于在数值数据上进行算术操作（如<strong>返回绝对值</strong>，进行<strong>代数运算</strong>）的<strong>数值函数</strong>。</li><li>用于<strong>处理日期</strong>和<strong>时间值</strong>并从这些值中<strong>提取特定成分</strong>（例如，返回<strong>两个日期之差</strong>，<strong>检查日期有效性</strong>等）的<strong>日期和时间函数</strong>。</li><li>返回DBMS正使用的特殊信息（如返回<strong>用户登录信息</strong>，<strong>检查版本细节</strong>）的<strong>系统函数</strong>。</li></ol><hr><h4 id="转换数据类型函数"><a href="#转换数据类型函数" class="headerlink" title="转换数据类型函数"></a>转换数据类型函数</h4><p><code>CAST(expression AS data_type)</code></p><p>可以选择的类型(data_type)：</p><ul><li>二进制，同带binary前缀的效果 : BINARY   </li><li>字符型，可带参数 : CHAR()   </li><li>日期 : DATE   </li><li>时间: TIME   </li><li>日期时间型 : DATETIME   </li><li>浮点数 : DECIMAL    </li><li>整数 : SIGNED   </li><li>无符号整数 : UNSIGNED </li></ul><hr><h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>TRIM(s)</code></td><td>删除字符串首尾的空格</td></tr><tr><td><code>LTRIM(s)</code></td><td>删除字符串开头的空格</td></tr><tr><td><code>RTRIM(s)</code></td><td>删除字符串末尾的空格</td></tr><tr><td><code>UPPER(s)</code></td><td>将字符串转为大写</td></tr><tr><td><code>LOWER(s)</code></td><td>将字符串转为小写</td></tr><tr><td><code>LENGTH(s)</code></td><td>获取字符串长度</td></tr><tr><td><code>SUBSTRING(s, start, length)</code></td><td>获取字符串子集</td></tr><tr><td><code>LEFT(s, n)</code></td><td>返回字符串的<strong>前n个字符</strong></td></tr><tr><td><code>RIGHT(s, n)</code></td><td>返回字符串的<strong>后n个字符</strong></td></tr><tr><td><code>REPLACE(s, s1, s2)</code></td><td>将字符串s中的<strong>子集s1替换为s2</strong></td></tr><tr><td>GROUP_CONCAT([DISTINCT] expression<br>[ORDER BY expression] SEPARATOR sep)</td><td>将<strong>分组中的字符串</strong>通过<strong>自定义的分隔符</strong>进行连接</td></tr></tbody></table><ul><li><p>例子：</p><ul><li><p>错误写法：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>, <span class="keyword">NAME</span>, <span class="keyword">LENGTH</span>(<span class="keyword">NAME</span>) <span class="keyword">AS</span> LEN_NAME</span><br><span class="line"><span class="keyword">FROM</span> world.city</span><br><span class="line"><span class="keyword">WHERE</span> LEN_NAME &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>**city表中没有LEN_NAME列**，执行会报错。</code></pre><ul><li><p>正确写法：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>, <span class="keyword">NAME</span>, <span class="keyword">LENGTH</span>(<span class="keyword">NAME</span>) <span class="keyword">AS</span> LEN_NAME</span><br><span class="line"><span class="keyword">FROM</span> world.city </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">LENGTH</span>(<span class="keyword">NAME</span>) &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>GROUP_CONCAT()</code>的用法</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_no, <span class="keyword">GROUP_CONCAT</span>(emp_no SEPARATOR <span class="string">','</span>) </span><br><span class="line"><span class="keyword">FROM</span> dept_emp </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_no;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法</p></blockquote><blockquote><p>使得能对串进行发音比较而不是字母比较。</p></blockquote><blockquote><p>虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。</p></blockquote><blockquote><p>在这个例子中，WHERE子句使用Soundex()函数来转换cust_contact列值和搜索串为它们的SOUNDEX值。因为Y.Lee和Y.Lie发音相似，所以它们的SOUNDEX值匹配，因此WHERE子句正确地过滤出了所需的数据。</p></blockquote><hr><h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><ul><li>一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。</li></ul><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>ADDDATE(d, n)</code></td><td>计算起始日期d加上n<strong>天</strong>的日期<br>如<code>SELECT ADDDATE(2017-06-15, INTERVAL 10 DAY)</code></td></tr><tr><td><code>ADDTIME(t, n)</code></td><td>时间t加上n<strong>秒</strong>的时间</td></tr><tr><td><code>CURDATE()</code></td><td>返回当前<strong>日期</strong></td></tr><tr><td><code>CURTIME()</code></td><td>返回当前<strong>时间</strong>(<strong>不含日期</strong>)</td></tr><tr><td><code>NOW()</code></td><td>返回<strong>当前日期和时间</strong></td></tr><tr><td><code>DATE()</code></td><td><strong>从日期或日期时间表达式中提取日期值</strong><br>如<code>SELECT DATE(&quot;2017-06-15&quot;)</code></td></tr><tr><td><code>DATEDIFF(d1, d2)</code></td><td>计算日期d1-&gt;d2之间<strong>相隔的天数</strong></td></tr><tr><td><code>TIMESTAMPDIFF(INTERVAL, datetime_expr1, datetime_expr2)</code></td><td>比较两个日期的时间差。<br>interval 确定时间差的<strong>单位</strong>：SECOND、MINUTE、HOUR、DAY、MONTH、YEAR<br>差值为 后一个时间参数 - 前一个时间参数</td></tr><tr><td><code>DATE_ADD(d, INTERVAL expr type)</code></td><td>计算起始日期d<strong>加上</strong>一个<strong>时间段</strong>后的日期<br>如<code>DATE_ADD(paidTime, INTERVAL -2 MONTH)</code></td></tr><tr><td><code>DATE_SUB(d,INTERVAL expr unit)</code></td><td>计算起始日期d<strong>减去</strong>一个<strong>时间段</strong>后的日期<br>如<code>DATE_SUB(paidTime, INTERVAL 2 MONTH)</code></td></tr><tr><td><code>DATE_FORMAT(d, f)</code></td><td>按表达式f的要求显示日期d<br>如<code>SELECT DATE_FORMAT(&#39;2020-07-28&#39;, &quot;%Y-%m&quot;)</code></td></tr><tr><td><code>DAYOFWEEK(d)</code></td><td>当前日期是<strong>星期几</strong></td></tr><tr><td><code>YEAR(d)</code></td><td>返回<strong>年份</strong></td></tr><tr><td><code>MONTH(d)</code></td><td>返回<strong>月份</strong></td></tr><tr><td><code>DAY(d)</code></td><td>返回日期值d的<strong>日</strong>部分</td></tr><tr><td><code>HOUR(t)</code></td><td>返回<strong>小时值</strong></td></tr><tr><td><code>MINuTE(t)</code></td><td>返回<strong>分钟值</strong></td></tr><tr><td><code>SECOND(t)</code></td><td>返回<strong>秒钟值</strong></td></tr><tr><td><code>TIME(expression)</code></td><td>提取表达式中的<strong>时间部分</strong></td></tr></tbody></table><ul><li><p>数据经常需要<strong>用日期进行过滤</strong></p><ul><li><p>首先需要注意的是MySQL使用的<strong>日期格式</strong>。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，<strong>日期必须为格式yyyy-mm-dd</strong>。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它<strong>排除了多义性</strong>（如，04/05/06是2006年5月4日或2006年4月5日或2004年5月6日或……）。</p></li><li><p><strong>应该总是使用4位数字的年份</strong>。支持2位数字的年份，MySQL处理00-69为2000-2069，处理70-99为1970-1999。虽然它们可能是打算要的年份，但<strong>使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定</strong>。</p></li></ul></li><li><p>如果你<strong>想要的仅是日期</strong>，则<strong>使用Date()是一个良好的习惯</strong>，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个<strong>Time()函数</strong>，在你<strong>只想要时间时</strong>应该使用它。</p></li><li><p><code>Date()</code>和<code>Time()</code>都是在MySQL 4.1.1中第一次引入的。</p></li><li><p>还有一种日期比较需要说明。如果你想检索出2005年9月下的所有订单，怎么办？简单的相等测试不行，因为它也要匹配月份中的天数。有几种解决办法。</p><ul><li><p>其中之一如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">Date</span>(order_date) <span class="keyword">BETWEEN</span> <span class="string">'2005-09-01'</span> <span class="keyword">AND</span> <span class="string">'2005-09-30'</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>另外一种办法（<strong>不需要记住每个月中有多少天或不需要操心闰年2月</strong>）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(order_date) = <span class="number">2005</span> <span class="keyword">AND</span> <span class="keyword">MONTH</span>(order_date) = <span class="number">9</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr><td>SIN(x)</td><td>返回正弦值(参数是<strong>弧度</strong>)</td></tr><tr><td>COS(x)</td><td>返回余弦值(参数是<strong>弧度</strong>)</td></tr><tr><td>TAN(x)</td><td>返回正切值(参数是<strong>弧度</strong>)</td></tr><tr><td>EXP(x)</td><td>返回<strong>e的x次方</strong></td></tr><tr><td>MOD(x, y)</td><td>返回<strong>x除以y以后的余数</strong></td></tr><tr><td>PI()</td><td>返回圆周率(<strong>3.141593</strong>)</td></tr><tr><td>RAND()</td><td>返回<strong>0到1</strong>的随机数</td></tr><tr><td>SQRT()</td><td>返回x的<strong>平方根</strong></td></tr><tr><td>ROUND(column_name, decimals)</td><td>把数值字段<strong>舍入</strong>为<strong>指定的小数位数(decimals)</strong></td></tr></tbody></table><hr><h4 id="IF表达式"><a href="#IF表达式" class="headerlink" title="IF表达式"></a>IF表达式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF(expr1, expr2, expr3)</span><br></pre></td></tr></table></figure><p>expr1的值为<code>TRUE</code>，则返回值为<code>expr2</code><br>expr1的值为<code>FALSE</code>，则返回值为<code>expr3</code></p><hr><h4 id="IFNULL函数"><a href="#IFNULL函数" class="headerlink" title="IFNULL函数"></a>IFNULL函数</h4><p><code>IFNULL(check_expression, replacement_value )</code></p><ul><li><code>replacement_value</code>：在<code>check_expression</code>为<code>NULL</code>时返回的表达式</li><li><code>check_expression</code>和<code>replacement_value</code>类型必须相同</li></ul><p><strong>SQL Server</strong>中相同功能的函数为<code>ISNULL()</code></p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IFNULL</span>(</span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary </span><br><span class="line">        <span class="keyword">FROM</span> Employee </span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">        <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>),</span><br><span class="line">        <span class="literal">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure><hr><h4 id="开窗函数-窗口函数"><a href="#开窗函数-窗口函数" class="headerlink" title="开窗函数/窗口函数"></a>开窗函数/窗口函数</h4><h5 id="窗口函数的作用"><a href="#窗口函数的作用" class="headerlink" title="窗口函数的作用"></a>窗口函数的作用</h5><p>在日常工作中，经常会遇到需要<strong>在每组内排名</strong>，比如下面的业务需求：</p><blockquote><p>排名问题：<strong>每个部门</strong>按业绩来<strong>排名</strong></p><p>topN问题：找出<strong>每个部门排名前N</strong>的员工进行奖励</p></blockquote><p>面对这类需求，就需要使用SQL的高级功能<strong>窗口函数</strong>了。</p><hr><h5 id="什么是窗口函数"><a href="#什么是窗口函数" class="headerlink" title="什么是窗口函数"></a>什么是窗口函数</h5><p>窗口函数，也叫OLAP(Online Analytical Processing，<strong>实时分析处理</strong>)函数。</p><hr><p>基本语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口函数&gt; OVER (PARTITION BY &lt;用于分组的列名&gt; </span><br><span class="line">             ORDER BY &lt;用于排序的列名&gt;)</span><br></pre></td></tr></table></figure><p>为什么叫窗口函数？</p><p>​    因为<code>PARTITION BY</code><strong>分组后的结果</strong>称为”窗口”，<strong>表示范围</strong>的意思。</p><p><code>&lt;窗口函数&gt;</code>位置可以放以下两种函数：</p><ol><li><strong>专用窗口函数</strong></li><li><strong>聚合函数</strong></li></ol><p>因为<strong>窗口函数是对WHERE或者GROUP BY子句处理后的结果进行操作</strong>，所以窗口函数<strong>原则上只能写在SELECT子句中</strong>。</p><hr><h5 id="专用窗口函数RANK"><a href="#专用窗口函数RANK" class="headerlink" title="专用窗口函数RANK"></a>专用窗口函数RANK</h5><p>如果想在<strong>每个班级内</strong>按成绩排名，需要如下操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *, <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 班级</span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> 成绩 <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> 班级表;</span><br></pre></td></tr></table></figure><ul><li><p>在<strong>每个班级内</strong>按成绩排名：</p><ul><li><p>按班级分组</p><p>  <code>PARTITION BY</code>用来对表分组</p></li><li><p>按成绩排名</p><p>  <code>ORDER BY</code>用来<strong>对各分组内的结果排序</strong>(默认升序)</p></li></ul></li><li><p>为什么使用窗口函数，而不是<code>GROUP BY</code>+<code>ORDER BY</code>呢？</p><p>  因为<code>GROUP BY</code>分组汇总后，<strong>改变了表的行数</strong>，<strong>一行只有一个GROUP</strong>。而<strong><code>PARTITION BY</code>和<code>RANK</code>函数不会减少原表中的行数</strong>。</p></li></ul><hr><h5 id="其他专用窗口函数"><a href="#其他专用窗口函数" class="headerlink" title="其他专用窗口函数"></a>其他专用窗口函数</h5><ul><li><code>DENSE_RANK()</code></li><li><code>ROW_NUMBER()</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,</span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> 成绩 <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking,</span><br><span class="line">    <span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> 成绩 <span class="keyword">DESC</span>) <span class="keyword">AS</span> <span class="keyword">dense_rank</span>,</span><br><span class="line">    ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> 成绩 <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num</span><br><span class="line"><span class="keyword">FROM</span> 班级表;</span><br></pre></td></tr></table></figure><ul><li><p><code>NTILE(n)</code>：将指定行<strong>等分成n个组</strong>，赋予<strong>组号</strong>（<strong>1-n</strong>）</p><ul><li><p><code>n</code>：指定分组数</p><p>  如果<strong>分组数n不能被整除</strong>，将会生成<strong>两种大小</strong>的组，组内<strong>行数差距为1</strong>，<strong>行数多的组</strong>以<code>ORDER BY</code>指定的顺序<strong>在前</strong>。</p></li></ul></li></ul><p><strong>四个专用窗口函数的区别</strong>：</p><table><thead><tr><th>窗口函数</th><th>特点</th></tr></thead><tbody><tr><td><code>RANK()</code></td><td>如果<strong>有并列名次的行，会占用下一名次的位置</strong><br>(如：1, 1, 1, <strong>4</strong>)</td></tr><tr><td><code>DENSE_RANK()</code></td><td>如果<strong>有并列名次的行，不占用下一名次的位置</strong><br>(如：1, 1, 1, <strong>2</strong>)</td></tr><tr><td><code>ROW_NUMBER()</code></td><td><strong>不考虑并列名次的情况</strong><br>(如：1, <strong>2</strong>, <strong>3</strong>, 4)</td></tr><tr><td><code>NTILE(n)</code></td><td>将指定行<strong>等分成n个组</strong>，赋予<strong>组号</strong>（<strong>1-n</strong>）</td></tr></tbody></table><hr><h5 id="聚合函数作为窗口函数"><a href="#聚合函数作为窗口函数" class="headerlink" title="聚合函数作为窗口函数"></a>聚合函数作为窗口函数</h5><p>聚和窗口函数和上面提到的专用窗口函数<strong>用法完全相同</strong>，只需要把聚合函数写在窗口函数的位置即可，但是<strong>函数后面括号里面不能为空，需要指定聚合的列名</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,</span><br><span class="line"><span class="keyword">SUM</span>(成绩) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> 学号) <span class="keyword">AS</span> current_sum,</span><br><span class="line"><span class="keyword">AVG</span>(成绩) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> 学号) <span class="keyword">AS</span> current_avg,</span><br><span class="line"><span class="keyword">COUNT</span>(成绩) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> 学号) <span class="keyword">AS</span> current_count,</span><br><span class="line"><span class="keyword">MAX</span>(成绩) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> 学号) <span class="keyword">AS</span> current_max,</span><br><span class="line"><span class="keyword">MIN</span>(成绩) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> 学号) <span class="keyword">AS</span> current_min</span><br><span class="line"><span class="keyword">FROM</span> 班级表;</span><br></pre></td></tr></table></figure><p>上述聚合函数，都是<strong>针对自身记录</strong>以及自身记录<strong>之前(已查询出来的行)</strong>的所有数据进行计算(<strong>从第一行到当前为止</strong>)。</p><p>聚合函数作为窗口函数，可以在每一行的数据里直观的看到，<strong>截止到本行数据，统计数据是多少</strong>（最大值、最小值等），同时<strong>可以看出每一行数据，对整体统计数据的影响</strong>。</p><hr><ul><li><p>前后函数</p><ul><li><code>LAG()</code></li><li><code>LEAD(return_value, offset, [,default])</code>：<strong>从当前行访问下一行的数据或下一行之后的行</strong>。</li><li><code>return_value</code>： 基于指定偏移量的后续<strong>行的返回值</strong>，必须为单个值。<pre><code>- `offset`：从当前行转发的行数，值**为正整数，默认是1**</code></pre></li></ul></li><li><p>头尾函数</p><ul><li><code>FIRST_VAL()</code></li><li><code>LAST_VAL()</code></li></ul></li></ul><hr><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>PARTITION子句可以省略，即<strong>不指定分组</strong>。但这样就失去了窗口函数的功能，所以<strong>一般不要这么使用</strong>。</p><hr><h4 id="MySQL-8-0前没有窗口函数，怎么办"><a href="#MySQL-8-0前没有窗口函数，怎么办" class="headerlink" title="MySQL 8.0前没有窗口函数，怎么办"></a>MySQL 8.0前没有窗口函数，怎么办</h4><p>通过<strong>变量</strong>达到相同效果。</p><p>例：</p><p>创建一个<strong>人员年龄表</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>, </span><br><span class="line">    first_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>), </span><br><span class="line">    age <span class="built_in">INT</span>, </span><br><span class="line">    gender <span class="built_in">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'Bob'</span>, <span class="number">25</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'Jane'</span>, <span class="number">20</span>, <span class="string">'F'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'Jack'</span>, <span class="number">30</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'Bill'</span>, <span class="number">32</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'Nick'</span>, <span class="number">22</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'Kathy'</span>, <span class="number">18</span>, <span class="string">'F'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">'Steve'</span>, <span class="number">36</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">'Anne'</span>, <span class="number">25</span>, <span class="string">'F'</span>);</span><br></pre></td></tr></table></figure><p>现在要<strong>根据不同性别进行分组排序他们的年龄，并得到序列号</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MySQL8.0之后，用窗口函数</span></span><br><span class="line"><span class="keyword">SELECT</span> gender, first_name, age, <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> gender </span><br><span class="line">                   <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>) <span class="keyword">AS</span> 排名</span><br><span class="line"><span class="keyword">FROM</span> person;</span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL8.0之前，用变量</span></span><br><span class="line"><span class="keyword">SELECT</span> gender, first_name, age, <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> first_name, gender, age, </span><br><span class="line">      @<span class="keyword">rank</span>:=<span class="keyword">IF</span>(@gen=gender, @<span class="keyword">rank</span>+<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">rank</span>, <span class="comment">-- 一开始@gen为空，获得排名为第一，其后相同性别时排名排名递增(按ROW_NUM()窗口函数规则排序) </span></span><br><span class="line">      @gen:=gender <span class="comment">-- 给gen赋值</span></span><br><span class="line">      <span class="keyword">FROM</span> person, (<span class="keyword">SELECT</span> @<span class="keyword">rank</span>:=<span class="number">0</span>, @gen:=<span class="literal">NULL</span>) temp <span class="comment">-- 自然连接，为person表添加两个列</span></span><br><span class="line">      <span class="keyword">ORDER</span> <span class="keyword">BY</span> gender, age <span class="keyword">DESC</span>) b <span class="comment">-- 按性别、年龄排序</span></span><br></pre></td></tr></table></figure><hr><h4 id="行转列Pivot函数-MySQL没有，SQL-Server有"><a href="#行转列Pivot函数-MySQL没有，SQL-Server有" class="headerlink" title="行转列Pivot函数(MySQL没有，SQL Server有)"></a>行转列Pivot函数(MySQL没有，SQL Server有)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">PIVOT</span>(</span><br><span class="line">聚合函数 (value_column)</span><br><span class="line"><span class="keyword">FOR</span> pivot_column</span><br><span class="line"><span class="keyword">IN</span> (&lt;column_list&gt;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例：一张各学生各课程的分数表如下：</p><table><thead><tr><th>姓名</th><th>科目</th><th>分数</th></tr></thead><tbody><tr><td>张三</td><td>语文</td><td>74</td></tr><tr><td>张三</td><td>数学</td><td>83</td></tr><tr><td>张三</td><td>物理</td><td>93</td></tr><tr><td>李四</td><td>语文</td><td>74</td></tr><tr><td>李四</td><td>数学</td><td>84</td></tr><tr><td>李四</td><td>物理</td><td>94</td></tr></tbody></table><ul><li><p>现要根据姓名<strong>分别统计三门成绩</strong>，即：姓名、语文、数学、物理</p><ul><li><p><strong>MySQL</strong>采用<code>MAX(CASE WHEN ... ELSE ... END)</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 姓名, <span class="keyword">MAX</span>(<span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> 科目=<span class="string">'语文'</span> <span class="keyword">THEN</span> 分数 </span><br><span class="line">              <span class="keyword">ELSE</span> <span class="number">0</span> <span class="comment">-- MAX 是为了确保筛选出科目为语文的成绩</span></span><br><span class="line"><span class="keyword">END</span>) 语文, </span><br><span class="line"><span class="keyword">MAX</span>(<span class="keyword">CASE</span> </span><br><span class="line">                    <span class="keyword">WHEN</span> 科目=<span class="string">'数学'</span> <span class="keyword">THEN</span> 分数</span><br><span class="line">                    <span class="keyword">ELSE</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">END</span>) 数学,</span><br><span class="line"><span class="keyword">MAX</span>(<span class="keyword">CASE</span> </span><br><span class="line">               <span class="keyword">WHEN</span> 科目=<span class="string">'物理'</span> <span class="keyword">THEN</span> 分数</span><br><span class="line">                <span class="keyword">END</span>) 物理</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 姓名;</span><br></pre></td></tr></table></figure></li><li><p>其他可以<strong>使用Pivot函数</strong>的数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">Pivot</span>(<span class="keyword">MAX</span>(分数) <span class="comment">-- 对 指定列 使用聚合函数</span></span><br><span class="line">      <span class="keyword">FOR</span> 科目 <span class="comment">-- 需要 转换为列 的行</span></span><br><span class="line">      <span class="keyword">IN</span> (语文, 数学, 物理)) <span class="comment">-- 转换为列后的各列名</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="列转行UNPIVOT函数"><a href="#列转行UNPIVOT函数" class="headerlink" title="列转行UNPIVOT函数"></a>列转行UNPIVOT函数</h4><hr><h2 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><ul><li>我们经常需要<strong>汇总数据而不用把它们实际检索出来</strong>，为此MySQL提供了专门的函数。使用这些函数，MySQL查询可用于<strong>检索数据，以便分析和报表生成</strong>。这种类型的检索例子有以下几种：<ul><li>确定表中<strong>行数</strong>（或者满足某个条件或包含某个特定值的行数）</li><li>获得表中<strong>行组的和</strong>。</li><li>找出表列（或所有行或某些特定的行）的<strong>最大值、最小值</strong>和<strong>平均值</strong>。</li></ul></li><li>上述例子都需要<strong>对表中数据</strong>（而<strong>不是实际数据本身</strong>）<strong>汇总</strong>。因此，返回实际表数据是对时间和处理资源的一种浪费（更不用说带宽了）。</li></ul><table><thead><tr><th>函数</th><th>说明</th><th>对 列值为NULL的行 的处理</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回<strong>某列</strong>的平均值</td><td>忽略</td></tr><tr><td><code>COUNT()</code></td><td>返回<strong>某列</strong>的<strong>行数</strong></td><td>COUNT(<strong>*</strong>) /COUNT(<strong>1</strong>)<strong>不忽略</strong><br>COUNT(<strong>指定列名</strong>)忽略</td></tr><tr><td><code>MAX()</code></td><td>返回<strong>某列</strong>的最大值</td><td>忽略</td></tr><tr><td><code>MIN()</code></td><td>返回<strong>某列</strong>的最小值</td><td>忽略</td></tr><tr><td><code>SUM()</code></td><td>返回<strong>某列</strong>之和</td><td>忽略</td></tr></tbody></table><ul><li>MySQL还支持一系列的标准偏差聚集函数，但本书并未涉及这些内容。</li></ul><h4 id="AVG-函数"><a href="#AVG-函数" class="headerlink" title="AVG()函数"></a>AVG()函数</h4><ul><li><p>AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。<strong>可返回所有列的平均值</strong>，也可用来返回<strong>特定列或行的平均值</strong>。</p><ul><li>如下，使用AVG()返回products表中<strong>所有产品的平均价格</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure><ul><li>如下，返回<strong>特定供应商所提供产品的平均价格</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span>;</span><br></pre></td></tr></table></figure></li><li><p>AVG()只能用来确定特定数值列得平均值，且<strong>列名必须作为函数参数给出</strong>。<strong>为了获得多个列的平均值，必须使用多个AVG()函数</strong>。</p></li><li><p><strong>AVG()函数忽略列值为NULL的行。</strong></p></li></ul><hr><h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT()函数"></a>COUNT()函数</h4><ul><li><p>可利用COUNT()确定<strong>表中行的数目</strong>或<strong>符合特定条件的行的数目</strong>。</p></li><li><p>COUNT()函数有两种使用方式：</p><ol><li>使用<code>COUNT(*)</code>/<code>COUNT(1)</code>对表中<strong>行的数目</strong>进行计数，<strong>包括空值（NULL）</strong>。</li><li>使用<code>COUNT(column)</code>对特定列中具有值的行进行计数，<strong>忽略NULL值</strong>。</li></ol></li><li><p><strong>去重计数</strong></p><p>  <code>COUNT(DISTINCT xxx)</code>：xxx为<strong>列名</strong></p></li></ul><hr><h4 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX()函数"></a>MAX()函数</h4><ul><li><p>MAX()返回指定列中的最大值。MAX()<strong>要求指定列名</strong>。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>对<strong>非数值数据</strong>使用MAX()：</p><p>虽然MAX()一般用来找出最大的<strong>数值</strong>或<strong>日期值</strong>，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在<strong>用于文本数据时</strong>，如果数据按相应的列排序，则MAX()<strong>返回最后一行</strong>。</p></li><li><p>MAX()函数<strong>忽略列值为NULL的行</strong>。</p></li></ul><hr><h4 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN()函数"></a>MIN()函数</h4><ul><li><p>MIN()的功能正好与MAX()功能相反，它返回指定列的最小值。与MAX()一样，MIN()要求指定列名</p></li><li><p>在用于文本数据时，如果数据按相应的列排序，则MIN()<strong>返回最前面的行</strong>。</p></li><li>MIN()函数<strong>忽略列值为NULL的行</strong>。</li></ul><hr><h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM()函数"></a>SUM()函数</h4><ul><li><p>SUM()用来返回<strong>指定列值的和</strong>（总计）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(quantity) <span class="keyword">AS</span> items_ordered</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure></li><li><p>SUM()也可以用来<strong>合计计算值</strong>。在下面的例子中，合计每项物品的item_price*quantity，得出总的订单金额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(item_price * quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure></li><li><p>SUM()<strong>函数忽略列值为NULL的行</strong>。</p></li></ul><hr><h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><ul><li><p>聚集函数的<strong>DISTINCT</strong>的使用，已经被添加到MySQL <strong>5.0.3</strong>中。下面所述内容<strong>在MySQL 4.x中不能正常运行</strong>。</p></li><li><p>上述5个聚集函数都可以如下使用：</p><ol><li><strong>对所有的行执行计算</strong>，指定ALL参数或不给参数（因为<strong>ALL是默认行为</strong>）；</li><li><strong>只包含不同的值</strong>，指定<strong>DISTINCT参数</strong>。</li></ol></li><li><p>下面的例子使用AVG()函数返回特定供应商提供的产品的平均价格。它与上面的SELECT语句相同，但<strong>使用了DISTINCT参数</strong>，因此平均值<strong>只考虑各个不同的价格</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误</strong>。类似地，<strong>DISTINCT必须使用列名</strong>，<strong>不能用于计算或表达式</strong>。</p></li></ul><hr><h3 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_items,</span><br><span class="line"><span class="keyword">MIN</span>(prod_price) <span class="keyword">AS</span> price_min,</span><br><span class="line"><span class="keyword">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,</span><br><span class="line"><span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure><ul><li><p>这里用单条SELECT语句执行了4个聚集计算，返回4个值（products表中物品的数目，产品价格的最低、最高以及平均值）</p></li><li><p>在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。</p></li></ul><h2 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h2><h3 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h3><ul><li>如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办？这就是分组显身手的时候了。<strong>分组</strong>允许<strong>把数据分为多个逻辑组</strong>，以便能<strong>对每个组进行聚集计算</strong>。</li></ul><hr><h3 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h3><ul><li><p>分组是在SELECT语句的<strong>GROUP BY子句中建立</strong>的。理解分组的最好办法是看一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure><p>结果：</p><p>| vend_id | num_prods |<br>| ——- | ——— |<br>| 1001    | 3         |<br>| 1002    | 2         |<br>| 1003    | 7         |<br>| 1005    | 2         |</p></li><li><p><strong>GROUP BY子句指示</strong>MySQL<strong>按vend_id排序并分组数据</strong>。这导致<strong>对每个vend_id</strong>而不是整个表<strong>计算num_prods一次</strong></p></li><li><p>因为使用了GROUP BY，就<strong>不必指定要计算和估值的每个组了</strong>,<strong>系统会自动完成</strong>。<strong>GROUP BY子句</strong>指示MySQL分组数据，然后<strong>对每个组</strong>而不是整个结果集<strong>进行聚集</strong>。</p></li><li><p>一些重要的规定：</p><ul><li>GROUP BY子句<strong>可以包含任意数目的列</strong>。这使得<strong>能对分组进行嵌套，为数据分组提供更细致的控制</strong>。</li><li>如果在GROUP BY子句中<strong>嵌套了分组</strong>，<strong>数据将在最后规定的分组上进行汇总</strong>。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li><li><strong>GROUP BY子句中列出的每个列</strong>都必须是<strong>检索列</strong>或<strong>有效的表达式</strong>（但<strong>不能是聚集函数</strong>）。如果<strong>在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式</strong>。<strong>不能使用别名</strong>。</li><li><strong>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出</strong>。</li><li>如果<strong>分组列中具有NULL值</strong>，则NULL<strong>将作为一个分组返回</strong>。如果列中有多行NULL值，它们将分为一组。</li><li><strong>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</strong>。</li></ul></li><li><p>使用<strong>WITH ROLLUP关键字</strong>，<strong>可以得到每个分组以及每个分组汇总级别（针对每个分组）的值</strong>，如下所示:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h3><ul><li><p><strong>WHERE</strong>子句能<strong>过滤指定的行</strong>；<strong>HAVING</strong>子句用于<strong>过滤分组</strong>。</p></li><li><p>HAVING非常类似于WHERE。事实上，<strong>目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代</strong>。</p></li><li><p>过滤分组的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这里WHERE子句不起作用，因为过滤是<strong>基于分组聚集值</strong>。</p></li><li><p>HAVING和WHERE的差别</p><p><strong>WHERE</strong>在<strong>数据分组前</strong>进行过滤，<strong>HAVING</strong>在<strong>数据分组后</strong>进行过滤。<strong>这是一个重要的区别，WHERE排除的行不包括在分组中。</strong>这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。</p></li><li><p>有没有在一条语句中<strong>同时使用WHERE和HAVING子句的需要</strong>呢？事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点，可增加一条WHERE子句，过滤出过去12个月内下过的订单。然后再增加HAVING子句过滤出具有两个以上订单的分组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &gt;= <span class="number">10</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><ul><li><p>虽然<strong>GROUP BY</strong>和<strong>ORDER BY</strong>经常完成相同的工作，但它们是非常不同的。</p><p>| ORDER BY                                   | GROUP BY                                                     |<br>| —————————————— | ———————————————————— |<br>| 排序产生的输出                             | 分组行。但<strong>输出可能不是分组的顺序</strong>。                       |<br>| 任意列都可以使用(甚至非选择的列也可以使用) | 只可能使用<strong>选择列</strong>或<strong>表达式列</strong>，<strong>而且必须使用每个选择列表达式</strong> |<br>| 不一定需要                                 | 如果与聚集函数一起使用列(或表达式)，则必须使用               |</p></li><li><p><strong>我们经常发现用GROUP BY分组的数据确实是以分组顺序输出，但情况并不总是这样，它并不是SQL规范所要求的</strong>。</p></li><li><p><strong>应该提供明确的ORDER BY子句</strong>，即使其效果等同于GROUP BY子句也是如此。<strong>千万不要仅依赖GROUP BY排序数据</strong>。</p></li></ul><hr><h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td><strong>行</strong>级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td><strong>组</strong>级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table><hr><h2 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li><p><strong>MySQL 4.1引入了对子查询的支持</strong>，所以要想使用本章描述的SQL，必须使用MySQL 4.1或更高级的版本。</p></li><li><p><strong>查询（query）</strong></p><p>任何SQL语句都是查询。但此术语<strong>一般指SELECT语句</strong>。</p></li><li><p>SQL还允许创建<strong>子查询（subquery）</strong>，即<strong>嵌套在其他查询中的查询</strong>。</p></li></ul><hr><h3 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h3><ul><li><p>本书所有章中使用的数据库表都是<strong>关系表</strong>。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。</p></li><li><p>现在，假如需要<strong>列出订购物品TNT2的所有客户</strong>，应该怎样检索？下面列出具体的步骤：</p><ol><li>检索包含物品TNT2的所有订单的编号。</li><li>检索具有前一步骤列出的订单编号的所有客户的ID。</li><li>检索前一步骤返回的所有客户ID的客户信息。</li></ol><p>上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。也可以<strong>使用子查询来把3个查询组合成一条语句</strong>。</p></li><li><p>在SELECT语句中，<strong>子查询</strong>总是<strong>从内向外</strong>处理。包含子查询的SELECT语句难以阅读和调试，特别是它们较为复杂时更是如此。<strong>把子查询分解为多行并且适当地进行缩进</strong>，<strong>能极大地简化子查询的使用</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                 <span class="keyword">FROM</span> orders</span><br><span class="line">                 <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                     <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                     <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>));</span><br></pre></td></tr></table></figure></li><li><p>在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时<strong>由于性能的限制，不能嵌套太多的子查询</strong>。</p></li><li><p><strong>列必须匹配</strong></p><p>在WHERE子句中<strong>使用子查询</strong>，<strong>应该保证SELECT语句具有与WHERE子句中相同数目的列</strong>。<strong>通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列</strong>。</p></li><li><p>虽然<strong>子查询一般与IN操作符结合使用</strong>，<strong>但也可以用于测试等于（=）、不等于（&lt;&gt;）等</strong>。</p></li></ul><hr><h3 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h3><ul><li><p>使用子查询的另一方法是<strong>创建计算字段</strong></p></li><li><p>假如需要显示customers表中每个客户的订单总数，订单与相应的客户ID存储在orders表中。操作应遵循以下步骤：</p><ol><li>从customers表中检索客户列表</li><li>对于检索出的每个客户，统计其在orders表中的订单数目。<strong>对每个客户执行<code>COUNT(*)</code>计算，应该将<code>COUNT(*)</code>作为一个子查询</strong>。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,</span><br><span class="line">cust_state,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">         <span class="keyword">FROM</span> orders</span><br><span class="line">         <span class="keyword">WHERE</span> orders.cust_id = customers.cust_id) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure></li><li><p><strong>涉及外部查询</strong>的子查询称为<strong>相关子查询</strong>。任何时候<strong>只要列名可能有多义性</strong>，就必须使用这种语法（<strong>表名和列名由一个句点分隔</strong>）。</p></li></ul><h2 id="第15章-联结表"><a href="#第15章-联结表" class="headerlink" title="第15章 联结表"></a>第15章 联结表</h2><h3 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h3><ul><li><strong>联结</strong>是利用SQL的<strong>SELECT</strong>能执行的<strong>最重要</strong>的操作</li></ul><h4 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h4><ul><li>假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？将这些数据与产品信息分开存储的理由如下。<ul><li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li><li>如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。</li><li>如果有重复数据（即每种产品都存储供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。</li></ul></li></ul><p>相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。<strong>关系表的设计就是要保证把信息分解成多个表，一类数据一个表</strong>。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p><p>在这个例子中，可建立两个表，一个存储<strong>供应商信息</strong>，另一个存储<strong>产品信息</strong>。</p><ul><li>vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为<strong>主键（primary key）</strong>，可以是供应商ID或任何其他唯一值。</li><li><p>products表只存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储其他供应商信息。</p></li><li><p>vendors表的<strong>主键</strong>又叫作<strong>products的外键</strong>，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。</p><blockquote><p><strong>外键（foreign key）</strong>为某个表中的一列，它<strong>包含另一个表的主键值</strong>，定义了两个表之间的关系。</p></blockquote></li></ul><p>总之，关系数据可以有效地存储和方便地处理。因此，<strong>关系数据库</strong>的<strong>可伸缩性</strong>远比非关系数据库要好。</p><blockquote><p><strong>可伸缩性（scale）</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（<strong>scale well</strong>）</p></blockquote><hr><h4 id="为什么要使用联结"><a href="#为什么要使用联结" class="headerlink" title="为什么要使用联结"></a>为什么要使用联结</h4><p>如果数据存储在多个表中，<strong>要使用单条SELECT语句检索出数据</strong>，则需要使用联结。</p><p>联结是一种机制，<strong>用来在一条SELECT语句中关联表，因此称之为联结</strong>。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p><hr><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">WHERE</span> vendors.vend_id = products.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure><ul><li>这条语句的FROM子句列出了两个表，分别是vendors和products</li></ul><hr><h4 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a>WHERE子句的重要性</h4><ul><li><p>在一条SELECT语句中<strong>联结几个表时</strong>，相应的<strong>关系是在运行中构造</strong>的。</p></li><li><p>在联结两个表时，你实际上做的是<strong>将第一个表中的每一行与第二个表中的每一行配对</strong>。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行</p></li><li><p><strong>没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对</strong>，而不管它们逻辑上是否可以配在一起。由没有联结条件的表关系返回的结果为<strong>笛卡儿积</strong>。</p><blockquote><p>笛卡尔积：检索出的<strong>行的数目</strong>将是<strong>第一个表中的行数乘以第二个表中的行数</strong>。</p></blockquote><p>  有时我们会听到返回称为<strong>叉联结（cross join）</strong>的笛卡儿积的联结类型。</p></li></ul><hr><h4 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h4><p>目前上述的联结称为<strong>等值联结（equijoin）</strong>，它基于两个表之间的相等测试，也称为<strong>内部联结</strong>。</p><p>下面的SELECT语句返回与前面例子完全相同的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id = products.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure><ul><li>这里，两个表之间的关系是FROM子句的组成部分，以<strong>INNER JOIN</strong>指定。在使用这种语法时，<strong>联结条件</strong>用特定的<strong>ON子句</strong>而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</li><li>ANSI SQL规范<strong>首选INNER JOIN语法</strong>。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</li></ul><hr><h4 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h4><ul><li>MySQL在运行时<strong>关联指定的每个表以处理联结。这种处理可能是非常耗费资源的</strong>，因此应该仔细，不要联结不必要的表。联<strong>结的表越多，性能下降越厉害</strong>。</li></ul><hr><h2 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h2><ul><li><p>给列起<strong>别名</strong>的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name), <span class="string">' ('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">') '</span>) <span class="keyword">AS</span></span><br><span class="line">vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure></li><li><p>别名除了用于<strong>列名</strong>和<strong>计算字段</strong>外，SQL还允许<strong>给表名起别名</strong>。这样做有两个主要理由：</p><ol><li><p>缩短SQL语句</p></li><li><p>允许在<strong>单条</strong>SELECT语句中<strong>多次使用</strong>相同的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line"><span class="keyword">AND</span> oi.order_num = o.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><strong>表别名</strong>只在<strong>查询</strong>执行中使用。与列别名不一样，<strong>表别名不返回到客户机</strong>。</li></ul><hr><h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><ul><li><p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。</p><ul><li>方法一（<strong>子查询</strong>）:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = (<span class="keyword">SELECT</span> vend_id</span><br><span class="line">                <span class="keyword">FROM</span> products</span><br><span class="line">                <span class="keyword">WHERE</span> prod_id = <span class="string">'DTNTR'</span>);</span><br></pre></td></tr></table></figure><ul><li>方法二(联结)：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id = p2.vend_id</span><br><span class="line"><span class="keyword">AND</span> p2.prod_id = <span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure><p> 此查询中需要的<strong>两个表实际上是相同的表</strong>，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有<strong>二义性</strong>，因为MySQL不知道你引用的是products表中的哪个实例。为解决此问题，使用了表别名。</p></li><li><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候<strong>处理联结远比处理子查询快得多</strong>。应该试一下两种方法，以确定哪一种的性能更好。</p></li></ul><hr><h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><ul><li><p>标准的<strong>内部联结</strong>返回<strong>所有数据</strong>，甚至<strong>相同的列多次出现</strong>。<strong>自然联结排除多次出现，使每个列只返回一次</strong>。</p></li><li><p>自然联结是这样一种联结，其中你<strong>只能选择那些唯一的列</strong>。这一般是通过对表使用通配符（<strong>SELECT *</strong>），对所有其他表的列使用明确的子集来完成的。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.*, o.order_num, o.order_date,</span><br><span class="line">oi.prod_id, oi.quality, oi.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line"><span class="keyword">AND</span> oi.order_num = o.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id = <span class="string">'FB'</span>;</span><br></pre></td></tr></table></figure></li><li><p>事实上，<strong>迄今为止我们建立的每个内部联结都是自然联结</strong>，很可能我们永远都不会用到不是自然联结的内部联结。</p></li></ul><hr><h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><ul><li><p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。</p><ul><li><p>下面的SELECT语句给出一个简单的<strong>内部联结</strong>。它检索所有客户及其订单(<strong>不包括没有订单的客户</strong>)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure></li><li><p><strong>外部联结</strong>语法类似。为了检索素有客户(<strong>包括没有订单的客户</strong>)，可如下进行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure><p>这条SELECT语句使用了关键字<strong>OUTER JOIN</strong>来<strong>指定联结的类型</strong>（而不是在WHERE子句中指定）</p></li></ul></li><li><p>在使用<strong>OUTER JOIN</strong>语法时，必须使用<strong>RIGHT</strong>或<strong>LEFT</strong>关键字<strong>指定包括其所有行的表</strong>（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）</p></li><li><p>外部联结的<strong>OUTER可省略</strong></p></li><li><p>MySQL<strong>不支持</strong>简化字符<code>*=</code>和<code>=*</code>的使用，这两种操作符在其他DBMS中是很流行的。</p></li><li><p>如果要<strong>检索所有客户及每个客户所下的订单数</strong>，下面使用了<strong>COUNT()函数</strong>的代码可完成此工作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name,</span><br><span class="line">customers.cust_id,</span><br><span class="line"><span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h3><ul><li><p>有必要汇总一下关于联结及其使用的某些要点：</p><ul><li><p>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</p></li><li><p>应该总是<strong>提供联结条件</strong>，否则会得出笛卡儿积。</p></li><li><p>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</p></li></ul></li></ul><h2 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h2><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><ul><li><p>MySQL也允许<strong>执行多个查询</strong>（多条SELECT语句），并<strong>将结果作为单个查询结果集返回</strong>。这些<strong>组合查询</strong>通常称为<strong>并（union）</strong>或<strong>复合查询（compound query）</strong>。</p></li><li><p>有两种基本情况，其中需要使用组合查询：</p><ol><li>在<strong>单个查询中</strong>从<strong>不同的表</strong>返回<strong>类似结构</strong>的数据；</li><li>对<strong>单个表</strong>执行<strong>多个查询</strong>，<strong>按单个查询返回数据</strong>。</li></ol></li><li><strong>任何具有多个WHERE子句的SELECT语句</strong>都可以作为<strong>一个组合查询</strong>给出，在以下段落中可以看到这一点。<strong>这两种技术在不同的查询中性能也不同</strong>。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。</li></ul><hr><h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><p>可用<strong>UNION操作符</strong>来<strong>组合数条SQL查询</strong>。<strong>利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集</strong>。</p><h4 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h4><ul><li><p>UNION的使用很简单，<strong>只需给出每条SELECT语句，在各条语句之间放上关键字UNION</strong>。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure><p>结果：</p><p>| vend_id | prod_id | prod_price |<br>| ——- | ——- | ———- |<br>| 1003    | FC      | 2.50       |<br>| 1002    | FU1     | 3.42       |<br>| 1003    | SLING   | 4.49       |<br>| 1003    | TNT1    | 2.50       |<br>| 1001    | ANV01   | 5.99       |<br>| 1001    | ANV02   | 9.99       |<br>| 1001    | ANV03   | 14.99      |<br>| 1002    | OL1     | 8.99       |</p><p>UNION指示MySQL执行两条SELECT语句，并<strong>把输出组合成单个查询结果集</strong>。</p><p>作为参考，这里给出使用多条WHERE子句而不是使用UNION的相同查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">OR</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure><p>这个简单的例子中，<strong>使用UNION可能比使用WHERE子句更为复杂</strong>。但对于<strong>更复杂的过滤条件</strong>，或者<strong>从多个表中检索数据</strong>的情形，<strong>使用UNION可能会使处理更简单</strong>。</p></li></ul><hr><h4 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h4><ul><li><p>UNION必须由<strong>两条或两条以上的SELECT语句组成</strong>，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。</p></li><li><p>UNION中<strong>每个查询必须包含相同的列、表达式或聚集函数</strong>（不过各个列<strong>不需要以相同的次序列出</strong>）。</p></li><li><p>列数据类型必须<strong>兼容</strong>。类型不必完全相同，但必须是DBMS可以隐含地转换的类型(如<strong>不同的数值类型</strong>或<strong>不同的日期类型</strong>)。</p></li></ul><hr><h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><ul><li><p><strong>UNION从查询结果集中自动去除了重复的行</strong>（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。</p></li><li><p>如果<strong>想返回所有匹配行</strong>，可<strong>使用UNION ALL</strong>而不是UNION。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>UNION ALL为UNION的一种形式，它完成WHERE子句完成不了的工作</strong>。如果确实需要每个条件的匹配行全部出现（包括<strong>重复行</strong>），则必须使用UNION ALL而不是WHERE。</p></li></ul><hr><h4 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h4><ul><li>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后<strong>。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句</strong>。</li></ul><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="MySQL创建索引"><a href="#MySQL创建索引" class="headerlink" title="MySQL创建索引"></a>MySQL创建索引</h3><h4 id="索引的介绍"><a href="#索引的介绍" class="headerlink" title="索引的介绍"></a>索引的介绍</h4><p>索引是一种数据结构，例如B-Tree，这种数据结构是需要<strong>额外的写入和存储为代价</strong>来<strong>提高表上数据检索的速度</strong>。</p><p>其中，当使用<strong>主键或唯一键</strong>创建表时，MySQL会<strong>自动创建名为PRIMARY的特殊索引</strong>, 该索引称为<strong>聚簇索引</strong>，<strong>这个索引本身与数据一起存储在同一个表中</strong>。<strong>PRIMARY索引之外的</strong>索引称为<strong>二级索引</strong>或<strong>非聚簇索引</strong>。</p><hr><h4 id="CREATE-INDEX语句"><a href="#CREATE-INDEX语句" class="headerlink" title="CREATE INDEX语句"></a>CREATE INDEX语句</h4><ul><li><p>通常，<strong>创建表的时候就能为表创建索引</strong>：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(</span><br><span class="line">   c1<span class="built_in">INT</span>PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">   c2<span class="built_in">INT</span><span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   c3<span class="built_in">INT</span><span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   c4<span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">   <span class="keyword">INDEX</span> (c2,c3)  <span class="comment"># 创建了由c2、c3两列组成的索引</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>要为列或一组列<strong>添加索引</strong>，可以使用<code>CREATE INDEX</code>语句：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list)</span><br></pre></td></tr></table></figure></li><li><p>默认情况下，如果<strong>未指定索引类型</strong>，MySQL将<strong>创建B-Tree索引</strong>。 以下显示了基于表的存储引擎的允许索引类型：</p><p>  | 存储引擎    | 允许的索引类型 |<br>  | ———– | ————– |<br>  | InnoDB      | BTREE          |<br>  | MyISAM      | BTREE          |<br>  | MEMORY/HEAP | HASH, BTREE    |</p></li></ul><hr><p><strong>举例</strong></p><p>查找职位为Sales Rep的员工：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> jobTitle <span class="keyword">ON</span> employees(jobTitle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employeeNumber, lastName, firstName</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> jobTitle = <span class="string">'Sales Rep'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="MySQL删除索引"><a href="#MySQL删除索引" class="headerlink" title="MySQL删除索引"></a>MySQL删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> tabel_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> PRIMARY <span class="keyword">ON</span> tabel_name; <span class="comment"># 删除索引名为PRIMARY的主键</span></span><br></pre></td></tr></table></figure><hr><h3 id="MySQL查询索引信息"><a href="#MySQL查询索引信息" class="headerlink" title="MySQL查询索引信息"></a>MySQL查询索引信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEXES</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>会得到一张二维表，各表列分别为：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>Table</td><td>表名</td></tr><tr><td>Non_unique</td><td><strong>0</strong>：索引<strong>不能包括</strong>重复值<br><strong>1</strong>：索引<strong>可以包括</strong>重复值</td></tr><tr><td>Key_name</td><td>索引名称。<strong>如果名称相同，表明属于同一个索引，而不是重复</strong>。</td></tr><tr><td>Seq_in_index</td><td>索引中的列序列号，<strong>从1开始</strong></td></tr><tr><td>Column_name</td><td>索引的列名</td></tr><tr><td>Collation</td><td>以什么方式存储于索引中</td></tr><tr><td>Cardinality</td><td>基数，表示索引中<strong>唯一值的数目的估计值</strong>。某个字段的<strong>重复值越少越适合建索引</strong>，所以<strong>一般根据Cardinality来判断索引是否具有高选择性</strong></td></tr><tr><td>Sub_part</td><td>如果列只是被部分地编入索引，则为被编入索引的字符的数目。<br>如果整列被编入索引，则为NULL。</td></tr><tr><td>Packed</td><td>指示关键字如何被压缩。如果没有被压缩，则为NULL。压缩一般包括压缩传输协议、压缩列解决方案和压缩表解决方案。</td></tr><tr><td>Null</td><td>如果列<strong>含有NULL，则为YES</strong></td></tr><tr><td>Index_type</td><td>索引类型，Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。</td></tr><tr><td>Comment Index_comment</td><td>注释</td></tr></tbody></table><hr><h3 id="使用唯一索引，避免重复"><a href="#使用唯一索引，避免重复" class="headerlink" title="使用唯一索引，避免重复"></a>使用唯一索引，避免重复</h3><p>为了使一列或多列具有唯一性，通常使用PRIMARY KEY约束。，但<strong>每个表只能有一个主键</strong>。 因此，<strong>如果使多个列或多个组合列具有唯一性，则不能使用主键约束</strong>。</p><p>MySQL提供了另一种索引，叫做<strong>唯一索引</strong>，允许我们<strong>一个或者多个列的值具有唯一性</strong>。且<strong>每张表中可以有很多个唯一索引</strong>。</p><ol><li><p><strong>创建唯一索引</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> tabel_name(index_column_1, index_column_1, ...);</span><br></pre></td></tr></table></figure></li><li><p><strong>添加唯一索引</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name( column_1,column_2 ) ;</span><br></pre></td></tr></table></figure><p> <strong>有一点值得注意:</strong><br> 与其他数据库系统不同，MySQL<strong>将NULL值视为不同的值</strong>，<strong>所以可以在唯一索引中包含很多的空值</strong>。另一个重点是<strong>UNIQUE约束不适用于InnoDB存储引擎之外的NULL值</strong>。</p></li></ol><hr><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设我们要管理应用程序中的联系人，并且还希望联系人表的每个联系人的<strong>电子邮件必须唯一</strong>，可以使用<code>CREATE TABLE</code>语句<strong>创建唯一约束</strong>来满足我们的需求：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> contacts (</span><br><span class="line">    <span class="keyword">id</span><span class="built_in">INT</span>AUTO_INCREMENTPRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    first_name<span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone <span class="built_in">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">Index</span> unique_email (email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>假设我们要一个<strong>first_name</strong>、<strong>last_name</strong>、<strong>phone</strong>的联合索引，我们可以使用下面的语法来得到：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idx_name_phone</span><br><span class="line"><span class="keyword">ON</span> contacts(first_name,last_name, phone);</span><br></pre></td></tr></table></figure><hr><h3 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h3><ol><li>主键(PRIMARY KEY)<strong>自动建立唯一索引</strong></li><li>存在<strong>频繁作为查询条件的字段</strong>，应该创建索引</li><li>查询中与其他表关联的字段，<strong>外键关系建立索引</strong></li><li><strong>频繁更新</strong>的字段<strong>不适合建立索引</strong>，因为每次更新不单单时更新了记录还会更新索引</li><li>WHERE条件里<strong>用不到的字段不创建索引</strong></li><li>查询中排序的字段，<strong>排序的字段若通过索引去访问将会大大提高排序速度</strong></li><li>查询中<strong>统计或者分组的字段</strong></li></ol><hr><h3 id="强制索引"><a href="#强制索引" class="headerlink" title="强制索引"></a>强制索引</h3><p><strong>FORCE INDEX</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> salaries </span><br><span class="line"><span class="keyword">FORCE</span> <span class="keyword">INDEX</span> idx_emp_no <span class="comment">-- idx_emp_no 是预设的索引</span></span><br><span class="line"><span class="keyword">WHERE</span> emp_no = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h2><h3 id="理解全文本搜索"><a href="#理解全文本搜索" class="headerlink" title="理解全文本搜索"></a>理解全文本搜索</h3><p>MySQL支持几种<strong>基本的数据库引擎</strong>。<strong>并非所有的引擎都支持本书所描述的全文本搜索</strong>。两个最常使用的引擎为<strong>MyISAM</strong>和<strong>InnoDB</strong>，<strong>前者支持全文本搜索，而后者不支持</strong>。</p><p><strong>第8章和第9章介绍LIKE和正则表达式的搜索机制，存在几个重要的限制</strong>：</p><ul><li><p><strong>性能</strong></p><p>  <strong>通配符</strong>和<strong>正则表达式匹配</strong>通常要求MySQL尝试<strong>匹配表中所有行</strong>（而且这些搜索<strong>极少使用表索引</strong>）。因此，<strong>由于被搜索行数不断增加，这些搜索可能非常耗时</strong>。</p></li><li><p><strong>明确控制</strong></p><p>  使用通配符和正则表达式匹配，<strong>很难（而且并不总是能）明确地控制匹配什么和不匹配什么</strong>。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。</p></li><li><p>智能化的结果</p><p>  虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都<strong>不能提供一种智能化的选择结果的方法</strong>。例如，一个特殊词的搜索将会返回包含该词的所有行，而<strong>不区分包含单个匹配的行和包含多个匹配的行</strong>。</p></li></ul><p>以上的限制都可以<strong>通过全文本搜索来解决</strong>。在使用全文本搜索时，<strong>MySQL不需要分别查看每个行，不需要分别分析和处理每个词</strong>。MySQL<strong>创建指定列中各词的一个索引</strong>，<strong>搜索可以针对这些词进行</strong>。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。</p><hr><h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><p>为了进行全文本搜索，<strong>必须索引被搜索的列</strong>，而且<strong>要随着数据的改变不断地重新索引</strong>。<strong>在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引</strong>。</p><h4 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h4><p>一般<strong>在创建表时启用全文本搜索</strong>。<code>CREATE TABLE</code>语句（第21章中介绍）接受<code>FULLTEXT</code>子句，它<strong>给出被索引列的一个逗号分隔的列表</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes(</span><br><span class="line">note_id<span class="built_in">int</span><span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    prod_id<span class="built_in">char</span>(<span class="number">10</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    note_datedatetime<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    note_text<span class="built_in">text</span><span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure><ul><li><p><code>FULLTEXT</code><strong>可以索引多个列</strong></p></li><li><p>在定义之后，MySQL<strong>自动维护该索引</strong>。<strong>在增加、更新或删除行时，索引随之自动更新</strong>。</p></li><li><p>可以在创建表时指定FULLTEXT，或者<strong>在稍后指定（在这种情况下所有已有数据必须立即索引）</strong>。</p></li></ul><p><strong>不要在导入数据时使用FULLTEXT</strong></p><p>​    如果<strong>正在导入数据</strong>到一个新表，此时<strong>不应该启用FULLTEXT索引</strong>。应该<strong>先导入所有数据，再修改表，定义FULLTEXT</strong>。这样有助于更快地导入数据(而且使索引数据的总时间小于在导入每行时分别进行索引所需的总时间)。</p><hr><h4 id="进行全文本搜索"><a href="#进行全文本搜索" class="headerlink" title="进行全文本搜索"></a>进行全文本搜索</h4><p>在索引之后，使用两个函数<code>Match()</code>和<code>Against()</code>执行全文本搜索，其中<code>Match()</code><strong>指定被搜索的列</strong>，<code>Against()</code><strong>指定要使用的搜索表达式</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>此SELECT语句检索单个列<code>note_text</code>。由于WHERE子句，一个全文本搜索被执行。</p></li><li><p>传递给<code>Match()</code>的值必须与<code>FULLTEXT()</code>定义中的相同。<strong>如果指定多个列，则必须列出它们（而且次序正确）</strong>。</p></li><li><p>除非使用<strong>BINARY</strong>方式（本章中没有介绍），否则<strong>全文本搜索不区分大小写</strong>。</p></li></ul><p>上述搜索也可以简单地用LIKE子句完成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> note_text <span class="keyword">LIKE</span> <span class="string">'%rabbit%'</span>;</span><br></pre></td></tr></table></figure><p>两种方式都没有使用ORDER BY子句。<strong>LIKE子句以不特别有用的顺序返回数据</strong>；而<strong>使用全文本搜索</strong>会返回<strong>以文本匹配的良好程度排序</strong>的数(<strong>搜索的内容出现的位置越靠前，等级越高</strong>)，<strong>全文本搜索的一个重要部分就是对结果排序</strong>。</p><ul><li>由于<strong>数据是索引的，全文本搜索还相当快</strong>。</li></ul><hr><h4 id="使用查询扩展-QUERY-EXPANSION"><a href="#使用查询扩展-QUERY-EXPANSION" class="headerlink" title="使用查询扩展(QUERY EXPANSION)"></a>使用查询扩展(QUERY EXPANSION)</h4><p>查询扩展用来设法<strong>放宽所返回的全文本搜索结果的范围</strong>。</p><p>如下情况：你想<strong>找出所有提到anvils的注释</strong>，但<strong>还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils</strong>。</p><p>在使用查询扩展时，MySQL<strong>对数据和索引进行两遍扫描</strong>来完成搜索：</p><ul><li>首先，进行一个<strong>基本的全文本搜索</strong>，找出<strong>与搜索条件匹配的</strong>所有行</li><li>其次，MySQL<strong>检查这些匹配行并选择所有有用的词</strong>（我们将会简要地解释MySQL如何断定什么有用，什么无用）。</li><li>再其次，MySQL<strong>再次进行全文本搜索</strong>，这次<strong>不仅使用原来的条件，而且还使用所有有用的词</strong>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'anvils'</span> <span class="keyword">WITH</span> <span class="keyword">QUERY</span> EXPANSION);</span><br></pre></td></tr></table></figure><p><strong>表中的行越多（这些行中的文本就越多），使用查询扩展返回的结果越好</strong>。</p><hr><h4 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h4><p>MySQL支持<strong>全文本搜索的另外一种形式</strong>，称为<strong>布尔方式（BOOLEAN MODE）</strong>。以布尔方式，可以提供关于如下内容的细节：</p><ol><li>要匹配的词；</li><li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</li><li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）;</li><li>表达式分组；</li><li>另外一些内容。</li></ol><ul><li><strong>即使没有定义FULLTEXT索引，也可以使用它</strong>。但<strong>这是一种非常缓慢的操作</strong>（其性能将随着数据量的增加而降低）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'heavy'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure><p>此全文本搜索检索包含词heavy的所有行。使用了<code>IN BOOLEAN MODE</code>，但没有指定布尔操作符，因此结果与没有指定布尔方式的操作相同。</p><ul><li><p>为了匹配包含heavy但<strong>不包含</strong> <strong>任意以rope开始的词</strong>的行，可使用以下查询：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'heavy -rope*'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>全文本布尔操作符</strong>：</p><table><thead><tr><th>布尔操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>+</code></td><td>包含，词<strong>必须存在</strong></td></tr><tr><td><code>-</code></td><td>排除，词<strong>必须不出现</strong></td></tr><tr><td><code>&gt;</code></td><td>包含，且<strong>增加等级值</strong></td></tr><tr><td><code>&lt;</code></td><td>包含，且<strong>减少等级值</strong></td></tr><tr><td><code>()</code></td><td>把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td><code>~</code></td><td><strong>取消</strong>一个词的<strong>排序值</strong></td></tr><tr><td><code>*</code></td><td><strong>词尾</strong>的<strong>通配符</strong></td></tr><tr><td><code>&quot;&quot;</code></td><td>定义一个<strong>短语</strong>(匹配一个短语，以便包含或排除这个短语)</td></tr></tbody></table><p>例1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'+rabbit +bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>); <span class="comment"># 匹配包含词rabbit和bait的行</span></span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>); <span class="comment"># 匹配包含词rabbit和bait中至少一个词的行</span></span><br></pre></td></tr></table></figure><p>例3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'"rabbit bait"'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>); <span class="comment"># 匹配短语rabbit bait</span></span><br></pre></td></tr></table></figure><p>例4：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'&gt;rabbit &lt;bait"'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>); <span class="comment"># 匹配包含词rabbit和bait的行，增加前者等级，降低后者等级</span></span><br></pre></td></tr></table></figure><p>例5：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'+safe +(&lt;combination)'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>); <span class="comment"># 匹配词safe和combination的行，且降低后者的等级</span></span><br></pre></td></tr></table></figure><p><strong>在布尔方式中，不按等级值降序排序返回的行。</strong></p><hr><h4 id="全文本搜索的使用说明"><a href="#全文本搜索的使用说明" class="headerlink" title="全文本搜索的使用说明"></a>全文本搜索的使用说明</h4><ol><li>索引全文本数据时，<strong>短词会被忽略且从索引中排除</strong>。(短词：只有<strong>3个及以下字符</strong>的词，如果需要，这个数目可以更改)</li><li>MySQL带有一个<strong>内建的非用词（stopword）列表</strong>，这些词<strong>在索引全文本数据时总是被忽略</strong>。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）</li><li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条<strong>50%规则</strong>，如果<strong>一个词出现在50%以上的行中，则将它作为一个非用词忽略</strong>。<strong>50%规则不用于IN BOOLEAN MODE</strong>。</li><li>如果表中的<strong>行数少于3行</strong>，则全文本搜索<strong>不返回结果</strong>（因为每个词或者不出现，或者至少出现在50%的行中）。</li><li><strong>忽略</strong>词中的<strong>单引号</strong>。例如，<strong>don’t索引为dont</strong>。</li><li><strong>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果</strong>。</li><li>如前所述，仅在<strong>MyISAM数据库引擎</strong>中<strong>支持全文本搜索</strong></li></ol><hr><h2 id="SQL语句的查询顺序"><a href="#SQL语句的查询顺序" class="headerlink" title="SQL语句的查询顺序"></a>SQL语句的查询顺序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">column</span>, AGG_FUNC(column_or_expression), …</span><br><span class="line"><span class="keyword">FROM</span> mytable <span class="keyword">JOIN</span> another_table</span><br><span class="line"><span class="keyword">ON</span> mytable.column = another_table.column</span><br><span class="line"><span class="keyword">WHERE</span> constraint_expression</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">column</span></span><br><span class="line"><span class="keyword">HAVING</span> constraint_expression</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">ASC</span>/<span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="keyword">count</span> <span class="keyword">OFFSET</span> <span class="keyword">COUNT</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>执行顺序</th><th>语句</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>FROM、JOIN</td><td><strong>获取数据集</strong></td></tr><tr><td>2</td><td>WHERE</td><td>过滤数据</td></tr><tr><td>3</td><td>GROUP BY</td><td>根据某一字段进行分组，并<strong>对各个组进行求聚合</strong></td></tr><tr><td>4</td><td>HAVING</td><td>过滤<strong>聚合后的</strong>数据</td></tr><tr><td>5</td><td>SELECT</td><td>返回最终数据</td></tr><tr><td>6</td><td>DISTINCT</td><td>为最终数据去重</td></tr><tr><td>7</td><td>ORDER BY</td><td>为最终数据排序</td></tr><tr><td>8</td><td>LIMIT/OFFSET</td><td>限定最终数据的返回行，也可理解为<strong>分页查询</strong><br>（如：<code>LIMIT 4 OFFSET 3</code>意为<strong>从行3开始取4行</strong>）</td></tr></tbody></table><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察这种写法的问题</span></span><br><span class="line"><span class="keyword">SELECT</span> country, <span class="keyword">SUM</span>(area) </span><br><span class="line"><span class="keyword">FROM</span> country_data</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SUM</span>(area) &gt; <span class="number">1000</span> <span class="comment"># GROUP BY还没执行，无法获取聚合值</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> country;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="keyword">SELECT</span> country, <span class="keyword">SUM</span>(area) </span><br><span class="line"><span class="keyword">FROM</span> country_data</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> country</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(area) &gt; <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="CASE语句"><a href="#CASE语句" class="headerlink" title="CASE语句"></a>CASE语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE</span><br><span class="line">    WHEN condition1 THEN result1</span><br><span class="line">    WHEN condition2 THEN result2</span><br><span class="line">    WHEN conditionN THEN resultN</span><br><span class="line">    ELSE result</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> salary</span><br><span class="line"><span class="keyword">SET</span> sex =  <span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> sex = <span class="string">'m'</span> <span class="keyword">THEN</span> <span class="string">'f'</span></span><br><span class="line">                <span class="keyword">WHEN</span> sex = <span class="string">'f'</span> <span class="keyword">THEN</span> <span class="string">'m'</span></span><br><span class="line">           <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>作用和IF表达式相当</strong>。</p><hr><h2 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h2><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><ul><li><strong>INSERT语句</strong>用来插入行到数据库表。插入可以用几种方式使用：<ul><li>插入完整的行</li><li>插入行的一部分</li><li>插入多行</li><li>插入某些查询的结果</li></ul></li></ul><hr><h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><ul><li><p>INSERT语句<strong>要求指定表名</strong>和<strong>被插入到新行中的值</strong>。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="literal">NULL</span>,</span><br><span class="line">      <span class="string">'Pep E. LaPew'</span>,</span><br><span class="line">       <span class="string">'100 Main Street'</span>,</span><br><span class="line">       <span class="string">'Los Angeles'</span>,</span><br><span class="line">       <span class="string">'CA'</span>,</span><br><span class="line">       <span class="string">'90046'</span>,</span><br><span class="line">       <span class="string">'USA'</span>,</span><br><span class="line">       <span class="literal">NULL</span>,</span><br><span class="line">       <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>存储到每个表列中的数据在<strong>VALUES子句</strong>中给出，对<strong>每个列必须提供一个值</strong>，<strong>各个列必须以在表定义中出现的次序填充</strong>。如果某个列没有值，应该使用NULL值（假定表允许对该列指定空值）。<strong>第一列cust_id也为NULL(每次插入一个新行时，该列由MySQL自动增量，NULL值会被MySQL忽略)</strong>。</p><p>虽然这种语法很简单，但<strong>并不安全，应该尽量避免使用</strong>。上面的SQL语句高度依赖于表中列的定义次序。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。</p></li><li><p>INSERT语句一般<strong>不会产生输出</strong>。</p></li><li><p>一般<strong>不要使用没有明确给出列的列表的INSERT语句</strong>。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。</p></li><li><p>不管使用哪种INSERT语法，都必须给出VALUES的正确数目</p><ul><li>如果<strong>不提供列名</strong>，则必须给每个表列提供一个值</li><li>如果<strong>提供列名</strong>，则必须对<strong>每个列出的列</strong>提供一个值</li></ul></li><li><p>省略的列必须满足以下某个条件。</p><ol><li>该<strong>列</strong>定义为<strong>允许NULL值</strong>。</li><li>在<strong>表定义中给出默认值</strong>。这表示如果不给出值，将使用默认值。</li></ol><p>如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</p></li><li><p><strong>INSERT操作可能很耗时，而且可能降低等待处理的SELECT语句的性能</strong>。如果<strong>数据检索是最重要的</strong>（通常是这样），则你可以通过<strong>在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级</strong>，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">LOW</span> <span class="keyword">PRIORITY</span> <span class="keyword">INTO</span> ...</span><br></pre></td></tr></table></figure><p>这<strong>也适用于</strong>下一章介绍的<strong>UPDATE和DELETE语句</strong>。</p></li></ul><hr><h3 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h3><ul><li><p>如果想<strong>插入多个行</strong>：</p><ol><li><p>可以使用<strong>多条INSERT语句</strong>，甚至<strong>一次提交</strong>它们，<strong>每条语句用一个分号结束</strong>。</p></li><li><p>只<strong>要每条INSERT语句中的列名(和次序)相同</strong>，可以用<strong>单条INSERT语句</strong>插入多组值，<strong>每组值用一对圆括号括起来，用逗号分隔</strong>。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country)</span><br><span class="line"><span class="keyword">VALUES</span>(</span><br><span class="line"><span class="string">'Pep E. LaPew'</span>,</span><br><span class="line">    <span class="string">'100 Main Street'</span>,</span><br><span class="line">    <span class="string">'Los Angeles'</span>,</span><br><span class="line">    <span class="string">'CA'</span>,</span><br><span class="line">    <span class="string">'90046'</span>,</span><br><span class="line">    <span class="string">'USA'</span></span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line">    <span class="string">'M. Martian'</span>,</span><br><span class="line">        <span class="string">'42 Galaxy Way'</span>,</span><br><span class="line">        <span class="string">'New York'</span>,</span><br><span class="line">        <span class="string">'NY'</span>,</span><br><span class="line">        <span class="string">'11213'</span>,</span><br><span class="line">        <span class="string">'USA'</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>单条INSERT语句处理多个插入比使用多条INSERT语句快</strong>。</p></li></ul><hr><h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><ul><li><p>INSERT还存在另一种形式，可以利用它<strong>将一条SELECT语句的结果插入表中</strong>。这就是所谓的<strong>INSERT SELECT</strong>。</p><p>假如你想<strong>从另一表中合并客户列表到你的customers表</strong>，可以如下进行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(cust_id,</span><br><span class="line">                      cust_contact,</span><br><span class="line">                      cust_email,</span><br><span class="line">                      cust_name)</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,</span><br><span class="line">cust_contact,</span><br><span class="line">cust_email,</span><br><span class="line">cust_name</span><br><span class="line"><span class="keyword">FROM</span> custnew;</span><br></pre></td></tr></table></figure></li><li><p>MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等</p></li><li><p><strong>如果目标表不存在，插入数据的方式</strong>：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> value1, value2</span><br><span class="line"><span class="keyword">INTO</span> table2 <span class="comment"># 目标表table2不存在，因此插入的时候自动创建目标表</span></span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><ul><li><p>为了更新(修改)表中的数据，可使用UPDATE语句。可采用两种方式使用UPDATE：</p><ol><li>更新表中<strong>特定行</strong></li><li>更新表中<strong>所有行</strong></li></ol></li><li><p>基本的UPDATE语句由3部分组成</p><ol><li>要更新的表</li><li>列名和它们的新值</li><li>确定要更新行的<strong>过滤条件</strong></li></ol><p>例如，客户10005现在有了电子邮件地址，需要更新记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_email = <span class="string">'elmer@fudd.com'</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure><p><strong>SET命令用来将新值赋给被更新的列</strong>。</p></li><li><p>UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行。<strong>没有WHERE子句</strong>，MySQL将会<strong>更新customers表中所有行</strong>。</p></li><li><p>更新多个列的语法稍有不同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_name = <span class="string">'The Fudds'</span>,</span><br><span class="line">cust_email = <span class="string">'elmer@fudd.com'</span></span><br><span class="line"><span class="keyword">WHERE</span> cust <span class="keyword">id</span> = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure><p><strong>更新多个列只需使用单个SET命令</strong>，<strong>每个“列=值”对之间用逗号分隔</strong>。</p></li><li><p>UPDATE语句中可以使用<strong>子查询</strong>。</p></li><li><p><strong>IGNORE关键字</strong></p><p>如果用UPDATE语句<strong>更新多行</strong>，并且这些行中的一行或者多行<strong>出现一个错误，整个UPDATE操作会被取消</strong>。如果<strong>希望即使发生错误也继续更新</strong>，可使用<strong>IGNORE关键字</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">IGNORE</span> customers ...</span><br></pre></td></tr></table></figure></li><li><p>为了<strong>删除某个列的值，可设置其为NULL</strong>(前提表定义允许NULL值)。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_email = <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><h5 id="用一张表的记录去更新另一张表的记录"><a href="#用一张表的记录去更新另一张表的记录" class="headerlink" title="用一张表的记录去更新另一张表的记录"></a>用一张表的记录去更新另一张表的记录</h5>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> A</span><br><span class="line"><span class="keyword">SET</span> A.Name = B.Name, </span><br><span class="line">A.Sex = B.Sex</span><br><span class="line"><span class="keyword">FROM</span> A,B</span><br><span class="line"><span class="keyword">WHERE</span> A.ID = B.ID;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li>为了从一个表中<strong>删除数据</strong>，使用<strong>DELETE语句</strong>。可以通过两种方式使用DELETE：<ol><li>从表中删除<strong>特定的行</strong></li><li>从表中删除<strong>所有行</strong></li></ol></li><li><p>DELETE语句以WHERE子句结束，它告诉MySQL删除哪一行。<strong>没有WHERE子句</strong>，MySQL将会<strong>删除表中所有行</strong>。</p></li><li><p>DELETE<strong>不需要列名或通配符</strong>。DELETE<strong>删除整行</strong>而不是删除列。<strong>为了删除指定的列，请使用UPDATE语句</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10006</span>;</span><br></pre></td></tr></table></figure></li><li><p>DELETE<strong>不删除表本身</strong>。</p></li><li><p><strong>更快的删除</strong></p><p>ruu过<strong>想删除表中所有行，不要使用DELETE</strong>。可使用<strong>TRUNCATE TABLE语句</strong>，<strong>它完成相同的工作，但速度更快</strong>（<strong>TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据</strong>）。</p></li></ul><hr><h3 id="更新和删除的指导原则"><a href="#更新和删除的指导原则" class="headerlink" title="更新和删除的指导原则"></a>更新和删除的指导原则</h3><ul><li>除非确实打算更新和删除每一行，否则<strong>一定要带WHERE子句</strong></li><li><strong>保证每个表都有主键</strong>，从而能通过WHERE子句指定唯一的列。</li><li>在对UPDATE或DELETE语句<strong>使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确</strong>。、</li><li>使用<strong>强制实施引用完整性的数据库</strong>（15章），这样MySQL<strong>将不允许删除具有与其他表相关联的数据的行</strong>。</li><li><strong>MySQL没有撤销（undo）按钮</strong>。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。</li></ul><hr><h2 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><ul><li>为了用程序创建表，可使用SQL的<strong>CREATE TABLE语句</strong>。</li></ul><h4 id="表创建基础"><a href="#表创建基础" class="headerlink" title="表创建基础"></a>表创建基础</h4><ul><li><p>为利用CREATE TABLE创建表，必须给出下列信息：</p><ul><li><strong>新表的名字</strong>，在<strong>关键字CREATE TABLE之后</strong>给出；</li><li>表<strong>列的名字和定义</strong>在<strong>圆括号之中</strong>，各列之间<strong>用逗号分隔</strong>；</li><li><strong>每列的定义</strong>以<strong>列名开始</strong>，后跟<strong>列的数据类型</strong>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers</span><br><span class="line">(</span><br><span class="line">cust_id<span class="built_in">int</span><span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    cust_name<span class="built_in">char</span>(<span class="number">50</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    cust_address<span class="built_in">char</span>(<span class="number">50</span>)<span class="literal">NULL</span>,</span><br><span class="line">    cust_city<span class="built_in">char</span>(<span class="number">50</span>)<span class="literal">NULL</span>,</span><br><span class="line">    cust_state<span class="built_in">char</span>(<span class="number">5</span>)<span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (cust_id)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure></li><li><p>表的<strong>主键</strong>可以<strong>在创建表时用PRIMARY KEY关键字指定</strong>。这里，列cust_id指定作为主键列。<strong>整条语句由右圆括号后的分号结束</strong>。</p></li><li><p><strong>语句格式化</strong></p><p>MySQL语句中忽略空格。语句可以在一个长行上输入，也可以分成许多行。它们的作用都相同。<strong>对列定义进行恰当的缩进，以便阅读和编辑</strong>。</p></li><li><p><strong>创建新表时，指定的表名必须不存在</strong>，否则将出错。<strong>如果要防止意外覆盖已有的表，SQL要求首先手工删除该表</strong>（请参阅后面的小节），<strong>然后再重建它</strong>，而不是简单地用创建表语句覆盖它。<strong>如果仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS</strong>(<strong>并不检查已有表的模式是否与打算创建的表模式相匹配，只是查看表名是否存在</strong>，并且仅在表名不存在时创建它)。</p></li></ul><hr><h4 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h4><ul><li><p>每个表列或者是NULL列，或者是NOT NULL列，<strong>这种状态在创建时由表的定义规定</strong>。</p></li><li><p><strong>NULL为默认设置</strong>，<strong>如果不指定NOT NULL，则认为指定的是NULL</strong>。</p></li><li>进行查询时可通过<code>WHERE XXX IS NULL</code>或<code>WHERE XXX IS NOT NULL</code>进行筛选。</li></ul><hr><h4 id="主键再介绍"><a href="#主键再介绍" class="headerlink" title="主键再介绍"></a>主键再介绍</h4><ul><li><p><strong>主键值必须唯一</strong>。如果主键<strong>使用单个列</strong>，则<strong>它的值必须唯一</strong>；如果<strong>使用多个列</strong>，则<strong>这些列的组合值必须唯一</strong>。</p></li><li><p>为创建由<strong>多个列组成的主键</strong>，应该<strong>以逗号分隔的列表给出各列名</strong>。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">    order_num<span class="built_in">int</span><span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_item<span class="built_in">int</span><span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_id<span class="built_in">char</span>(<span class="number">10</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    quantity<span class="built_in">int</span><span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    item_price<span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (order_num, order_item)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p><strong>订单号（order_num列）和订单物品（order_item列）的组合是唯一的，从而适合作为主键</strong>。</p></li><li><p>主键可以<strong>在创建表时定义</strong>，或者<strong>在创建表之后定义</strong>。<strong>主键只能使用NOT NULL值的列</strong>，因为允许NULL值的列不能作为唯一标识。</p></li></ul><hr><h4 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h4><ul><li><p><strong>AUTO_INCREMENT</strong>告诉MySQL，<strong>本列每当增加一行时自动增量</strong>。每次执行一个<strong>INSERT操作</strong>时，MySQL<strong>自动对该列增量</strong>，赋予一下一个可用的值。这样能使得每个行被分配一个唯一的值，可以作为主键值。</p></li><li><p><strong>每个表只允许一个AUTO_INCREMENT列</strong>，<strong>而且它必须被索引</strong>（如，通过使它<strong>成为主键</strong>）。</p></li><li><p><strong>覆盖AUTO_INCREMENT</strong> </p><p>如果一个列被指定为AUTO_INCRE-MENT，则它需要使用特殊的值吗？你<strong>可以在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可</strong>，该值将被用来<strong>替代自动生成的值</strong>，<strong>后续的增量将开始使用该手工插入的值</strong>。</p></li><li><p><strong>确定AUTO_INCREMENT值</strong></p><p>让MySQL通过自动增量生成主键的一个缺点是<strong>你不知道这些值都是谁</strong>。</p><p>考虑这个场景：你正在增加一个新订单，这要求在orders表中创建一行，然后在orderitems表中对订购的每项物品创建一行。order_num在orderitems表中与订单细节一起存储。<strong>这显然要求你在插入orders行之后，插入orderitems行之前知道生成的order_num</strong>。</p><p>那么，<strong>如何在使用AUTO_INCREMENT列时获得这个值呢</strong>？可使用<strong>last_insert_id()函数</strong>获得这个值，如<code>SELECT_last_insert_id()</code>，<strong>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句</strong>。</p></li><li><p>更改<strong>自动增量的开始数和增幅</strong>(IDENTITY(a,b)`)</p><p>   <code>IDENTITY(a, b)</code>：</p><ul><li>a、b均为<strong>正整数</strong></li><li><p>a表示<strong>开始数</strong>，b表示<strong>增幅</strong></p><p>就像<code>IDENTITY(2,3)</code>，意思就是<strong>该列自动增长</strong>，由2开始，每次增加是3</p></li></ul></li></ul><hr><h4 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h4><ul><li><p>如果<strong>在插入行时没有给出值</strong>，MySQL<strong>允许指定此时使用的默认值</strong>。默认值用<strong>CREATE TABLE语句的列定义中的DEFAULT关键字指定</strong>。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">order_num<span class="built_in">INT</span><span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_item<span class="built_in">INT</span><span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_id<span class="built_in">CHAR</span>(<span class="number">10</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    quantity<span class="built_in">INT</span><span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">    item_price <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (order_num, order_item)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>此例子中，给该列的描述添加文本<strong>DEFAULT 1</strong>指示MySQL，<strong>在未给出数量的情况下使用数量1</strong>。</p></li><li><p>与大多数DBMS<strong>不一样</strong>，MySQL<strong>不允许使用函数作为默认值</strong>，它<strong>只支持常量</strong>。</p></li><li><p>许多数据库开发人员<strong>使用默认值而不是NULL列</strong>，特别是对<strong>用于计算或数据分组的列更是如此</strong>。</p></li></ul><hr><h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h4><ul><li>迄今为止使用的CREATE TABLE语句全都以<strong>ENGINE=InnoDB语句</strong>结束。<strong>如果省略ENGINE=语句，则使用默认引擎</strong>(MySQL <strong>5.5之前</strong>，<strong>MyISAM</strong>是默认的引擎；<strong>5.5之后</strong>，<strong>InnoDB</strong>是默认的引擎)。</li><li>几个需要知道的引擎：<ol><li><strong>InnoDB</strong>是一个可靠的<strong>事务处理引擎</strong>（参见第26章），它<strong>不支持全文本搜索</strong>(18章)；</li><li><strong>MyISAM</strong>是一个<strong>性能极高</strong>的引擎，它<strong>支持全文本搜索，不支持事务处理</strong>。</li><li><strong>MEMORY</strong>功能等同于MyISAM，但由于<strong>数据存储在内存中</strong>，速度很快，故适合于<strong>临时表</strong>。</li></ol></li><li>引擎可以混用</li><li><strong>外键（用于强制实施引用完整性，如第1章所述）不能跨引擎</strong>。</li></ul><hr><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    stuId <span class="built_in">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    stuName <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    stuAge <span class="built_in">INT</span> <span class="keyword">CHECK</span>(stuAge <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">100</span>), <span class="comment"># 加入检查约束</span></span><br><span class="line">    stuAddress <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">'china'</span>, <span class="comment"># 指定默认值 </span></span><br><span class="line">    stuDel <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><ul><li><p>更新表定义，可使用<strong>ALTER TABLE语句</strong></p></li><li><p>为了使用ALTER TABLE更改表结构，必须给出下面的信息：</p><ul><li>在<strong>ALTER TABLE之后</strong>给出<strong>要更改的表名</strong>（<strong>该表必须存在，否则将出错</strong>）；</li><li><strong>所做更改的列表</strong>。</li></ul></li><li><p><strong>给表添加一个列</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><strong>增加一个列</strong>，<strong>必须明确其数据类型</strong>。</p></li><li><p><strong>删除表中的列</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br></pre></td></tr></table></figure></li><li><p>ALTER TABLE的一种常见用途是<strong>定义外键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders <span class="comment">-- CONSTRAINT fk_name 定义外键名，可以不定义</span></span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (order_num) <span class="keyword">REFERENCES</span> orders (order_num);</span><br></pre></td></tr></table></figure><p>如果<strong>对单个表进行多个更改</strong>，可以<strong>使用单条ALTER TABLE语句</strong>，<strong>每个更改用逗号分隔</strong>。</p></li><li><p><strong>复杂的表结构更改</strong>一般需要<strong>手动删除过程</strong>：</p><ol><li>用新的列布局创建一个新表</li><li>使用<strong>INSERT SELECT语句</strong>(19章)<strong>从旧表复制数据到新表</strong>。如果有必要，<strong>可使用转换函数和计算字段</strong>。</li><li>检验包含所需数据的新表</li><li>重命名旧表（如果确定，可以删除它）</li><li>用旧表原来的名字重命名新表</li><li>根据需要，重新创建触发器、存储过程、索引和外键</li></ol></li><li><p>使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。</p></li></ul><hr><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ul><li><p>删除表（删除整个表而不是其内容）非常简单，使用<strong>DROP TABLE语句</strong>即可。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br></pre></td></tr></table></figure></li></ul><p>DROP TABLE IF EXISTS table_name;<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  **删除表没有确认，也不能撤销**，执行这条语句将永久删除该表。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 重命名表</span><br><span class="line"></span><br><span class="line">#### 方式一</span><br><span class="line"></span><br><span class="line">- 使用**RENAME TABLE语句**可以重命名一个表。如：</span><br><span class="line"></span><br><span class="line">  ```sql</span><br><span class="line">  RENAME TABLE customers2 TO customers;</span><br></pre></td></tr></table></figure></p><ul><li>可以<strong>使用单条RENAME TABLE语句</strong>对<strong>多个表</strong>进行重命名，<strong>每个重命名用逗号分隔</strong>。</li></ul><hr><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers2 <span class="keyword">RENAME</span> <span class="keyword">TO</span> customers;</span><br></pre></td></tr></table></figure><hr><h2 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>MySQL <strong>5</strong>添加了对视图的支持。视图是<strong>虚拟的表</strong>，<strong>只包含</strong>使用时动态检索数据的<strong>查询</strong>，<strong>不包含数据</strong>。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure><p>​    此查询用来检索订购了某个特定产品的客户。<strong>任何需要这个数据的人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。为了检索其他产品的相同数据，必须修改最后的WHERE子句</strong>。假如可以<strong>把整个查询包装成一个名为productcustomers的虚拟表</strong>，则可以如下轻松地检索出相同的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> productcustomers</span><br><span class="line"><span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure><p><strong>这就是视图的作用</strong>。productcustomers是一个视图，<strong>作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询</strong>。</p><hr><h4 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h4><p>视图的一些常见应用：</p><ol><li>重用SQL语句。</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。可以<strong>给用户授予表的特定部分的访问权限</strong>而不是整个表的访问权限。</li><li><strong>更改数据格式和表示</strong>。视图可返回与底层表的表示和格式不同的数据。</li></ol><p>视图本身不包含数据，因此它们<strong>返回的数据是从其他表中检索出来的</strong>。<strong>在添加或更改这些表中的数据时，视图将返回改变过的数据</strong>。</p><p><strong>性能问题</strong>：因为视图不包含数据，所以<strong>每次使用视图时，都必须处理查询执行时所需的任一个检索</strong>。因此，<strong>如果用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害</strong>。因此，在部署使用了大量视图的应用前，应该进行测试。</p><hr><h4 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h4><p>视图创建和使用的一些最常见的规则和限制：</p><ol><li>与表一样，视图必须唯一命名（<strong>不能给视图取</strong>与别的视图或<strong>表</strong>相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有<strong>足够的访问权限</strong>。这些<strong>限制通常由数据库管理人员授予</strong>。</li><li>视图<strong>可以嵌套</strong>，即<strong>可以利用从其他视图中检索数据的查询来构造一个视图</strong>。</li><li>ORDER BY可以用在视图中，但<strong>如果从该视图检索数据的SELECT语句中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖</strong>。</li><li><strong>视图不能索引，也不能有关联的触发器或默认值</strong>。</li><li><strong>视图可以和表一起使用</strong>。例如，编写一条联结表和视图的SELECT语句。</li></ol><hr><h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图的创建：</p><ol><li>视图用<strong>CREATE VIEW语句</strong>来创建。</li><li>使用<code>SHOW CREATE VIEW viewname;</code>来<strong>查看创建视图的语句</strong>。</li><li><strong>用DROP删除视图</strong>，其语法为<code>DROP VIEW viewname;</code>。</li><li><strong>更新视图</strong>时，可以<strong>先用DROP再用CREATE</strong>，也可以直接用<strong>CREATE OR REPLACEVIEW</strong>。</li></ol><hr><h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h4><p>视图<strong>最常见的应用</strong>之一是<strong>隐藏复杂的SQL</strong>，这通常都会涉及联结：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> productcustomers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id </span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure><ul><li><p>这条语句创建了一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行<code>SELECT * FROM productcustomers;</code>，将列出订购了任意产品的客户。</p></li><li><p>为检索订购了产品TNT2的客户，可如下进行：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> productcustomers</span><br><span class="line"><span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure><ul><li>这条语句通过WHERE子句从视图中检索特定数据。在MySQL处理此查询时，它<strong>将指定的WHERE子句添加到视图查询中的已有WHERE子句中</strong>，以便正确过滤数据。</li><li>可以看出，视图极大地简化了复杂SQL的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。</li></ul></li></ul><hr><h4 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h4><p>如下SELECT语句在单个组合计算列中返回供应商名和位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name), <span class="string">'('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">')'</span>) <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure><p>假如经常需要这个格式的结果，不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vendorlocations <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name), <span class="string">'('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">')'</span>) <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> vendorlocations;</span><br></pre></td></tr></table></figure><hr><h4 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h4><p>例如，可以定义customeremaillist视图，它<strong>过滤没有电子邮件地址的客户</strong>。为此目的，可使用下面的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customeremaillist <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> customeremaillist;</span><br></pre></td></tr></table></figure><hr><h4 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h4><p>视图对于<strong>简化计算字段的使用</strong>特别有用。下面是第10章中介绍的一条SELECT语句。它检索某个特定订单中的物品，计算每种物品的总价格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity * item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure><p>为其转换为一个视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> orderitemsexpanded <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity * item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> orderitemsexpanded</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p><strong>视图的数据能否更新？答案视情况而定</strong>。</p><p><strong>通常，视图是可更新的</strong>（即，可以对它们使用INSERT、UPDATE和DELETE）。<strong>更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行</strong>。</p><p>但是，<strong>并非所有视图都是可更新的</strong>。基本上可以说，如果MySQL<strong>不能正确地确定被更新的基数据</strong>，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ol><li>分组（使用GROUP BY和HAVING）；</li><li>联结；</li><li>子查询；</li><li>并；</li><li>聚集函数（Min()、Count()、Sum()等）；</li><li>DISTINCT；</li><li>导出（计算）列。</li></ol><p><strong>看上去好像是一个严重的限制，但实际上不是，因为视图主要用于数据检索(SELECT)</strong>。</p><hr><h2 id="用户变量和SET语句"><a href="#用户变量和SET语句" class="headerlink" title="用户变量和SET语句"></a>用户变量和SET语句</h2><p>用户变量即<strong>自定义的变量</strong>，我们<strong>可以给用户变量分配值，并且可用在任何可以正常使用标量表达式的地方</strong>。<br> 必须<strong>使用SET或SELECT语句来定义它</strong>，<strong>然后为它赋一个值，否则变量就只有一个空值</strong>。一个客户端定义的变量不能被其它客户端看到或使用。<strong>当客户端退出时，该客户端连接的所有变量将自动释放</strong>。</p><h3 id="用户变量定义"><a href="#用户变量定义" class="headerlink" title="用户变量定义"></a>用户变量定义</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @var_name = expr [, @var_name = expr] ...</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @var_name := expr [, @var_name = expr] ...</span><br></pre></td></tr></table></figure></li></ul><p>对于<strong>SET，可以使用<code>=</code>或<code>:=</code>来赋值，对于SELECT只能使用<code>:=</code>来赋值</strong></p><hr><h3 id="用户变量的使用"><a href="#用户变量的使用" class="headerlink" title="用户变量的使用"></a>用户变量的使用</h3><h4 id="SET-语句"><a href="#SET-语句" class="headerlink" title="SET 语句"></a>SET 语句</h4><ol><li><p><strong>把一个值赋给一个变量的标量表达式可以是复合表达式</strong>。计算、函数、系统标量以及其他用户变量都是允许的，子查询也是允许的。然后<strong>通过SELECT语句可以获取用户变量的值，结果是带有一行的一个表</strong>。</p><p> 例：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @var1=<span class="number">1</span>, @var2=<span class="string">'vartest'</span>, @var3=<span class="keyword">ABS</span>(<span class="number">-2</span>), @var4=(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> mysql.user);</span><br><span class="line"><span class="keyword">SELECT</span> @var1, @var2, @var3, @var4;</span><br></pre></td></tr></table></figure><p> 结果为：</p><p> | @var1 | @var2   | @var3 | @var4 |<br> | —– | ——- | —– | —– |<br> | 1     | vartest | 2     | 4     |</p></li><li><p>在为一个用户变量赋值的表达式中，也可以指定其它的用户变量。但是MySQL会<strong>先</strong>确定<strong>所有表达式的值</strong>，再<strong>给变量赋值</strong>。</p><p> 例：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @varA = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">SET</span> @varA = <span class="number">3</span>, @varB = @varA;</span><br><span class="line"><span class="keyword">SELECT</span> @varB; <span class="comment">-- @varB的值为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="keyword">SET</span> @varA = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">SET</span> @varB = @varA;</span><br><span class="line"><span class="keyword">SELECT</span> @varB; <span class="comment">-- @varB的值为3</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @var1:=<span class="number">1</span>, @var2:=<span class="string">'vartest'</span>, @var3:=<span class="keyword">ABS</span>(<span class="number">-2</span>), @var4:=(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> mysql.user);</span><br></pre></td></tr></table></figure><p>返回一个表格形式的结果：</p><table><thead><tr><th>@var1:=1</th><th>@var2:=’vartest’</th><th>@var3:=abs(-2)</th><th>@var4:=(select count(*) from mysql.user)</th></tr></thead><tbody><tr><td>1</td><td>vartest</td><td>2</td><td>4</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @var1, @var2, @var3, @var4; <span class="comment">-- 效果与SET语句后的SELECT相同</span></span><br></pre></td></tr></table></figure><hr><h3 id="用户变量注意事项"><a href="#用户变量注意事项" class="headerlink" title="用户变量注意事项"></a>用户变量注意事项</h3><ul><li><p>用户变量<strong>用在WHERE或HAVING子句中时，必须首先用另一条语句来定义</strong>。如下面例子，<strong>初次查询不会返回结果，先定义以后再查询才有输出</strong>：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @H:=<span class="string">'localhost'</span>, <span class="keyword">user</span></span><br><span class="line"><span class="keyword">FROM</span> mysql.user</span><br><span class="line"><span class="keyword">WHERE</span> Host = @H; <span class="comment">-- 因为这时@H的值还是NULL(MySQL先确定所有表达式的值，再给变量赋值)</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @H:<span class="string">'localhost'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @H:=<span class="string">'localhost'</span>, <span class="keyword">user</span></span><br><span class="line"><span class="keyword">FROM</span> mysql.user</span><br><span class="line"><span class="keyword">WHERE</span> Host = @H;</span><br></pre></td></tr></table></figure></li><li><p>用户变量为<strong>session级别</strong>，当我们关闭客户端或退出登录时用户变量全部消失</p></li><li><p>用户变量名对大小写不敏感</p></li><li><p>未定义的变量初始化是NULL</p></li></ul><hr><h2 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>迄今为止，<strong>使用的大多数SQL语句都是</strong>针对一个或多个表的<strong>单条语句</strong>。并非所有操作都那么简单，经常会有一个完整的操作需要多条语句才能完成。例如如下场景：</p><ol><li>为了处理订单，需要核对以保证库存中有相应的物品。</li><li>如果库存有物品，<strong>这些物品需要预定</strong>以便不将它们再卖给别的人，并且要<strong>减少可用的物品数量以反映正确的库存量</strong>。</li><li>库存中没有的物品需要订购，这需要与供应商进行某种交互。</li><li>关于哪些商品入库(并可以立即发货)和哪些物品退订，需要通知相应的客户。</li></ol><p>执行这些处理<strong>需要针对许多表的多条MySQL语句</strong>。此外，<strong>需要执行的具体语句及其次序也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化</strong>。那么，应该怎样编写代码？</p><p><strong>可以单独编写每条语句，并根据结果，有条件地执行另外的语句。在每次需要这个处理时，都必须做这些工作</strong>。可以<strong>创建存储过程</strong>。存储过程简单来说，就是<strong>为以后的使用而保存的一条或多条MySQL语句的集合</strong>。<strong>可将其视为批文件，虽然它们的作用不仅限于批处理</strong>。</p><hr><h3 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h3><ol><li>简化复杂操作</li><li>需要执行的步骤越多，出错的可能性就越大。使用存储过程能防止错误，保证数据的一致性。</li><li>简化对变动的管理(解耦)。</li><li>提高性能，<strong>使用存储过程比使用单独的SQL语句要快</strong>。</li><li><strong>存在一些只能用在单个请求中的MySQL元素和特性</strong>，存储过程可以使用它们来编写功能更强更灵活的代码。</li></ol><p>简单来说，使用存储过程有<strong>3个主要好处</strong>：<strong>简单、安全、高性能</strong>。</p><p>存储过程同样也存在一些<strong>缺点</strong>：</p><ol><li>存储过程的<strong>编写比基本SQL语句复杂</strong>，编写存储过程需要更高的技能，更丰富的经验。</li><li>可能没有创建存储过程的安全访问权限。</li></ol><hr><h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><p>MySQL称<strong>存储过程的执行</strong>为<strong>调用</strong>，因此MySQL执行存储过程的语句为<strong>CALL</strong>。CALL接受<strong>存储过程的名字</strong>以及<strong>需要传递给它的任意参数</strong></p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。</span></span><br><span class="line"><span class="keyword">CALL</span> productpricing(@pricelow,</span><br><span class="line">                   @pricehigh,</span><br><span class="line">                   @priceaverage);</span><br></pre></td></tr></table></figure><ul><li>存储过程<strong>可以显示结果，也可以不显示结果</strong>。</li></ul><hr><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p>例：一个<strong>返回产品平均价格</strong>的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>定义</strong>存储过程：<code>CREATE PROCEDURE 存储过程名()</code></li><li>如果存储过程接受<strong>参数</strong>，它们将<strong>在<code>()</code>中列出</strong></li><li><strong>BEGIN和END语句用来限定存储体</strong>，存储体本身是一个简单的SELECT语句</li></ul><p><strong>MySQL命令行的分隔符</strong>：</p><p>默认的MySQL语句分隔符为<code>;</code>，如果<strong>命令行实用程序</strong>要解释存储过程自身内的<code>;</code>字符，会<strong>使存储过程中的SQL语句出现语法错误</strong>。通过<strong>临时更改命令行实用程序的语句分隔符</strong>来解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ul><li><p><code>DELIMITER //</code>指明<strong>使用<code>//</code>作为新的语句结束分隔符</strong>；<code>DELIMITER ;</code>指明<strong>使用<code>;</code>作为新的语句结束分隔符</strong></p><p>  <strong>除<code>\</code>符号外，任何字符都可以用作语句分隔符</strong>。</p></li><li><p>使用这个存储过程：<code>CALL productpricing();</code></p><p>  因为存储过程实际上是一种函数，所以存储过程名后需要有<code>()</code>符号</p></li></ul><hr><h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><p>存储过程<strong>在创建之后，被保存在服务器上以供使用，直至被删除</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> productpricing;</span><br></pre></td></tr></table></figure><ul><li><p>请注意<strong>没有使用后面的<code>()</code>，只给出存储过程名</strong></p></li><li><p>如果<strong>指定的过程不存在，则DROP PROCEDURE将产生一个错误</strong>。当过程存在想删除它时（如果过程不存在也不产生错误）可使用<code>DROP PROCEDURE IF EXISTS</code>。</p></li></ul><hr><h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p><strong>一般，存储过程并不显示结果，而是把结果返回给你指定的变量</strong>。</p><ul><li><strong>变量</strong>：内存中一个特定的位置，用来<strong>临时存储数据</strong>。</li></ul><h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing( </span><br><span class="line">    <span class="keyword">OUT</span> pl <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> ph <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> pa <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(prod_price)</span><br><span class="line"><span class="keyword">INTO</span> pl</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(prod_price)</span><br><span class="line"><span class="keyword">INTO</span> ph</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price)</span><br><span class="line"><span class="keyword">INTO</span> pa</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><p>如果不先<strong>删除已存在的同名存储过程</strong>，则不能再次创建它。</p></li><li><p>关键字<strong>OUT</strong>指出<strong>相应的参数用来从存储过程传出一个值（返回给调用者）</strong></p><p>  MySQL支持<strong>IN(传递给存储过程)</strong>、<strong>OUT(从存储过程传出)</strong>和<strong>INOUT(对存储过程传入和传出)</strong>类型的参数。</p></li><li><p>存储过程用来检索值，然后通过指定<strong>INTO关键字</strong>保存到相应的变量</p></li><li><strong>不能通过一个参数返回多个行和列</strong>，因为<strong>记录集是不允许的类型</strong>。</li></ul><p>为调用此存储过程，必须指定3个变量名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(@pricelow, </span><br><span class="line">                   @pricehigh,</span><br><span class="line">                   @priceaverage);</span><br></pre></td></tr></table></figure><ul><li><p><strong>所有MySQL变量</strong>都必须<strong>以@开始</strong></p></li><li><p>在调用时，<strong>这条语句并不显示任何数据</strong>。它<strong>返回变量</strong>。</p></li><li><p>为了<strong>显示</strong>检索出的产品平均价格，可如下进行：<code>SELECT @priceaverage;</code></p></li><li>为了获得3个变量的值，可：<code>SELECT @pricehigh, @pricelow, @priceaverage;</code></li></ul><hr><h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>这次使用IN和OUT参数。ordertotal接受订单号并返回该订单的合计：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal( </span><br><span class="line">    <span class="keyword">IN</span> onumber <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Sum</span>(item_price*quantity)</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = onumber</span><br><span class="line"><span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><p>可使用调用语句：<code>CALL ordertotal(20005, @total);</code></p></li><li><p>为了显示合计：<code>SELECT @total;</code></p></li></ul><hr><h4 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h4><p>迄今为止使用的所有存储过程基本上都是封装MySQL简单的SELECT语句。虽然它们全都是有效的存储过程例子，但它们所能完成的工作你直接用这些被封装的语句就能完成。<strong>只有在存储过程内包含业务规则和智能处理时，它们的威力才真正显现出来</strong>。</p><p>考虑这个场景。你需要获得与以前一样的订单合计，但需要对<strong>合计增加营业税</strong>，不过<strong>只针对某些顾客</strong>（或许是你所在州中那些顾客）。那么，你需要做下面几件事情：</p><ol><li>获得合计</li><li>把营业税有条件地添加到合计</li><li>返回合计（带或不带税）</li></ol><p>存储过程的完整工作如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Name: ordertotal</span></span><br><span class="line"><span class="comment">-- Parameters:onumber = order number</span></span><br><span class="line"><span class="comment">--taxable = 0 if not taxable, 1 if taxable</span></span><br><span class="line"><span class="comment">--ototal = order total variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal( </span><br><span class="line">    <span class="keyword">IN</span> onumber <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">IN</span> taxable <span class="built_in">BOOLEAN</span>,</span><br><span class="line">    <span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">) <span class="keyword">COMMENT</span> <span class="string">'Obtain order total, optionally adding tax'</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- Declare variable for total</span></span><br><span class="line"><span class="keyword">DECLARE</span> total <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">-- Declare tax percentage</span></span><br><span class="line"><span class="keyword">DECLARE</span> taxrate <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Get the order total</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Sum</span>(item_price*quantity)</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = onumber</span><br><span class="line"><span class="keyword">INTO</span> total;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Is this taxable?</span></span><br><span class="line">IF taxable THEN </span><br><span class="line"><span class="comment">-- Yes, so add taxrate to the total</span></span><br><span class="line"><span class="keyword">SELECT</span> total+(total*taxrate/<span class="number">100</span>) <span class="keyword">INTO</span> total</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- And finally, save to out variable</span></span><br><span class="line"><span class="keyword">SELECT</span> total <span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><p>注释（前面放置<code>--</code>，<code>#</code>也有同样效果）</p></li><li><p>用<strong>DECLARE</strong>语句<strong>定义了两个局部变量</strong></p><p>  DECLARE要求指定<strong>变量名</strong>和<strong>数据类型</strong>，支持<strong>可选的默认值</strong>(DEFAULT xxx)</p></li><li><p><strong>COMMENT关键字</strong></p><p>  它<strong>不是必需的</strong>，但如果给出，将<strong>在SHOW PROCEDURE STATUS的结果中显示</strong>。</p></li><li><p><strong>IF语句</strong></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF search_condition THEN</span><br><span class="line">    statement_list</span><br><span class="line">[ELSEIF search_condition THEN]</span><br><span class="line">    statement_list ...</span><br><span class="line">[ELSE</span><br><span class="line">    statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h4><ul><li><p><strong>显示</strong> 创建一个存储过程的CREATE语句，使用<code>SHOW CREATE PROCEDURE</code>语句：<code>SHOW CREATE PROCEDURE ordertotal;</code></p></li><li><p>为了获得<strong>包括何时、由谁创建等详细信息的存储过程列表</strong>，使用<code>SHOW PROCEDURESTATUS</code>。</p><p>  为<strong>限制其输出，可使用LIKE指定一个过滤模式</strong>，例如：</p><p>  <code>SHOW PROCEDURE STATUS LIKE ’ordertotal&#39;;</code></p></li></ul><hr><h2 id="information-schema-数据库"><a href="#information-schema-数据库" class="headerlink" title="information_schema 数据库"></a>information_schema 数据库</h2><p>information_schema这个数据库中<strong>保存了MySQL服务器所有数据库的信息</strong>，如数据库名，数据库的表，表栏的数据类型与访问权限等。<br>再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问等等信息都保存在information_schema里面。</p><ul><li>SCHEMATA表<ul><li>列SCHEMA_NAME：<strong>所有数据库的名字</strong></li></ul></li><li><p>TABLES表</p><ul><li>列TABLE_SCHEMA：<strong>所有数据库的名字</strong></li><li>列TABLE_NAME：<strong>所有数据库表的名字</strong></li><li>列TABLE_ROWS：表的行数</li></ul></li><li><p>COLUMNS表</p><ul><li>列COLUMN_NAME：<strong>所有数据库表的列的名字</strong></li></ul></li></ul><hr><h2 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h2><blockquote><p>在检索出来的行中前进或后退一行或多行。这就是使用游标的原因</p></blockquote><blockquote><p>游标（cursor）</p></blockquote><blockquote><p>数据库查询</p></blockquote><blockquote><p>结果集</p></blockquote><blockquote><p>主要用于交互式应用</p></blockquote><blockquote><p>MySQL游标只能用于存储过程（和函数）</p></blockquote><blockquote><p>定义要使用的SELECT语句</p></blockquote><blockquote><p>把数据实际检索出来</p></blockquote><blockquote><p>在结束游标使用时，必须关闭游标</p></blockquote><blockquote><p>游标用DECLARE语句创建</p></blockquote><blockquote><p>OPEN CURSOR语句</p></blockquote><blockquote><p>存储检索出的数据以供浏览和滚动</p></blockquote><blockquote><p>CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。</p></blockquote><blockquote><p>果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p></blockquote><blockquote><p>FETCH指定检索什么数据（所需的列）</p></blockquote><blockquote><p>向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）</p></blockquote><blockquote><p>自动从第一行开始</p></blockquote><blockquote><p>REPEAT</p></blockquote><blockquote><p>UNTIL done END REPEAT</p></blockquote><blockquote><p>[插图]</p></blockquote><blockquote><p>CONTINUE HANDLER</p></blockquote><blockquote><p>MySQL还支持循环语句，它可用来重复执行代码，直到使用LEAVE语句手动退出为止</p></blockquote><blockquote><p>REPEAT语句的语法使它更适合于对游标进行循环。</p></blockquote><h2 id="第25章-使用触发器"><a href="#第25章-使用触发器" class="headerlink" title="第25章 使用触发器"></a>第25章 使用触发器</h2><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p><strong>MySQL语句在需要时被执行，存储过程也是如此</strong>。但是，如果你<strong>想要某条语句（或某些语句）在事件发生时自动执行</strong>，怎么办呢？例如：</p><ol><li><strong>每当增加一个</strong>顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否为大写；</li><li><strong>每当订购一个</strong>产品时，都从库存数量中减去订购的数量；</li><li>无论何时<strong>删除一行</strong>，都在某个存档表中保留一个副本。</li></ol><p>这些例子的共同之处在于<strong>它们都需要在某个表发生更改时自动处理</strong>，<strong>触发器就是提供这样功能</strong>的工具。触发器是MySQL<strong>响应DELETE/INSERT/UPDATE语句</strong>而自动执行的<strong>一条</strong>（或<strong>位于BEGIN和END语句之间的一组语句</strong>）MySQL语句。<strong>其他MySQL语句不支持触发器</strong>。</p><hr><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>在创建触发器时，需要给出4条信息：</p><ol><li>唯一的<strong>触发器名</strong>；</li><li>触发器<strong>关联的表</strong>；</li><li>触发器应该<strong>响应的活动</strong>（<strong>DELETE、INSERT或UPDATE</strong>）；</li><li>触发器<strong>何时执行</strong>（<strong>处理之前或之后</strong>）</li></ol><p><strong>保持每个数据库的触发器名唯一</strong></p><p>​    在MySQL 5中，触发器名必须在<strong>每个表中唯一</strong>，<strong>但不是在每个数据库中唯一</strong>。<strong>这在其他每个数据库触发器名必须唯一的DBMS中是不允许的，</strong>而且以后的MySQL版本很可能会使命名规则更为严格。因此，现在最好是在数据库范围内使用唯一的触发器名。</p><p>触发器用<strong>CREATE TRIGGER语句</strong>创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct </span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> products</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'Product added'</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>只有表才支持触发器</strong>，<strong>视图</strong>和<strong>临时表都不支持触发器</strong>。</li><li>触发器<strong>按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器</strong>。因此，每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。</li><li>如果<strong>BEFORE触发器失败</strong>，则MySQL<strong>将不执行请求的操作</strong>。此外，如果<strong>BEFORE触发器或语句本身失败</strong>，MySQL<strong>将不执行AFTER触发器</strong>（如果有的话）。</li></ul><hr><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> newproduct;</span><br></pre></td></tr></table></figure><p>触发器<strong>不能更新或覆盖</strong>，<strong>为了修改一个触发器，必须先删除它，然后再重新创建</strong>。</p><hr><h3 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h3><h4 id="INSERT触发器"><a href="#INSERT触发器" class="headerlink" title="INSERT触发器"></a>INSERT触发器</h4><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p><ol><li>在INSERT<strong>触发器代码内</strong>，可<strong>引用一个名为NEW的虚拟表</strong>，<strong>访问被插入的行</strong>；</li><li>在<strong>BEFORE</strong> INSERT触发器中，<strong>NEW中的值也可以被更新</strong>（允许更改被插入的值）；</li><li>对于<strong>AUTO_INCREMENT列</strong>，<strong>NEW在INSERT执行之前包含0</strong>，在INSERT执行之后包含新的自动生成值。</li></ol><p><strong>AUTO_INCREMENT列</strong>具有MySQL自动赋予的值。第21章建议了几种<strong>确定新生成值</strong>的方法，但下面是一种更好的方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder</span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> </span><br><span class="line"><span class="keyword">SELECT</span> NEW.order_num; <span class="comment">-- 引用一个名为NEW的虚拟表，访问被插入的行</span></span><br></pre></td></tr></table></figure><ul><li>在插入一个新订单到orders表时，<strong>MySQL生成一个新订单号并保存到order_num中</strong>。触发器<strong>从NEW. order_num取得这个值并返回它</strong>。<strong>此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成</strong>。对于orders的每次插入使用这个触发器将总是返回新的订单号。</li></ul><p>通常，<strong>将BEFORE用于数据验证和净化</strong>（目的是保证插入表中的数据确实是需要的数据，对于UPDATE触发器也适用）。</p><hr><h4 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h4><ul><li>在DELETE触发器代码内，<strong>可以引用一个名为OLD的虚拟表</strong>，<strong>访问被删除的行</strong></li><li>OLD中的值全都是<strong>只读</strong>的，<strong>不能更新</strong></li></ul><p>下面的例子演示<strong>使用OLD保存将要被删除的行到一个存档表中</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteorder </span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> archive_orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li>在<strong>任意订单被删除前</strong>将执行此触发器。</li><li><p>使用<strong>BEFORE DELETE触发器的优点</strong>（相对于AFTER DELETE触发器来说）为，<strong>如果由于某种原因，订单不能存档，DELETE本身将被放弃</strong>。</p></li><li><p>使用<strong>BEGIN END语句</strong>标记触发器体的好处是<strong>触发器能容纳多条SQL语句</strong>（在BEGIN END块中一条挨着一条）。</p></li></ul><hr><h4 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h4><ul><li>在UPDATE触发器代码中，你<strong>可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值</strong>，<strong>引用一个名为NEW的虚拟表访问新更新的值</strong>；</li><li>在<strong>BEFORE UPDATE触发器中</strong>，<strong>NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）</strong>；</li><li><strong>OLD中的值全都是只读的，不能更新</strong>。</li></ul><p>下面的例子<strong>保证州名缩写总是大写</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> updatevendor </span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> vendors</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">SET</span> NEW.vend_state = <span class="keyword">Upper</span>(NEW.vend_state);</span><br></pre></td></tr></table></figure><p>显然，任<strong>何数据净化都需要在UPDATE语句之前进行</strong>。</p><hr><h4 id="关于触发器的进一步介绍"><a href="#关于触发器的进一步介绍" class="headerlink" title="关于触发器的进一步介绍"></a>关于触发器的进一步介绍</h4><ol><li>与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的MySQL版本中有一些改进和增强触发器支持的计划。</li><li><strong>创建</strong>触发器<strong>可能需要特殊的安全访问权限</strong>，但是，<strong>触发器的执行是自动的</strong>。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行。</li><li>应该<strong>用触发器来保证数据的一致性（大小写、格式等）</strong>。在触发器中<strong>执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关</strong>。</li><li>触发器的一种非常有意义的使用是<strong>创建审计跟踪</strong>。使用触发器，<strong>把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易</strong>。</li><li>遗憾的是，MySQL<strong>触发器中不支持CALL语句</strong>。这表示<strong>不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内</strong>。</li></ol><hr><h2 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h2><blockquote><p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p></blockquote><blockquote><p>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果</p></blockquote><blockquote><p>发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p></blockquote><blockquote><p>❑ 事务（transaction）指一组SQL语句；❑ 回退（rollback）指撤销指定SQL语句的过程；❑ 提交（commit）指将未存储的SQL语句结果写入数据库表；❑ 保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同）。</p></blockquote><blockquote><p>关键在于将SQL语句组分解为逻辑块</p></blockquote><blockquote><p>标识事务的开始</p></blockquote><blockquote><p>ROLLBACK命令用来回退（撤销）MySQL语句</p></blockquote><blockquote><p>用一条ROLLBACK语句回退STARTTRANSACTION之后的所有语句</p></blockquote><blockquote><p>ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）。</p></blockquote><blockquote><p>哪些语句可以回退？ 事务处理用来管理INSERT、UPDATE和DELETE语句</p></blockquote><blockquote><p>不能回退CREATE或DROP操作</p></blockquote><blockquote><p>在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句</p></blockquote><blockquote><p>因为涉及更新两个数据库表orders和orderitems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。</p></blockquote><blockquote><p>更复杂的事务处理可能需要部分提交或回退。</p></blockquote><blockquote><p>必须能在事务处理块中合适的位置放置占位符</p></blockquote><blockquote><p>占位符称为保留点</p></blockquote><blockquote><p>SAVEPOINT</p></blockquote><blockquote><p> 保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。</p></blockquote><blockquote><p>任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句：</p></blockquote><blockquote><p>设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）</p></blockquote><blockquote><p>针对每个连接而不是服务器</p></blockquote><h2 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h2><blockquote><p>❑ 字符集为字母和符号的集合；❑ 编码为某个字符集成员的内部表示；❑ 校对为规定字符如何比较的指令。</p></blockquote><blockquote><p>字符集</p></blockquote><blockquote><p>校对</p></blockquote><h2 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h2><blockquote><p>MySQL创建一个名为root的用户账号，它对整个MySQL服务器具有完全的控制</p></blockquote><blockquote><p>不过在现实世界的日常工作中，决不能使用root</p></blockquote><blockquote><p>mysql数据库有一个名为user的表，它包含所有用户账号。user表有一个名为user的列，它存储用户登录名</p></blockquote><blockquote><p>IDENTIFIED BY指定的口令为纯文本，MySQL将在保存到user表之前对其进行加密。为了作为散列值指定口令，使用IDENTIFIED BY PASSWORD</p></blockquote><blockquote><p>CREATE USER是最清楚和最简单的句子。此外，也可以通过直接插入行到user表来增加用户，不过为安全起见，一般不建议这样做</p></blockquote><blockquote><p>删除用户账号和所有相关的账号权限</p></blockquote><blockquote><p>MySQL 5以前，DROP USER只能用来删除用户账号，不能删除相关的权限</p></blockquote><blockquote><p>新创建的用户账号没有访问权限</p></blockquote><blockquote><p>MySQL的权限用用户名和主机名结合定义</p></blockquote><blockquote><p>此GRANT允许用户</p></blockquote><blockquote><p>使用SELECT</p></blockquote><blockquote><p>GRANT的反操作为REVOKE，用它来撤销特定的权限</p></blockquote><blockquote><p>被撤销的访问权限必须存在，否则会出错。</p></blockquote><blockquote><p>在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求</p></blockquote><blockquote><p>副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用</p></blockquote><blockquote><p>列出各权限并用逗号分隔，将多条GRANT语句串在一起</p></blockquote><blockquote><p>更改用户口令，可使用SET PASSWORD语句</p></blockquote><blockquote><p>新口令必须传递到Password()函数进行加密</p></blockquote><blockquote><p>在不指定用户名时，SET PASSWORD更新当前登录用户的口令。</p></blockquote><h2 id="第29章-数据库维护"><a href="#第29章-数据库维护" class="headerlink" title="第29章 数据库维护"></a>第29章 数据库维护</h2><blockquote><p>MySQL数据库是基于磁盘的文件</p></blockquote><blockquote><p>由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。</p></blockquote><blockquote><p>转储所有数据库内容到某个外部文件</p></blockquote><blockquote><p>从一个数据库复制所有数据</p></blockquote><blockquote><p>BACKUP TABLE</p></blockquote><blockquote><p>SELECT INTO OUTFILE</p></blockquote><blockquote><p>数据可以用RESTORE TABLE来复原。</p></blockquote><blockquote><p>首先刷新未写数据 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSH TABLES语句。</p></blockquote><blockquote><p> ANALYZE TABLE，用来检查表键是否正确</p></blockquote><blockquote><p> CHECK TABLE用来针对许多问题对表进行检查</p></blockquote><blockquote><p>CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描</p></blockquote><blockquote><p>下面是几个重要的mysqld命令行选项：❑ –help显示帮助——一个选项列表；❑ –safe-mode装载减去某些最佳配置的服务器；❑ –verbose显示全文本消息（为获得更详细的帮助消息与–help联合使用）；❑ –version显示版本信息然后退出。</p></blockquote><blockquote><p>错误日志。它包含启动和关闭问题以及任意关键错误的细节</p></blockquote><blockquote><p>位于data目录中</p></blockquote><blockquote><p>查询日志。它记录所有MySQL活动，在诊断问题时非常有用</p></blockquote><blockquote><p>位于data目录中</p></blockquote><blockquote><p>二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句</p></blockquote><blockquote><p>位于data目录内</p></blockquote><blockquote><p>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询</p></blockquote><blockquote><p>在确定数据库何处需要优化很有用</p></blockquote><blockquote><p>位于data目录中</p></blockquote><blockquote><p>使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。</p></blockquote><h2 id="第30章-改善性能"><a href="#第30章-改善性能" class="headerlink" title="第30章 改善性能"></a>第30章 改善性能</h2><ul><li><p>MySQL<strong>和所有的DBMS一样，具有特定的硬件建议</strong>。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对<strong>用于生产的服务器来说，应该坚持遵循这些硬件建议</strong>。 </p></li><li><p>MySQL是<strong>用一系列的默认设置预先配置的，这些设置开始通常是很好的</strong>。但过一段时间后你可能需<strong>要调整内存分配、缓冲区大小</strong>等(为查看当前设置，可使用<code>SHOW VARIABLES;</code>和<code>SHOW STATUS;</code>)。 </p></li><li><p>MySQL是一个<strong>多用户多线程</strong>的DBMS。如果遇到<strong>显著的性能不良</strong>，可使用<code>SHOW PROCESSLIST;</code><strong>显示所有活动进程</strong>（以及它们的线程ID和执行时间）。你还可以<strong>用KILL命令终结某个特定的进程</strong>（使用这个命令<strong>需要作为管理员登录</strong>）</p></li><li><p>一般来说，<strong>存储过程执行得</strong>比一条一条地执行其中的各条语句要<strong>快</strong>。</p></li><li><p><strong>除非需要每一个列</strong>，否则不要用<code>SELECT *</code></p></li><li><p>有的操作（包括INSERT）支持一个可选的<strong>DELAYED关键字</strong>，如果使用它，将<strong>把控制立即返回给调用程序</strong>，并且<strong>一旦有可能就实际执行该操作</strong></p></li><li><p>导入数据时，应该<strong>关闭自动提交</strong>。你可能还想<strong>删除索引(包括FULLTEXT索引)</strong>，然后<strong>在导入完成后重建它们</strong>。</p></li><li><p>必须<strong>索引数据库表以改善数据检索的性能</strong>。</p></li><li><p>如果<strong>有一系列复杂的OR条件</strong>，通过<strong>使用多条SELECT语句和连接它们的UNION语句</strong>，<strong>能看到极大的性能改进</strong>。</p></li><li><p><strong>索引</strong>改善数据检索的性能，但<strong>损害数据插入、删除和更新的性能</strong>。如果有一些表，它们<strong>收集数据</strong>且不经常被搜索，则<strong>在有必要之前不要索引它们</strong>。</p></li><li><p>LIKE很慢，一般来说，<strong>最好是使用FULLTEXT而不是LIKE</strong>。</p></li><li><p>数据库是不断变化的实体，<strong>理想的优化和配置也会改变</strong>。</p></li></ul><h3 id="SQL如何提高查询效率"><a href="#SQL如何提高查询效率" class="headerlink" title="SQL如何提高查询效率"></a>SQL如何提高查询效率</h3><h4 id="1-参数是子查询-14章-时，使用-EXISTS-还是-IN"><a href="#1-参数是子查询-14章-时，使用-EXISTS-还是-IN" class="headerlink" title="1. 参数是子查询(14章)时，使用 EXISTS 还是 IN"></a>1. 参数是子查询(14章)时，使用 EXISTS 还是 IN</h4><p>在大多数时候，<code>[NOT] IN</code>和<code>[NOT] EXISTS</code>返回的结果是相同的。</p><p>当<strong>主表比从表大</strong>时，<strong>IN查询的效率较高</strong>；当<strong>从表比主表大</strong>时，<strong>EXISTS查询的效率较高</strong>。</p><ul><li>IN是<strong>先执行子查询，得到一个结果集</strong>，将结果集代入外层谓词条件执行主查询，子查询只需要执行一次</li><li>EXISTS是<strong>先从主查询中取得一条数据，再代入到子查询中</strong>，执行一次子查询，判断子查询是否能返回结果，<strong>主查询有多少条数据，子查询就要执行多少次</strong>。</li></ul><p>例：从Class_A表中查出同时存在于Class_B表中的员工。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 慢</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Class_A</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> </span><br><span class="line">             <span class="keyword">FROM</span> Class_B);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Class_A</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * </span><br><span class="line">              <span class="keyword">FROM</span> Class_B </span><br><span class="line">              <span class="keyword">WHERE</span> A.id = B.id);</span><br></pre></td></tr></table></figure><p><strong>使用EXISTS时更快</strong>的原因：</p><ol><li><p>如果<strong>连接列</strong>(上例中为<code>id</code>)<strong>建立了索引</strong>，那么查询Class_B时不用查实际的表，只需要查索引就可以了。</p></li><li><p><strong>使用EXISTS，只要查到一行数据满足条件就会终止查询</strong>，而<strong>使用IN时会将表全扫描一遍</strong>。</p><p> IN的参数是子查询时，数据库<strong>首先执行子查询</strong>，然后<strong>将结果存储在一张临时的工作表里</strong>（<strong>内联视图</strong>），然后<strong>扫描整个视图</strong>。使用 EXISTS 的话，数据库不会生成临时的工作表。</p></li></ol><p>要想<strong>改善 IN 的性能</strong>，除了使用 EXISTS ，<strong>还可以使用连接(JOIN)</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用连接代替IN</span></span><br><span class="line"><span class="keyword">SELECT</span> A.id, A.name</span><br><span class="line"><span class="keyword">FROM</span> Class_A <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Class_B <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.id = B.id;</span><br></pre></td></tr></table></figure><p>因为没有了子查询，数据库也不会产生中间表。<strong>很难JOIN和EXISTS相比谁更好，但如果没有索引，可能EXISTS会更胜一筹</strong>。</p><hr><h4 id="2-避免排序"><a href="#2-避免排序" class="headerlink" title="2. 避免排序"></a>2. 避免排序</h4><p>我们<strong>在查询的时候</strong>，即使没想进行排序，但是<strong>在数据库内部仍然频繁地进行着暗中的排序</strong>。<strong>会进行排序的代表性运算</strong>：</p><ul><li><code>GROUP BY</code>子句</li><li><code>ORDER BY</code>子句</li><li>聚合函数(<code>SUM()</code>、<code>COUNT()</code>、<code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code>)</li><li><code>DISTINCT</code></li><li>集合运算符(<code>UNION</code>、<code>INTERSECT</code>、<code>EXCEPT</code>)</li><li>窗口函数(<code>RANK</code>、<code>ROW_NUMBER</code>等)</li></ul><hr><h5 id="使用UNION-ALL代替UNION"><a href="#使用UNION-ALL代替UNION" class="headerlink" title="使用UNION ALL代替UNION"></a>使用<code>UNION ALL</code>代替<code>UNION</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Class_A</span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> Class_B</span><br></pre></td></tr></table></figure><p>这个操作会进行排序，如果<strong>不在乎结果中是否有重复数据</strong>，可以使用<code>UNION ALL</code>代替<code>UNION</code>。</p><hr><h5 id="使用EXISTS代替DISTINCT"><a href="#使用EXISTS代替DISTINCT" class="headerlink" title="使用EXISTS代替DISTINCT"></a>使用<code>EXISTS</code>代替<code>DISTINCT</code></h5><p>为了排除重复数据，<code>DISTINCT</code>也会进行排序。<strong>如果需要对两张表的连接结果进行去重</strong>，可以考虑用<code>EXISTS</code>代替<code>DISTINCT</code>，以避免排序。</p><p>例：从商品表Items中找出同时存在于销售记录表SalesHistory中的商品。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> I.item</span><br><span class="line"><span class="keyword">FROM</span> Item <span class="keyword">AS</span> I <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SalesHistory <span class="keyword">AS</span> SH</span><br><span class="line"><span class="keyword">ON</span> I.item_no = SH.item_no;</span><br></pre></td></tr></table></figure><p>因为是一对多连接，所以<code>item_no</code>列中会出现重复数据，<strong>为了排除重复数据，需要使用DISTINCT</strong>。但是<strong>使用DISTINCT会排序，更好的做法是使用<code>EXISTS</code></strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> I.item_no</span><br><span class="line"><span class="keyword">FROM</span> Item <span class="keyword">AS</span> I <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SalesHistory <span class="keyword">AS</span> SH</span><br><span class="line"><span class="keyword">ON</span> I. item_no = SH. item_no;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> item_no</span><br><span class="line"><span class="keyword">FROM</span> Items <span class="keyword">AS</span> I</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * </span><br><span class="line">              <span class="keyword">FROM</span> SalesHistory SH </span><br><span class="line">              <span class="keyword">WHERE</span> I.item_no = SH.item_no);</span><br></pre></td></tr></table></figure><hr><h5 id="在极值函数-MAX-MIN-中使用索引"><a href="#在极值函数-MAX-MIN-中使用索引" class="headerlink" title="在极值函数(MAX/MIN)中使用索引"></a>在极值函数(MAX/MIN)中使用索引</h5><p>使用<code>MAX()</code>和<code>MIN()</code>这两个函数都会进行排序。但<strong>如果参数字段上建有索引，则只需要扫描索引，不需要扫描整张表</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以Item表为例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(item_no)</span><br><span class="line"><span class="keyword">FROM</span> Items;</span><br></pre></td></tr></table></figure><p>这种方法并不是去掉了排序的过程，而是<strong>优化了排序前的查找速度(只需要扫描索引，不需要扫描整张表)</strong>，从而减弱了排序对整体性能的影响。</p><hr><h5 id="能写在WHERE子句里的条件不要写在HAVING子句里"><a href="#能写在WHERE子句里的条件不要写在HAVING子句里" class="headerlink" title="能写在WHERE子句里的条件不要写在HAVING子句里"></a>能写在WHERE子句里的条件不要写在HAVING子句里</h5><ul><li><p>聚合<strong>后</strong>使用HAVING子句过滤</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="keyword">SUM</span>(quantity)</span><br><span class="line"><span class="keyword">FROM</span> SalesHistory</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date</span><br><span class="line"><span class="keyword">HAVING</span> sale_date = <span class="string">'2007-10-01'</span>;</span><br></pre></td></tr></table></figure></li><li><p>聚合<strong>前</strong>使用WHERE子句过滤</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="keyword">SUM</span>(quantity)</span><br><span class="line"><span class="keyword">FROM</span> SalesHistory</span><br><span class="line"><span class="keyword">WHERE</span> sale_date = <span class="string">'2007-10-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date;</span><br></pre></td></tr></table></figure></li></ul><p>虽然结果是一样的，但是<strong>从性能上来看，使用WHERE语句效率更高</strong>。原因通常有两个：</p><ol><li>在使用<strong>GROUP BY</strong>子句聚合时会进行<strong>排序</strong>，如果事先通过<strong>WHERE</strong> 子句<strong>筛选出一部分行，就能够减轻排序的负担</strong>。</li><li>在<strong>WHERE</strong> 子句的条件里<strong>可以使用索引</strong>。而<strong>HAVING</strong>子句是<strong>针对聚合后生成的视图进行筛选的</strong>，但是<strong>很多时候聚合后的视图都没有继承原表的索引结构</strong>。</li></ol><hr><h4 id="3-真正把索引利用起来"><a href="#3-真正把索引利用起来" class="headerlink" title="3. 真正把索引利用起来"></a>3. 真正把索引利用起来</h4><p>列举一些<strong>导致索引失效的作法</strong>：</p><ol><li><p><strong>索引字段上进行计算</strong>，会进行全表扫描。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> someTable</span><br><span class="line"><span class="keyword">WHERE</span> col_1 * <span class="number">1.1</span> &gt; <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化方法：把运算的表达式放到查询条件的右侧</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> someTable</span><br><span class="line"><span class="keyword">WHERE</span> col_1 &gt; <span class="number">100</span>/<span class="number">1.1</span>;</span><br></pre></td></tr></table></figure><p> 实际上，<strong>只要索引列上使用函数的时候，索引就会失效</strong>。</p></li><li><p><strong>使用<code>IS NULL</code>谓词</strong></p><p> <strong>通常索引字段不存在NULL</strong>，所以指定IS NULL和IS NOT NULL的话会使得索引无法使用，进而导致查询性能低下。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> someTable</span><br><span class="line"><span class="keyword">WHERE</span> col_1 <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用否定形式</strong></p><ul><li><p><code>&lt;&gt;</code>/<code>!=</code></p></li><li><p><code>NOT IN</code></p></li></ul></li><li><p><strong>使用OR</strong></p><p> 在<code>col_1</code>和<code>col_2</code>上<strong>分别建立了不同的索引，或者建立了(col_1,col_2)这样的联合索引时</strong>，如果<strong>使用OR连接条件</strong>，<strong>要么用不到索引，要么用到了但是效率比AND要差很多</strong>。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> someTable</span><br><span class="line"><span class="keyword">WHERE</span> col_1 &gt; <span class="number">100</span></span><br><span class="line"><span class="keyword">OR</span> col_2 = <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用<strong>联合索引</strong>时，<strong>列的顺序错误</strong></p><p> 假设存在这样顺序的一个<strong>联合索引</strong>(col_1, col_2, col_3)。<strong>联合索引中的第一列col_1必须写在查询条件的开头</strong>，而且<strong>索引中列的顺序不能颠倒</strong>。<strong>如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引拆分为多个索引</strong>。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 能够利用索引的操作</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_1 = <span class="number">10</span> </span><br><span class="line"><span class="keyword">AND</span> col_2 = <span class="number">100</span> </span><br><span class="line"><span class="keyword">AND</span> col_3 = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_1 = <span class="number">10</span> <span class="keyword">AND</span> col_2 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="comment"># 不能利用索引的操作</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_1 = <span class="number">10</span> <span class="keyword">AND</span> col_3 = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_2 = <span class="number">100</span> <span class="keyword">AND</span> col_3 = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_2 = <span class="number">100</span> <span class="keyword">AND</span> col_1 = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用<strong>LIKE</strong>进行<strong>后方一致</strong>或<strong>中间一致</strong>的匹配</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引失效 %为通配符，表示任何字符出现任意次数</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_1 <span class="keyword">LIKE</span> <span class="string">'%a'</span>; <span class="comment"># 后方一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_1 <span class="keyword">LIKE</span> <span class="string">'%a%'</span>; <span class="comment"># 中间一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line"><span class="comment"># 索引有效</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_1 <span class="keyword">LIKE</span> <span class="string">'a%'</span>; <span class="comment"># 开头一致</span></span><br></pre></td></tr></table></figure></li><li><p><strong>进行隐式的类型转换</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如 col_1列的类型为 字符</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_1 = <span class="number">10</span>; <span class="comment"># 隐式的类型转换，不仅会增加额外的性能开销，还会导致索引不可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> SomeTable </span><br><span class="line"><span class="keyword">WHERE</span> col_1 = <span class="keyword">CAST</span>(<span class="number">10</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>(<span class="number">2</span>)); <span class="comment"># 把数字10转换为长度为2的字符</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="减少中间表"><a href="#减少中间表" class="headerlink" title="减少中间表"></a>减少中间表</h4><p>在 SQL 中，<strong>子查询的结果会被看成一张新表</strong>，这张新表与原始表一样，可以通过代码进行操作。这种高度的相似性使得 SQL 编程具有非常强的灵活性，但是<strong>如果不加限制地大量使用中间表，会导致查询性能下降</strong>。</p><p>频繁使用中间表会带来两个问题：</p><ol><li><strong>展开数据需要耗费内存资源</strong></li><li><strong>原始表中的索引不容易使用到</strong>（特别是聚合时）</li></ol><p>因此，<strong>尽量减少中间表的使用</strong>也是提升性能的一个重要方法。</p><p><strong>灵活使用HAVING子句 可以减少中间表的使用</strong>：</p><p>​    <strong>对聚合结果指定筛选条件时，使用 HAVING 子句是基本原则</strong>。不习惯使用 HAVING 子句的数据库工程师可能会倾向于像下面这样先生成一张中间表，然后在 WHERE 子句中指定筛选条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> sale_date, <span class="keyword">MAX</span>(quantity) <span class="keyword">AS</span> max_qty </span><br><span class="line">      <span class="keyword">FROM</span> SalesHistory</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date) TMP <span class="comment"># 没用的中间表</span></span><br><span class="line"><span class="keyword">WHERE</span> max_qty &gt;= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用HAVING子句的写法</span></span><br><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="keyword">MAX</span>(quantity) <span class="keyword">AS</span> max_qty </span><br><span class="line"><span class="keyword">FROM</span> SalesHistory</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date </span><br><span class="line"><span class="keyword">HAVING</span> max_qty &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>HAVING子句和聚合操作(GROUP BY)是同时执行的，所以比起生成中间表后再执行的WHERE子句，效率更高，代码更简洁</strong>。</p><hr><h2 id="附录C-MySQL语句的语法"><a href="#附录C-MySQL语句的语法" class="headerlink" title="附录C MySQL语句的语法"></a>附录C MySQL语句的语法</h2><blockquote><p>方括号中</p></blockquote><blockquote><p>是可选的</p></blockquote><blockquote><p>更新已存在表的模式</p></blockquote><blockquote><p>将事务处理写到数据库</p></blockquote><blockquote><p>在一个或多个列上创建索引</p></blockquote><h2 id="附录D-MySQL数据类型"><a href="#附录D-MySQL数据类型" class="headerlink" title="附录D MySQL数据类型"></a>附录D MySQL数据类型</h2><h3 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h3><ul><li><strong>定长串</strong>：接受长度固定的字符串，其<strong>长度是在创建表时指定的</strong>。<ul><li>定长列不允许多于指定的字符数目，它们<strong>分配的存储空间和指定的一样多</strong>。</li><li><strong>CHAR</strong>属于定长串类型</li></ul></li><li><strong>变长串</strong>：存储可变长度的文本。<ul><li>有些变长数据类型<strong>具有最大的定长</strong>；有些则是<strong>完全变长</strong>的。</li><li><strong>TEXT</strong>属于变长串类型</li></ul></li></ul><p><strong>为什么要使用定长数据类型</strong>？</p><p>​    因为<strong>性能</strong>，MySQL<strong>处理定长列要快得多</strong>。此外，<strong>不允许对变长列（或一个列的可变部分）进行索引</strong>。</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>CHAR(size)</td><td>最多设置255个字符的<strong>定长</strong>串。<br>长度必须在创建时指定，否则MySQL默认为<code>CHAR(1)</code></td></tr><tr><td>VARCHAR(size)</td><td>最多设置255个字符的<strong>变长</strong>串。<br>如果<strong>值的长度 &gt; 255，会转为TEXT类型</strong>。</td></tr><tr><td>TEXT</td><td>最大长度为65535($2^{16}$)的<strong>变长</strong>串。</td></tr><tr><td>TINYTEXT</td><td>最大长度为255个字符的<strong>变长</strong>串，类型与TEXT相同</td></tr><tr><td>MEDIUMTEXT</td><td>最大长度为$2^{14}$的变长串</td></tr><tr><td>LONGTEXT</td><td>最大长度为$2^{22}$的变长串</td></tr><tr><td>ENUM(x, y, z, etc.)</td><td>枚举，最多$2^{16}$<strong>个</strong>变长串</td></tr></tbody></table><ul><li><p>不管使用何种形式的串数据类型，串值都<strong>必须括在引号内</strong>（通常<strong>单引号更好</strong>）。</p></li><li><p>如果数值是计算（求和、平均等）中使用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p></li></ul><hr><h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h3><p>所有数值类型(除BIT和BOOLEAN外)都可以有符号或无符号。<strong>有符号数值列</strong>可以存储正/负数值，<strong>无符号数值列</strong>只能存储<strong>正数</strong>。<strong>默认情况为有符号</strong>，但如果你知道自己<strong>不需要存储负值，可以使用 UNSIGNED关键字</strong>。</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>BIT</td><td><strong>位</strong>，1~64位</td></tr><tr><td>BOOLEAN/BOOL</td><td>取值为0/1</td></tr><tr><td>INT(size)</td><td>整数值<br>（$-2^{31}\sim2^{31}-1$，UNSIGNED时，为$0\sim2^{32}-1$)</td></tr><tr><td>TINYINT(size)</td><td>整数值<br>($-2^7\sim2^7-1$，UNSIGNED时，为$0\sim2^8-1$)</td></tr><tr><td>SMALLINT(size)</td><td>整数值<br>($-2^{15}\sim2^{15}-1$，UNSIGNED时，为$0\sim 2^{16}-1$)</td></tr><tr><td>MEDIUMINT(size)</td><td>整数值<br>($-2^{23}\sim 2^{23}-1$，UNSIGNED时，为$0\sim 2^{24}-1$)</td></tr><tr><td>BIGINT(size)</td><td>整数值<br>($-2^{63}\sim 2^{63}-1$，UNSIGNED时，为$0\sim 2^{64}-1$)</td></tr><tr><td>FLOAT(size, d)</td><td>单精度浮点数，存在精度损失<br>size规定<strong>最大位数(小数点左侧和右侧)</strong>，d规定<strong>小数点右侧的最大位数</strong>。</td></tr><tr><td>DOUBLE(size, d)</td><td>双精度浮点数，存在精度损失<br>size规定<strong>最大位数(小数点左侧和右侧)</strong>，d规定<strong>小数点右侧的最大位数</strong>。</td></tr><tr><td>DECIMAL(size, d)</td><td><strong>以字符串的形式保存</strong>数值，<strong>不存在精度损失</strong>。<br>适用于<strong>存储货币</strong>等金融数据。</td></tr></tbody></table><ul><li>MySQL中没有专门<strong>存储货币</strong>的数据类型，一般情况下使用<strong>DECIMAL(8, 2)</strong>。</li></ul><hr><h3 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a>日期和时间数据类型</h3><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>DATE</td><td>日期，格式为<code>YYYY-MM-DD</code><br>支持的范围：1000-01-01~9999-12-31</td></tr><tr><td>TIME</td><td>时间，格式为<code>HH:MM:SS</code></td></tr><tr><td>DATETIME</td><td>DATE和TIME的组合<br>支持的范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>功能同DATETIME，<strong>格式更包容，但范围较小</strong><br>支持的范围：1970-01-01 00:00:01 UTC ~ 2038-01-09 03:14:07 UTC</td></tr><tr><td>YEAR</td><td>用2位数字表示，范围是70(1970)~69(2069)；<br>用4位数字表示，范围是1901~2155</td></tr></tbody></table><p> 即便<strong>DATETIME</strong>和<strong>TIMESTAMP</strong>返回相同的格式，它们的工作方式很不同。在<strong>INSERT</strong>或<strong>UPDATE</strong>查询中，<strong>TIMESTAMP自动把自身设置为当前的日期和时间</strong>。TIMESTAMP也接受不同的格式，比如<strong>YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD</strong></p><hr><h3 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h3><p>二进制数据类型<strong>可存储任何数据</strong>（甚至包括<strong>二进制信息</strong>），如图像、多媒体、字处理文档等。</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>BLOB</td><td>用于 BLOBs (Binary Large OBjects，<strong>二进制大型对象</strong>)。存放最多$2^{16}$B的数据</td></tr><tr><td>TINYBLOB</td><td>最大长度为$2^8-1$B</td></tr><tr><td>MEDIUMBLOB</td><td>最大长度为$2^{24}$B</td></tr><tr><td>LONGBLOB</td><td>最大长度为$2^{32}$B</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门到实践</title>
      <link href="/2020/06/13/Python%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/06/13/Python%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="变量和简单数据类型"><a href="#变量和简单数据类型" class="headerlink" title="变量和简单数据类型"></a>变量和简单数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在Python中，用引号(<strong>可以是单引号，也可以是双引号</strong>)括起的都是字符串。</p><h4 id="使用方法修改字符串的大小写"><a href="#使用方法修改字符串的大小写" class="headerlink" title="使用方法修改字符串的大小写"></a>使用方法修改字符串的大小写</h4><ul><li><p><code>title()</code>:</p><p>将字符串中<strong>每个单词</strong> <strong>首字母</strong>改为<strong>大写</strong>，<strong>其余字母小写</strong>。</p></li><li><p><code>upper()</code>：</p><p>将字符串中所有字母改为<strong>大</strong>写</p></li><li><p><code>lower()</code></p><p>将字符串中所有字母改为<strong>小</strong>写</p></li></ul><hr><h4 id="合并-拼接-字符串"><a href="#合并-拼接-字符串" class="headerlink" title="合并(拼接)字符串"></a>合并(拼接)字符串</h4><p>Python使用<code>+</code>来合并字符串。</p><hr><h4 id="使用方法删除多余的空格"><a href="#使用方法删除多余的空格" class="headerlink" title="使用方法删除多余的空格"></a>使用方法删除多余的空格</h4><ul><li><p><code>strip()</code>：</p><p>删除字符串<strong>首尾</strong>空格</p></li><li><p><code>lstrip()</code>:</p><p>删除字符串<strong>开头</strong>的空格</p></li><li><p><code>rstrip()</code>：</p><p>删除字符串<strong>末尾</strong>的空格</p></li></ul><hr><h4 id="将字符串中的特定单词都替换为另一个单词"><a href="#将字符串中的特定单词都替换为另一个单词" class="headerlink" title="将字符串中的特定单词都替换为另一个单词"></a>将字符串中的特定单词都替换为另一个单词</h4><p><code>replace()</code></p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">"I really like dogs."</span></span><br><span class="line">message.replace(<span class="string">'dog'</span>, <span class="string">'cat'</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="Python2中的print语句"><a href="#Python2中的print语句" class="headerlink" title="Python2中的print语句"></a>Python2中的print语句</h4><p>例如：<code>print &quot;Hello Python 2.7 world!&quot;</code></p><p><strong>无需</strong>将要打印的内容<strong>放在括号内</strong>。从技术上说，Python 3中的print是一个函数，因此括号必不可少。</p><hr><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul><li><p>Python用<code>**</code>表示<strong>次方</strong>运算</p><p>如<code>3**2</code>的结果为9。</p></li></ul><hr><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><hr><h4 id="使用函数str-避免类型错误"><a href="#使用函数str-避免类型错误" class="headerlink" title="使用函数str()避免类型错误"></a>使用函数str()避免类型错误</h4><p><code>str()</code>：<strong>将非字符串值表示为字符串</strong></p><hr><h4 id="Python-2中的整数"><a href="#Python-2中的整数" class="headerlink" title="Python 2中的整数"></a>Python 2中的整数</h4><p><strong>Python 2</strong>中，<strong>整数除法</strong>的<strong>结果只包含整数部分</strong>，<strong>小数部分直接被删除(没有四舍五入)</strong>。如果要避免这种情况，<strong>必须至少一个操作数为浮点数</strong>。</p><hr><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在Python中，用<strong>井号#</strong>标识注释。</p><hr><h2 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a>列表简介</h2><h3 id="列表是什么"><a href="#列表是什么" class="headerlink" title="列表是什么"></a>列表是什么</h3><p>列表由<strong>一系列按特定顺序排列的元素</strong>组成，像一个<strong>栈</strong>。可以创建包含字母表中所有字母、数字、所有家庭成员姓名的列表，也可以加入任何东西，<strong>其中的元素之间可以没有任何关系</strong>。</p><p>在Python中，用<strong>方括号[]</strong>表示列表，并用<strong>逗号来分隔</strong>其中的元素。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bicycles = [<span class="string">'trek'</span>, <span class="string">'cannondale'</span>, <span class="string">'redline'</span>, <span class="string">'specialized'</span>]</span><br><span class="line">print(bicycles)</span><br></pre></td></tr></table></figure><p>Python会打印列表的<strong>内部表示</strong>，<strong>包括方括号</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'trek'</span>, <span class="string">'cannondale'</span>, <span class="string">'redline'</span>, <span class="string">'specialized'</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h4><p>如<code>bicycles[0]</code>，请求获取列表元素时，<strong>Python只返回该元素，而不包括方括号和引号</strong>，是<strong>整洁干净的输出</strong>。</p><p>还可以对<strong>任何列表元素</strong>调用字符串方法。</p><hr><h4 id="索引从0开始"><a href="#索引从0开始" class="headerlink" title="索引从0开始"></a>索引从0开始</h4><ul><li><p>Python还为<strong>访问最后一个列表元素</strong>提供了一种特数语法：<strong>将索引指定为-1</strong>即可访问最后一个列表元素。<strong>这种约定也适用于其他负数索引</strong>，如<strong>-2</strong>返回<strong>倒数第二个</strong>列表元素，以此类推。</p><p>当<strong>列表为空</strong>时，这种<strong>访问最后一个元素的方式会导致错误</strong>。</p></li></ul><hr><h4 id="使用列表中的各个值"><a href="#使用列表中的各个值" class="headerlink" title="使用列表中的各个值"></a>使用列表中的各个值</h4><p>可以像使用其他变量一样使用列表中的各个值。</p><hr><h3 id="修改、添加和删除元素"><a href="#修改、添加和删除元素" class="headerlink" title="修改、添加和删除元素"></a>修改、添加和删除元素</h3><h4 id="修改列表元素"><a href="#修改列表元素" class="headerlink" title="修改列表元素"></a>修改列表元素</h4><p>指定列表名和要修改的元素的索引，再指定该元素的新值即可。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">motorcycles[<span class="number">0</span>] = <span class="string">'ducati'</span></span><br></pre></td></tr></table></figure><hr><h4 id="在列表中添加元素"><a href="#在列表中添加元素" class="headerlink" title="在列表中添加元素"></a>在列表中添加元素</h4><ul><li><p>在列表<strong>末尾添加</strong>元素：使用<code>append()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">motorcycles.append(<span class="string">'ducati'</span>)</span><br></pre></td></tr></table></figure><p><code>append()</code>方法让<strong>动态地创建列表</strong>易如反掌。</p></li><li><p>在列表中插入元素：使用<code>insert()</code>方法(需要指定新元素的索引和值)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">'ducati'</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h4><ul><li><p>使用<strong>del语句</strong>删除元素</p><p><strong>知道要删除的元素在列表中的位置</strong>，可以用del语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>删除元素后，其余元素索引会相应发生变动。</p></li><li><p>使用<strong>方法<code>pop()</code></strong>删除元素</p><p>方法<code>pop()</code>可以删除列表<strong>末尾元素</strong>，并<strong>能让你接着使用它</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popped_motorcycle = motorcycle.pop()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>弹出列表中<strong>任何位置</strong>处的元素</p><p>在方法<code>pop()</code>的括号中<strong>指定要删除元素的索引</strong>即可。</p><p>first_owned = motorcycles.pop(0)</p></li><li><p>使用<strong>方法<code>remove()</code>根据值删除元素</strong></p><p>不知道要从列表中删除的值所处的位置，只知道要删除元素的值是，可以使用<strong>方法<code>remove()</code></strong>。</p><p>方法<code>remove()</code><strong>只删除第一个</strong>指定的值。如果要删除的值可能在列表中出现多次，就需要<strong>使用循环来判断是否删除了所有这样的值</strong>。</p></li></ul><hr><h3 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h3><h4 id="使用方法sort-对列表进行永久性排序"><a href="#使用方法sort-对列表进行永久性排序" class="headerlink" title="使用方法sort()对列表进行永久性排序"></a>使用方法<code>sort()</code>对列表进行永久性排序</h4><ul><li>无参数：按<strong>字母顺序</strong>排序</li><li>填入参数<code>reverse=True</code>：按<strong>字母逆序</strong>排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字母顺序排序</span></span><br><span class="line">cars.sort()</span><br><span class="line"><span class="comment"># 得到结果cars = ['audi', 'bmw', 'subaru', 'toyota']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字母逆序排序</span></span><br><span class="line">cars.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(cars)</span><br><span class="line"><span class="comment"># 得到结果cars = ['toyota', 'subaru', 'bmw', 'audi']</span></span><br></pre></td></tr></table></figure><p><strong>并非所有的值都是小写时，按字母顺序排列列表要复杂些</strong>。决定排列顺序时，有多种解读大写字母的方式，要指定准确的排列顺序可能比较复杂。但是大多数排序方式都基于本节介绍的知识。</p><hr><h4 id="使用函数sorted-对列表进行临时排序"><a href="#使用函数sorted-对列表进行临时排序" class="headerlink" title="使用函数sorted()对列表进行临时排序"></a>使用函数<code>sorted()</code>对列表进行临时排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(sorted(cars))</span><br></pre></td></tr></table></figure><hr><h4 id="反转列表元素"><a href="#反转列表元素" class="headerlink" title="反转列表元素"></a>反转列表元素</h4><ul><li><p><code>reverse()</code>方法</p><p>注意：与<code>sort(reverse=True)</code>中的reverse作用不同。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.reverse()</span><br></pre></td></tr></table></figure><hr><h4 id="确定列表的长度"><a href="#确定列表的长度" class="headerlink" title="确定列表的长度"></a>确定列表的长度</h4><ul><li><code>len()</code>方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(cars)</span><br></pre></td></tr></table></figure><hr><h3 id="使用列表时避免索引错误"><a href="#使用列表时避免索引错误" class="headerlink" title="使用列表时避免索引错误"></a>使用列表时避免索引错误</h3><hr><p>错误示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">print(motorcycles[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>即类似其他语言的<strong>数组越界访问</strong>，会引起<strong>索引错误</strong>。</p><hr><h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><h3 id="遍历整个列表"><a href="#遍历整个列表" class="headerlink" title="遍历整个列表"></a>遍历整个列表</h3><p>语句为<code>for xxx in xxx:</code>（注意<strong>不要遗漏冒号</strong>）</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">magicians = [<span class="string">'alice'</span>, <span class="string">'david'</span>, <span class="string">'carolina'</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    print(magician)</span><br></pre></td></tr></table></figure><ul><li>编写for循环时，对于用于存储列表中每个值的<strong>临时变量，可指定任何名称</strong>。</li><li>Python根据<strong>缩进</strong>来判断<strong>代码行与前一个代码行的关系</strong>。在for循环后面，<strong>没有缩进</strong>的代码就<strong>不是循环的一部分</strong>。</li></ul><hr><h3 id="避免缩进错误"><a href="#避免缩进错误" class="headerlink" title="避免缩进错误"></a>避免缩进错误</h3><ul><li>两行独立的代码语句，如果不小心缩进，Python将会报错。</li></ul><hr><h3 id="创建数字列表"><a href="#创建数字列表" class="headerlink" title="创建数字列表"></a>创建数字列表</h3><h4 id="使用函数range"><a href="#使用函数range" class="headerlink" title="使用函数range()"></a>使用函数range()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>即输出范围<strong>左闭右开</strong>。</p><p>习题：使用一个for循环打印数字1~20(<strong>含</strong>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><hr><h4 id="使用range-创建数字列表"><a href="#使用range-创建数字列表" class="headerlink" title="使用range()创建数字列表"></a>使用range()创建数字列表</h4><ul><li>要创建数字列表，可使用函数<code>list()</code>将<code>range()</code>的结果直接转换成列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = list(range(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 得到numbers = [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><ul><li>使用range()函数还可以<strong>指定步长</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_numbers = list(range(<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 得到numbers = [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><ul><li>创建包含(1-10)的平方的数字列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    squares.append(value**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><p>对数字列表执行简单的<strong>统计计算</strong></p><ul><li><code>min()</code></li><li><code>max()</code></li><li><code>sum()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line">min(digits)</span><br><span class="line">max(digits)</span><br><span class="line">sum(digits)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h4><p>列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。</p><p>如创建平方数列表可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><p>要使用这种语法，首先<strong>指定一个描述性的列表名</strong>，如squares；然后<strong>定义一个表达式</strong>，用于<strong>生成要存储到列表中的值</strong>。</p><p>在上述例子中，表达式为<code>value**2</code></p><hr><h3 id="使用列表的一部分"><a href="#使用列表的一部分" class="headerlink" title="使用列表的一部分"></a>使用列表的一部分</h3><p>Python称<strong>列表的部分元素</strong>为<strong>切片</strong>。</p><hr><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>创建切片可指定要使用的<strong>第一个元素的索引</strong>和<strong>最后一个元素的索引+1</strong>(创建范围<strong>左闭右开</strong>)。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line">print(players[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><ul><li><p>如果<strong>没有指定第一个索引</strong>，Python将<strong>自动从列表开头开始</strong>：</p><p><code>player[:4]</code></p></li><li><p>要<strong>让切片终止于列表末尾</strong>，也可通过<strong>省略终止索引</strong>实现。</p><p><code>player[2:]</code></p></li><li><p>如果想输出<strong>最后三名</strong>队员，可通过切片<code>player[-3:]</code>实现</p></li></ul><hr><h4 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[:<span class="number">3</span>]:</span><br><span class="line">    print(player);</span><br></pre></td></tr></table></figure><hr><h4 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h4><p>要复制列表，可以通过<strong>同时省略起始索引和终止索引</strong>，<strong>创建一个包含整个列表的切片</strong>。</p><p>例如，假设有一个列表，其中包含你最喜欢的三种食品，而你还想创建另外一个列表，其中包含一位朋友喜欢的所有食物。不过你喜欢的视频，这位朋友都喜欢，因此可以通过复制来创建这个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">'pizza'</span>, <span class="string">'falafel'</span>, <span class="string">'carrot cake'</span>]</span><br><span class="line">friend_foods = my_foods[:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下直接赋值，无法得到两个独立的列表</span></span><br><span class="line">friend_foods = my_foods</span><br></pre></td></tr></table></figure><hr><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><strong>列表</strong>是<strong>可以修改</strong>的，非常适合用于存储<strong>在程序运行期间可能变化的数据集</strong>。但有时候需要创建一系列<strong>不可修改</strong>的元素，<strong>元组</strong>可以满足这种需求。</p><p>Python将<strong>不可变的列表</strong>称为<strong>元组</strong>。</p><hr><h4 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h4><p>元组看起来犹如列表，但<strong>使用圆括号</strong>来标识。</p><p>例如有一个大小不应改变的矩形，可将其长宽存储在一个元组中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="遍历元组中的所有值"><a href="#遍历元组中的所有值" class="headerlink" title="遍历元组中的所有值"></a>遍历元组中的所有值</h4><p>同遍历列表相同</p><hr><h4 id="修改元组变量"><a href="#修改元组变量" class="headerlink" title="修改元组变量"></a>修改元组变量</h4><p>虽然<strong>不能修改元组中的元素</strong>，但<strong>可以给存储元组的变量赋值</strong>。因此如果要修改前述矩形的尺寸，可<strong>重新定义整个元组</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新定义元组</span></span><br><span class="line">dimensions = (<span class="number">400</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="设置代码格式"><a href="#设置代码格式" class="headerlink" title="设置代码格式"></a>设置代码格式</h3><p><strong>PEP</strong>(Python Enhancement Proposal)：<strong>Python改进提案</strong>。</p><p>PEP 8是最古老的PEP之一，提供了代码格式设置指南。</p><hr><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>PEP 8建议每级缩进都使用<strong>四个空格</strong>，既提高可读性，又留下了足够的多级缩进空间。</p><p>在<strong>字处理文档</strong>中，大家<strong>常常使用 制表符 而不是 空格 来缩进</strong>。对于字处理文档来说，这样做的效果很好，但<strong>混合使用制表符和空格会让Python解释器感到迷惑</strong>。每款文本编辑器都提供了<strong>将输入的制表符转换为指定数量的空格</strong>的设置。在编写代码时应该使用制表符键，但<strong>一定要对编辑器进行设置，使其在文档中插入空格而不是制表符</strong>。</p><hr><h4 id="行长"><a href="#行长" class="headerlink" title="行长"></a>行长</h4><p>建议<strong>每行不超过80字符</strong>,PEP 8还建议<strong>注释的行长</strong>都<strong>不超过72字符</strong>，因为有些工具为大型项目自动生成文档时，会在每行注释开头添加格式化字符。在大多数编辑器中，都可以设置一个<strong>视觉标志</strong>——通常是一条<strong>垂直参考线</strong>，让我们知道<strong>不能越过的界限</strong>在什么地方。</p><hr><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><p><strong>值为True或False的表达式</strong>被称为<strong>条件测试</strong>。</p><h4 id="检查是否相等时，大小写的影响"><a href="#检查是否相等时，大小写的影响" class="headerlink" title="检查是否相等时，大小写的影响"></a>检查是否相等时，大小写的影响</h4><ul><li><p>在Python中检查是否相等时<strong>区分大小写</strong>，两个<strong>大小写不同的值会被视为不相等</strong>。</p></li><li><p>如果<strong>大小写无关紧要</strong>，可<strong>将变量的值转换为小写</strong>，再进行比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">'Audi'</span></span><br><span class="line">car.lower() == <span class="string">'audi'</span></span><br><span class="line"><span class="comment"># 结果为True</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="检查多个条件"><a href="#检查多个条件" class="headerlink" title="检查多个条件"></a>检查多个条件</h4><ul><li>使用<strong>and</strong>检查多个条件(Java/C/C++ 中为 <strong>&amp;&amp;</strong>)</li><li>使用<strong>or</strong>检查多个条件(Java/C/C++ 中为 <strong>||</strong>)</li></ul><hr><h4 id="检查特定值是否包含在列表中"><a href="#检查特定值是否包含在列表中" class="headerlink" title="检查特定值是否包含在列表中"></a>检查特定值是否包含在列表中</h4><p>有时候，执行操作前必须检查列表是否包含特定的值。例如，结束用户的注册过程前，可能需要检查用户名是否已包含在用户名列表中。在地图程序中，可能需要检查用户提交的位置是否包含在已知位置列表中。</p><p>要判断特定的值是否已包含在列表中，可使用<strong>关键字in</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">'mushrooms'</span>, <span class="string">'onions'</span>, <span class="string">'pineapple'</span>]</span><br><span class="line">print(<span class="string">'mushrooms'</span> <span class="keyword">in</span> requested_toppings)</span><br></pre></td></tr></table></figure><hr><h4 id="检查特定值是否不包含在列表中"><a href="#检查特定值是否不包含在列表中" class="headerlink" title="检查特定值是否不包含在列表中"></a>检查特定值是否不包含在列表中</h4><p>使用关键字<strong>not in</strong>。例如，如果有一个列表，其中包含被禁止在论坛上发表评论的用户，就可在允许用户提交评论前检查他是否被禁言：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">banned_users = [<span class="string">'andrew'</span>, <span class="string">'carolina'</span>, <span class="string">'david'</span>]</span><br><span class="line">user = <span class="string">'marie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">not</span> <span class="keyword">in</span> banned_users:</span><br><span class="line">    print(user.title() + <span class="string">", you can post a response if you wish."</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h4><p>布尔表达式不过是<strong>条件测试的别名</strong>。</p><p><strong>布尔值通常用于记录条件</strong>，如游戏是否正在运行，或用户是否可以编辑网站的特定内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">game_active = <span class="literal">True</span></span><br><span class="line">can_edit = <span class="literal">False</span></span><br></pre></td></tr></table></figure><hr><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><h4 id="简单的-if-语句"><a href="#简单的-if-语句" class="headerlink" title="简单的 if 语句"></a>简单的 if 语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> conditional_test:</span><br><span class="line">    do something</span><br></pre></td></tr></table></figure><p>假设有一个表示某人年龄的变量，而你想知道这个人是否够投票的年龄，可使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">print(<span class="string">"You are old enough to vote!"</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if - else 语句"></a>if - else 语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">print(<span class="string">"You are old enough to vote!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">"Sorry, you are too young to vote."</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="if-elif-else-结构"><a href="#if-elif-else-结构" class="headerlink" title="if - elif - else 结构"></a>if - elif - else 结构</h4><p>在现实世界中，很多情况下需要考虑的情形都超过两个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    price = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">print(<span class="string">"Your admission cost is $"</span> + str(price) + <span class="string">"."</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="使用if语句处理列表"><a href="#使用if语句处理列表" class="headerlink" title="使用if语句处理列表"></a>使用if语句处理列表</h3><h4 id="检查特殊元素"><a href="#检查特殊元素" class="headerlink" title="检查特殊元素"></a>检查特殊元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">'mushrooms'</span>. <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> requested_topping == <span class="string">'green peppers'</span>:</span><br><span class="line">        print(<span class="string">"Sorry, we are out of green peppers right now."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Adding "</span> + requested_topping + <span class="string">'.'</span>)</span><br><span class="line">        </span><br><span class="line">print(<span class="string">"\nFinished making your pizza!"</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="确定列表不是空的"><a href="#确定列表不是空的" class="headerlink" title="确定列表不是空的"></a>确定列表不是空的</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> requested_toppings:</span><br><span class="line">    <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">        print(<span class="string">"Adding "</span> + requested_topping + <span class="string">'.'</span>)    </span><br><span class="line">    print(<span class="string">"\nFinished making your pizza!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Are you sure you want a plain pizza?"</span>)</span><br></pre></td></tr></table></figure><ul><li>在<strong>if语句</strong>中<strong>将 列表名 用在条件表达式中</strong>时，Python将<strong>在列表至少包含一个元素时</strong>返回<strong>True</strong>，并在<strong>列表为空时</strong>返回<strong>False</strong>。</li></ul><hr><h4 id="使用多个列表"><a href="#使用多个列表" class="headerlink" title="使用多个列表"></a>使用多个列表</h4><p>下列示例定义两个列表，其中第一个列表包含<strong>披萨店供应的</strong>配料，第二个列表包含<strong>顾客点的</strong>配料。这次对于顾客要求的每个配料，都检查是否时披萨店供应的配料：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">avaliable_toppings = [<span class="string">'mushrooms'</span>, <span class="string">'olives'</span>, <span class="string">'green peppers'</span>,</span><br><span class="line">                     <span class="string">'pepperoni'</span>, <span class="string">'pineapple'</span>, <span class="string">'extra cheese'</span>]</span><br><span class="line">requested_toppings = [<span class="string">'mushrooms'</span>. <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> requested_topping <span class="keyword">in</span> avaliable_toppings:</span><br><span class="line">        print(<span class="string">"Adding "</span> + requested_topping + <span class="string">"."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Sorry, we don't have "</span> + requested_topping + <span class="string">"."</span>)</span><br><span class="line">print(<span class="string">"\nFinished making your pizza!"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li><p><strong>列表</strong>：用<strong>方</strong>括号<code>[]</code>标识</p></li><li><p><strong>元组</strong>：用<strong>圆</strong>括号<code>()</code>标识(<strong>不可修改</strong>)</p></li><li><strong>字典</strong>：用<strong>花</strong>括号<code>{}</code>标识</li></ul><hr><h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><p>在Python中，<strong>字典</strong>是一系列 <strong>键-值 对</strong>。每个键都与一个值相关联，可以<strong>使用键来访问与之相关联的值</strong>，<strong>可以将任何Python对象用作字典中的值</strong>。</p><p><strong>键和值之间</strong>用<strong>冒号</strong><code>:</code>分隔，<strong>键-值对之间</strong>用<strong>逗号</strong>分隔。如：<code>alien_0 = {&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5}</code></p><hr><h4 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h4><p>要获取与键相关联的<strong>值</strong>，可依次<strong>指定字典名</strong>和<strong>放在方括号内的键</strong>。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br><span class="line">new_points = alien_0[<span class="string">'points'</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="添加-键-值-对"><a href="#添加-键-值-对" class="headerlink" title="添加 键-值 对"></a>添加 键-值 对</h4><p><strong>字典是一种动态结构</strong>，<strong>可随时添加 键-值 对</strong>。要添加 键-值 对，可依次指定<strong>字典名</strong>、用<strong>方括号括起的键</strong>和<strong>相关联的值</strong>。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alien_0[<span class="string">'x_position'</span>] = <span class="number">0</span></span><br><span class="line">alien_0[<span class="string">'y_position'</span>] = <span class="number">25</span></span><br></pre></td></tr></table></figure><ul><li>键-值 对的<strong>排列顺序</strong>与<strong>添加顺序</strong>不同。Python<strong>只关心</strong> 键-值 对之间的<strong>关联关系</strong>。</li></ul><hr><h4 id="先创建一个空字典"><a href="#先创建一个空字典" class="headerlink" title="先创建一个空字典"></a>先创建一个空字典</h4><p>可先使用一对<strong>空的花括号</strong>定义一个字典，再<strong>分行添加</strong>各个 键-值 对。</p><p><strong>使用字典</strong>来<strong>存储用户提供的数据</strong>或在<strong>编写能自动生成大量 键-值 对的代码</strong>时，通常都需要<strong>先定义一个空字典</strong>。</p><hr><h4 id="修改字典中的值"><a href="#修改字典中的值" class="headerlink" title="修改字典中的值"></a>修改字典中的值</h4><p>修改字典中的值，可<strong>依次指定字典名</strong>、用方括号括起的<strong>键</strong>以及与该键相关联的<strong>新值</strong>。</p><hr><h4 id="删除-键-值-对"><a href="#删除-键-值-对" class="headerlink" title="删除 键-值 对"></a>删除 键-值 对</h4><p>对于字典中不再需要的信息，可使用<strong>del语句</strong>将相应的 键-值 对彻底删除。使用del语句时，必须<strong>指定字典名</strong>和<strong>要删除的键</strong>。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> alien_0[<span class="string">'points'</span>]</span><br></pre></td></tr></table></figure><ul><li>删除的 键-值 对<strong>永远消失</strong>了</li></ul><hr><h4 id="由类似对象组成的字典"><a href="#由类似对象组成的字典" class="headerlink" title="由类似对象组成的字典"></a>由类似对象组成的字典</h4><p>字典可以存储<strong>一个对象的多种信息</strong>，也可以存储<strong>众多对象的同一种信息</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line">    <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line">    <span class="string">'phil'</span>: <span class="string">'python'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><h4 id="遍历所有的-键-值-对"><a href="#遍历所有的-键-值-对" class="headerlink" title="遍历所有的 键-值 对"></a>遍历所有的 键-值 对</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123;</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'efermi'</span>.</span><br><span class="line">    <span class="string">'first'</span>: <span class="string">'enrico'</span>,</span><br><span class="line">    <span class="string">'last'</span>: <span class="string">'fermi'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_0.items():</span><br><span class="line">    print(<span class="string">"\nKey: "</span> + key)</span><br><span class="line">    print(<span class="string">"Value: "</span> + value)</span><br></pre></td></tr></table></figure><p>如例子所示，要编写用于<strong>遍历字典</strong>的for循环。可声明<strong>两个变量</strong>用于<strong>存储键和值</strong>，这两个变量可以使用任何名称。</p><ul><li>方法<code>items()</code>返回一个 <strong>键-值 对列表</strong></li><li>即使遍历字典时，键-值 对的<strong>返回顺序</strong>也<strong>与存储顺序不同</strong>。</li></ul><hr><h4 id="遍历字典中的所有键"><a href="#遍历字典中的所有键" class="headerlink" title="遍历字典中的所有键"></a>遍历字典中的所有键</h4><ul><li><p>方法<code>keys()</code>返回一个<strong>键列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(name.title())</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历字典</strong>时，会<strong>默认遍历</strong>所有的<strong>键</strong>。因此<code>for name in favorite_languages.keys():</code>和<code>for name in favorite_languages:</code><strong>效果相同</strong>。</p></li></ul><p>下面遍历一下字典中的名字，但在<strong>名字为指定朋友的名字时</strong>，打印一条消息，指出其喜欢的语言：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">friends = [<span class="string">'phil'</span>, <span class="string">'sarah'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(name.title())</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> friends:</span><br><span class="line">        print(<span class="string">" Hi "</span> + name.title() +</span><br><span class="line">             <span class="string">", I see your favorite language is "</span> +</span><br><span class="line">             favorite_languages[name].title() + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><ul><li><p>还可以使用keys()确定某个人是否接受了调查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'erin'</span> <span class="keyword">not</span> <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(<span class="string">"Erin, please take our poll!"</span>)</span><br></pre></td></tr></table></figure></li><li><p>方法<code>keys()</code><strong>并非只能用于遍历</strong>，实际上，它返回一个包含字典中所有键的列表。</p></li></ul><hr><h4 id="按顺序遍历字典中的所有键"><a href="#按顺序遍历字典中的所有键" class="headerlink" title="按顺序遍历字典中的所有键"></a>按顺序遍历字典中的所有键</h4><p>要以<strong>特定的顺序</strong>返回元素，一种办法是在for循环中<strong>对返回的键进行排序</strong>。为此，可以使用函数<code>sorted()</code>(<strong>临时排序</strong>)来获得按特定顺序排列的<strong>键列表的副本</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> sorted(favorite_languages.keys()):</span><br><span class="line">    print(name.title() + <span class="string">", thank you for taking the poll."</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="遍历字典中的所有值"><a href="#遍历字典中的所有值" class="headerlink" title="遍历字典中的所有值"></a>遍历字典中的所有值</h4><ul><li><p>方法<code>values()</code>返回一个<strong>值列表</strong></p><p>这种做法提取字典中所有的值，<strong>没有考虑是否重复</strong>。为<strong>剔除重复项</strong>，可使用<strong>集合</strong>(<strong>set</strong>)。(在C/C++中，set是一个<strong>内部自动递增排序</strong>且<strong>不含重复元素</strong>的容器)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> set(favorite_languages.values()):</span><br><span class="line">    print(language.title())</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><h4 id="在列表中存储字典"><a href="#在列表中存储字典" class="headerlink" title="在列表中存储字典"></a>在列表中存储字典</h4><p>字典alien_0包含一个外星人的各种信息，但无法存储第二个外星人的信息。如何管理<strong>成群结队的外星人</strong>呢？一种办法是创建一个外星人<strong>列表</strong>，其中每个外星人都是一个<strong>字典</strong>，包含有关该外星人的各种信息(即<strong>字典列表</strong>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个用于存储外星人的空列表</span></span><br><span class="line">aliens = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建30个绿色的外星人</span></span><br><span class="line"><span class="keyword">for</span> alien_number <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">30</span>):</span><br><span class="line">    new_alien = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>, <span class="string">'speed'</span>: <span class="string">'slow'</span>&#125;</span><br><span class="line">    aliens.append(new_alien)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 显示前五个外星人</span></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[:<span class="number">5</span>]:</span><br><span class="line">    print(alien)</span><br><span class="line">print(<span class="string">"..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示创建了多少个外星人</span></span><br><span class="line">print(<span class="string">"Total number of aliens: "</span> + str(len(aliens)))</span><br></pre></td></tr></table></figure><ul><li>获取<strong>列表长度</strong>：函数<code>len(列表名)</code></li></ul><hr><h4 id="在字典中存储列表"><a href="#在字典中存储列表" class="headerlink" title="在字典中存储列表"></a>在字典中存储列表</h4><p>有时候，需要将列表存储在字典中。例如，你要如何描述顾客点的披萨呢？如果使用列表，只能存储要添加的披萨配料；但使用字典，还可以包含其他有关披萨的描述。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pizza = &#123;</span><br><span class="line">    <span class="string">'crust'</span>: <span class="string">'thick'</span>,</span><br><span class="line">    <span class="string">'toppings'</span>: [<span class="string">'mushrooms'</span>, <span class="string">'extra cheese'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">'topping'</span>]:</span><br><span class="line">    print(<span class="string">"\t"</span> + topping)</span><br></pre></td></tr></table></figure><ul><li>每当需要在字典中<strong>将一个键关联到多个值</strong>时，都可以<strong>在字典中嵌套一个列表</strong>。</li></ul><p>在本章前面有关<strong>喜欢的编程语言</strong>的示例中，如果将每个人的回答都存储在一个列表中，被调查者就<strong>可以选择多种喜欢的语言</strong>。因此，在遍历该字典的for循环中，我们需要再使用一个for循环来遍历与被调查者相关联的语言列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: [<span class="string">'python'</span>, <span class="string">'ruby'</span>],</span><br><span class="line">    <span class="string">'sarah'</span>: [<span class="string">'c'</span>],</span><br><span class="line">    <span class="string">'edward'</span>: [<span class="string">'ruby'</span>, <span class="string">'go'</span>],</span><br><span class="line">    <span class="string">'phil'</span>: [<span class="string">'python'</span>, <span class="string">'haskell'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    print(<span class="string">"\n"</span> + name.title() + <span class="string">" 's favorite languages are:"</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages:</span><br><span class="line">        print(<span class="string">"\t"</span> + language.title())</span><br></pre></td></tr></table></figure><hr><h4 id="在字典中存储字典"><a href="#在字典中存储字典" class="headerlink" title="在字典中存储字典"></a>在字典中存储字典</h4><p>可以在字典中嵌套字典，但这样做时，代码可能很快复杂起来。</p><hr><h3 id="将列表转换为字典"><a href="#将列表转换为字典" class="headerlink" title="将列表转换为字典"></a>将列表转换为字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="用户输入和while循环"><a href="#用户输入和while循环" class="headerlink" title="用户输入和while循环"></a>用户输入和while循环</h2><h3 id="函数input-的工作原理"><a href="#函数input-的工作原理" class="headerlink" title="函数input()的工作原理"></a>函数input()的工作原理</h3><p>函数input()让程序暂停运行，等待用户输入一些<strong>文本</strong>。<strong>获取用户输入后，Python将其存储在一个变量中，Python将用户输入解读为字符串</strong>。</p><p>例如，下面的程序让用户输入一些文本，再将这些文本呈现给用户：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = input(<span class="string">"Tell me something, and I will repeat it back to you: "</span>)</span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><ul><li>函数input()<strong>接受一个参数</strong>，即要向用户显示的<strong>提示或说明</strong>。</li><li>程序等待用户输入，并在用户<strong>按回车键后继续运行</strong>。</li></ul><hr><h4 id="编写清晰的程序"><a href="#编写清晰的程序" class="headerlink" title="编写清晰的程序"></a>编写清晰的程序</h4><p>有时候，<strong>提示可能超过一行</strong>，例如，你可能需要指出获取特定输入的原因。这种情况下，可将提示存储再一个变量中，再将该变量传递给函数input()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">"If you tell us who you are, we can personalize the messages you see."</span></span><br><span class="line">prompt += <span class="string">"\nwhat is your first name? "</span></span><br><span class="line"></span><br><span class="line">name = input(prompt)</span><br></pre></td></tr></table></figure><hr><h4 id="使用int-来获取数值输入"><a href="#使用int-来获取数值输入" class="headerlink" title="使用int()来获取数值输入"></a>使用int()来获取数值输入</h4><p>函数<code>int()</code>让Python<strong>将输入视为数值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height = input(<span class="string">"How tall are you, in inches? "</span>)</span><br><span class="line">height = int(height)</span><br></pre></td></tr></table></figure><hr><h4 id="在Python-2-7-中获取输入"><a href="#在Python-2-7-中获取输入" class="headerlink" title="在Python 2.7 中获取输入"></a>在Python 2.7 中获取输入</h4><p>Python 2.7应使用函数<code>raw_input()</code>来提示用户输入，这个函数与Python 3 中的<code>nput()</code>一样，将输入解读为字符串。</p><p>Python 2.7 也包含函数<code>input()</code>，但它将用户输入解读为Python代码，并尝试运行它们。因此最好的结果是出现错误，指出Python不明白输入的代码；最糟糕的结果是，将运行原本无意运行的代码。</p><hr><h3 id="while循环简介"><a href="#while循环简介" class="headerlink" title="while循环简介"></a>while循环简介</h3><h4 id="使用标志"><a href="#使用标志" class="headerlink" title="使用标志"></a>使用标志</h4><p>在要求<strong>很多条件都满足才继续运行</strong>的程序中，可<strong>定义一个变量，用于判断真个程序是否处于活动状态</strong>，这个变量被称为<strong>标志</strong>。这样，在while语句中，<strong>只需检查一个条件</strong>——<strong>while的当前值是否为True</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">active = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> active:</span><br><span class="line">    message = input()</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">'quit'</span>:</span><br><span class="line">        active = false</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br></pre></td></tr></table></figure><hr><h4 id="使用-break-退出循环"><a href="#使用-break-退出循环" class="headerlink" title="使用 break 退出循环"></a>使用 break 退出循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    city = input()</span><br><span class="line">    <span class="keyword">if</span> city == <span class="string">'quit'</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"xxxxx"</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="在循环中使用-continue"><a href="#在循环中使用-continue" class="headerlink" title="在循环中使用 continue"></a>在循环中使用 continue</h4><hr><h4 id="避免无限循环"><a href="#避免无限循环" class="headerlink" title="避免无限循环"></a>避免无限循环</h4><p>如果程序陷入无限循环，可按<code>Ctrl</code> + <code>C</code>，也可关闭显示程序输出的终端窗口。</p><p>有些编辑器(如 Sublime Text)内嵌了输出窗口，这可能导致难以结束无限循环，因此不得不关闭编辑器来结束无限循环。</p><hr><h3 id="使用-While-循环来处理列表和字典"><a href="#使用-While-循环来处理列表和字典" class="headerlink" title="使用 While 循环来处理列表和字典"></a>使用 While 循环来处理列表和字典</h3><p>for循环是一种遍历列表的有效方式，但<strong>在for循环中不应修改列表，否则将导致Python难以跟踪其中的元素</strong>。要在<strong>遍历列表的同时对其进行修改</strong>，可使用<strong>while循环</strong>。将while循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。</p><hr><h4 id="在列表之间移动元素"><a href="#在列表之间移动元素" class="headerlink" title="在列表之间移动元素"></a>在列表之间移动元素</h4><p>假设一个列表，其中包含新注册但还未验证的网站用户；<strong>验证这些用户后，如何将他们移到另一个已验证用户列表中呢</strong>？一种办法是<strong>使用一个while循环，在验证用户的同时将其从未验证用户列表中提取出来，再将其加入到另一个已验证用户列表中</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unconfirmed_users = [<span class="string">'alice'</span>, <span class="string">'brian'</span>, <span class="string">'candace'</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证每个用户，直到没有未验证用户为止</span></span><br><span class="line"><span class="comment"># 将每个经过验证的用户都移到已验证用户列表中</span></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = unconfirmed_users.pop()</span><br><span class="line">    confirmed_user.append(current_user)</span><br></pre></td></tr></table></figure><ul><li>方法<code>pop()</code>删除列表末尾用户</li></ul><hr><h4 id="删除包含特定值的所有列表元素"><a href="#删除包含特定值的所有列表元素" class="headerlink" title="删除包含特定值的所有列表元素"></a>删除包含特定值的所有列表元素</h4><p>在第3章中，我们使用方法<code>remove()</code>删除列表中的特定值(<strong>只删除第一个</strong>指定的值)。如果要删除列表中所有包含特定值的元素，该怎么办？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'goldfish'</span>, <span class="string">'cat'</span>, <span class="string">'rabbit'</span>, <span class="string">'cat'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> pets:</span><br><span class="line">    pets.remove(<span class="string">'cat'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="现有函数"><a href="#现有函数" class="headerlink" title="现有函数"></a>现有函数</h3><ul><li><code>round(number, ndigits=None)</code><ul><li><code>number</code>：需要进行四舍五入的数字</li><li><code>ndigits</code>： 指定的<strong>位数</strong>，按此位数进行<strong>四舍五入</strong></li></ul></li></ul><hr><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>下面是一个打印问候语的简单函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示简单的问候语"""</span></span><br><span class="line">    print(<span class="string">"Hello!"</span>)</span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><ul><li>使用<strong>关键字def</strong>告诉Python要<strong>定义一个函数</strong>，定义<strong>以冒号结尾</strong>。</li><li>第二行的文本<code>&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</code>是被称为<strong>文档字符串(docstring)</strong>的<strong>注释</strong>。<strong>文档字符串</strong>用<strong>三引号</strong>括起，Python<strong>用它们来生成</strong>有关程序中<strong>函数的文档</strong></li></ul><hr><h4 id="向函数传递信息"><a href="#向函数传递信息" class="headerlink" title="向函数传递信息"></a>向函数传递信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="string">"""显示简单的问候语"""</span></span><br><span class="line">    print(<span class="string">"Hello, "</span> + username.title() + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">greet_user(<span class="string">'jesse'</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h4><p>向函数传递实参的方式很多，可使用<strong>位置实参</strong>，这<strong>要求实参的顺序与形参的顺序相同</strong>；也可使用<strong>关键字实参</strong>，其中每个实参都<strong>由形参名和值组成</strong>；还可使用<strong>列表和字典</strong>。</p><ul><li><p><strong>关键字</strong>实参(顺序无关紧要)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(animal_type, pet_name)</span>:</span></span><br><span class="line">    <span class="string">"""显示宠物的信息"""</span></span><br><span class="line">    print(<span class="string">"\nI have a "</span> + animal_type + <span class="string">"."</span>)</span><br><span class="line">    print(<span class="string">"My "</span> + animal_type + <span class="string">"'s name is "</span> + pet_name.title() + <span class="string">"."</span>)</span><br><span class="line">    </span><br><span class="line">describe_pet(animal_type=<span class="string">'hamster'</span>, pet_name = <span class="string">'harry'</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>编写函数时，可<strong>为每个形参指定默认值</strong>，那么在函数调用中就可以省略相应的实参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(pet_name, animal_type=<span class="string">'dog'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""显示宠物的信息"""</span></span><br><span class="line">    print(<span class="string">"\nI have a "</span> + animal_type + <span class="string">"."</span>)</span><br><span class="line">    print(<span class="string">"My "</span> + animal_type + <span class="string">"'s name is "</span> + pet_name.title() + <span class="string">"."</span>)</span><br><span class="line">    </span><br><span class="line">describe_pet(pet_name=<span class="string">'willie'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>由于给animal_type 指定了默认值，因此在函数调用中只包含一个实参——宠物的名字。然而，Python依然将这个实参<strong>视为位置实参</strong>，因此如果函数调用中<strong>只包含宠物的名字，这个实参将关联到函数定义中的第一个形参</strong>，因此<strong>需要将pet_name放在形参列表开头</strong>。这样，就能在函数调用中只提供小狗的名字了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe_pet(<span class="string">'willie'</span>)</span><br></pre></td></tr></table></figure></li><li><p>被指定默认值的形参，可以通过<strong>显式地提供实参</strong>来<strong>忽略默认值</strong>。</p></li></ul><hr><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h4 id="返回简单值"><a href="#返回简单值" class="headerlink" title="返回简单值"></a>返回简单值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first_name, last_name)</span>:</span></span><br><span class="line">    <span class="string">"""返回整洁的姓名"""</span></span><br><span class="line">    full_name = first_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line">musician = get_formatted_name(<span class="string">'jimi'</span>, <span class="string">'hendrix'</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="让实参变成可选的"><a href="#让实参变成可选的" class="headerlink" title="让实参变成可选的"></a>让实参变成可选的</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first_name, last_name, middle_name=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="string">"""返回整洁的姓名"""</span></span><br><span class="line">    <span class="keyword">if</span> middle_name:</span><br><span class="line">        full_name = first_name + <span class="string">' '</span> + middle_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><ul><li>Python将<strong>非空字符串</strong>解读为<strong>True</strong></li></ul><hr><h4 id="返回字典"><a href="#返回字典" class="headerlink" title="返回字典"></a>返回字典</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_person</span><span class="params">(first_name, last_name, age=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个字典，其中包含有关一个人的信息"""</span></span><br><span class="line">    person = &#123;<span class="string">'first'</span>: first_name, <span class="string">'last'</span>: last_name&#125;</span><br><span class="line">    <span class="keyword">if</span> age:</span><br><span class="line">        person[<span class="string">'age'</span>] = age</span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line"></span><br><span class="line">musician = build_person(<span class="string">'jimi'</span>, <span class="string">'hendrix'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="传递列表"><a href="#传递列表" class="headerlink" title="传递列表"></a>传递列表</h3><p>假设有一个用户列表，我们要问候其中的每位用户。下面的示例将一个名字列表传递给一个名为greet_users()的函数，这个函数问候列表中的每个人：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span><span class="params">(names)</span>:</span></span><br><span class="line">    <span class="string">"""向列表中的每位用户都发出简单的问候"""</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        msg = <span class="string">"Hello, "</span> + name.title() + <span class="string">"!"</span></span><br><span class="line">        print(msg)</span><br><span class="line">        </span><br><span class="line">usernames = [<span class="string">'hannah'</span>, <span class="string">'ty'</span>, <span class="string">'margot'</span>]</span><br><span class="line">greet_users(usernames)</span><br></pre></td></tr></table></figure><hr><h4 id="禁止函数修改列表"><a href="#禁止函数修改列表" class="headerlink" title="禁止函数修改列表"></a>禁止函数修改列表</h4><p>为了防止函数修改列表，可<strong>向函数传递列表的副本而不是原件</strong>。</p><p>要<strong>将列表的副本传递给函数</strong>，可以像下面这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name(list_name[:])</span><br></pre></td></tr></table></figure><ul><li><strong>切片表示法</strong><code>[:]</code><strong>创建列表的副本</strong></li></ul><p>虽然像函数传递列表的副本可保留原始列表的内容，但<strong>除非有充分的理由需要传递副本</strong>，<strong>否则还是应该将原始列表传递给函数</strong>。因为让函数<strong>使用现成列表</strong>可<strong>避免花时间和内存创建副本</strong>，从而提高效率，在<strong>处理大型列表</strong>时尤其如此。</p><hr><h3 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h3><p>有时候，你预先不知道函数需要接受多少个实参，好在<strong>Python允许函数从调用语句中收集任意数量的实参</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(*toppings)</span>:</span></span><br><span class="line">    <span class="string">"""打印顾客点的所有配料"""</span></span><br><span class="line">    print(toppings)</span><br><span class="line">    </span><br><span class="line">make_pizza(<span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(<span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure><ul><li>形参名<code>*toppings</code>中的<strong>星号</strong><code>*</code>让Python创建一个名为toppings的<strong>空元组</strong>(用<strong>圆括号</strong><code>()</code>标识，<strong>不可修改</strong>)，并将收到的所有值都封装到这个元组中。</li></ul><hr><h4 id="结合使用位置实参和任意数量实参"><a href="#结合使用位置实参和任意数量实参" class="headerlink" title="结合使用位置实参和任意数量实参"></a>结合使用位置实参和任意数量实参</h4><p>如果要让函数<strong>接受不同类型的实参</strong>，必须在函数定义中<strong>将接纳任意数量实参的形参放在最后</strong>。Python<strong>先匹配位置实参</strong>和<strong>关键字实参</strong>，再<strong>将余下的实参都收集到最后一个形参中</strong>。</p><p>例如，如果前面的函数<strong>还需要一个表示披萨尺寸的实参</strong>，<strong>必须</strong>将该形参放在形参<code>*toppings</code><strong>前面</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(size, *toppings)</span>:</span></span><br><span class="line">    <span class="string">"""概述要制作的披萨"""</span></span><br><span class="line">    print(<span class="string">"\nMaking a "</span> + str(size) +</span><br><span class="line">         <span class="string">"-inch pizza with the following toppings:"</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        print(<span class="string">"- "</span> + topping)</span><br><span class="line">    </span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="使用任意数量的关键字实参"><a href="#使用任意数量的关键字实参" class="headerlink" title="使用任意数量的关键字实参"></a>使用任意数量的关键字实参</h4><p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。可<strong>将函数编写成能够接受任意数量的 键-值 对</strong>——调用语句提供了多少就接受多少。</p><p>一个示例是创建用户简介：你知道将受到有关用户的信息，但不确定是什么样的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span><span class="params">(first, last, **user_info)</span>:</span></span><br><span class="line">    <span class="string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span></span><br><span class="line">    profile = &#123;&#125;</span><br><span class="line">    profile[<span class="string">'first_name'</span>] = first</span><br><span class="line">    profile[<span class="string">'last_name'</span>] = last</span><br><span class="line">    <span class="keyword">for</span> key, vaule <span class="keyword">in</span> user_info.items():</span><br><span class="line">        profile[key] = value</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line"></span><br><span class="line">user_profile = build_profile(<span class="string">'albert'</span>, <span class="string">'einstein'</span>,</span><br><span class="line">                            location=<span class="string">'princeton'</span>,</span><br><span class="line">                            field=<span class="string">'physics'</span>)</span><br></pre></td></tr></table></figure><ul><li>形参名<code>**user_info</code>中的<strong>两个星号</strong><code>**</code>让Python创建一个名为user_info的<strong>空字典</strong>(用<strong>花括号</strong><code>{}</code>标识)，并将收到的所有 名称-值 对都封装到这个字典中。</li></ul><hr><h3 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a>将函数存储在模块中</h3><p>使用函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。还可以更进一步，将函数<strong>存储在被称为模块的独立文件中</strong>，<strong>再将模块导入到主程序中</strong>。<strong>import语句</strong>允许<strong>在当前运行的程序文件中使用模块中的代码</strong>。</p><h4 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h4><p>要让函数是<strong>可导入</strong>的，得<strong>先创建模块</strong>。模块是<strong>扩展名为<code>.py</code>的文件</strong>，<strong>包含要导入到程序中的代码</strong>。</p><p>下面来<strong>创建一个包含函数<code>make_pizza()</code>的模块</strong>。为此，我们将文件pizza.py中除函数<code>make_pizza()</code>之外的其他代码都删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(size, *toppings)</span>:</span></span><br><span class="line">    <span class="string">"""概述要制作的披萨"""</span></span><br><span class="line">    print(<span class="string">"\nMaking a "</span> + str(size) +</span><br><span class="line">         <span class="string">"-inch pizza with the following toppings:"</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        print(<span class="string">"- "</span> + topping)</span><br></pre></td></tr></table></figure><p>接下来，我们在<strong>pizza.py所在的目录中</strong>创建另一个名为making_pizzas.py的文件，这个文件<strong>导入到刚创建的模块</strong>，再调用make_pizza()两次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line"></span><br><span class="line">pizza.make_pizza(<span class="number">16</span>, <span class="string">'pepperoni'</span>)</span><br><span class="line">pizza.make_pizza(<span class="number">12</span>, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>Python读取这个文件时，代码行<code>import pizza</code>让Python打开pizza.py，并<strong>将其中的所有函数都复制到这个程序中</strong>。</p></li><li><p><strong>要调用被导入的模块中的函数</strong>，可<strong>指定导入的模块的名称</strong>pizza<strong>和函数名</strong>make_pizza()，<strong>并用句点分隔它们</strong>。如果你使用这种import语句导入了名为module_name.py的整个模块，就可使用下面的语法来使用其中任何一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_name.function_name()</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="导入特定的函数"><a href="#导入特定的函数" class="headerlink" title="导入特定的函数"></a>导入特定的函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_0, function_1, function_2</span><br></pre></td></tr></table></figure><ul><li><strong>通过逗号分隔函数名</strong>，可根据需要从模块中<strong>导入任意数量的函数</strong></li><li>使用这种语法，<strong>调用函数时就无需使用句点</strong></li></ul><hr><h4 id="使用-as-给函数指定别名"><a href="#使用-as-给函数指定别名" class="headerlink" title="使用 as 给函数指定别名"></a>使用 as 给函数指定别名</h4><p>要给函数指定别名，需要<strong>在导入时</strong>这样做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name <span class="keyword">as</span> fn</span><br></pre></td></tr></table></figure><ul><li>上面的语句将函数<code>function_name()</code>重命名为<code>fn()</code></li></ul><hr><h4 id="使用-as-给模块指定别名"><a href="#使用-as-给模块指定别名" class="headerlink" title="使用 as 给模块指定别名"></a>使用 as 给模块指定别名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name <span class="keyword">as</span> mn</span><br></pre></td></tr></table></figure><hr><h4 id="导入模块中的所有函数"><a href="#导入模块中的所有函数" class="headerlink" title="导入模块中的所有函数"></a>导入模块中的所有函数</h4><p>使用<strong>星号<code>*</code></strong>运算符可让Python导入模块中的<strong>所有函数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">16</span> <span class="string">'pepperoni'</span>)</span><br></pre></td></tr></table></figure><p><strong>import语句中的星号</strong>让Python将模块pizza中的<strong>每个函数</strong>都复制到这个文件中。由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。然而，使用<strong>并非自己编写的大型模块</strong>时，<strong>最好不要采用这种导入方法</strong>：Python可能遇到多个名称相同的函数或变量，进而<strong>覆盖函数</strong>，而不是分别导入所有的函数。</p><p>最佳的做法是，要么<strong>只导入需要使用的函数</strong>，要么<strong>导入整个模块并使用句点表示法</strong>，这能让代码更清晰，更容易阅读和理解。</p><hr><h3 id="函数编写指南"><a href="#函数编写指南" class="headerlink" title="函数编写指南"></a>函数编写指南</h3><ol><li><p>给函数指定<strong>描述性名称</strong>，且<strong>只使用小写字母</strong>和<strong>下划线</strong>。</p></li><li><p>每个函数都应包含简要地阐述其功能的注释，该<strong>注释应紧跟在函数定义后面</strong>，并采用<strong>文档字符串格式</strong>。</p></li><li><p><strong>给形参指定认值</strong>时，<strong>等号两边不要有空格</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">(parameter_0, parameter_1=<span class="string">'default value'</span>)</span></span></span><br></pre></td></tr></table></figure></li><li><p>对于<strong>函数调用中的关键字实参</strong>，<strong>等号两边不要有空格</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name(value_0, parameter_1=<span class="string">'value'</span>)</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>形参很多</strong>，导致函数定义的长度超过了79字符，可在函数定义中<strong>输入左括号后按回车键</strong>，并在下一行<strong>按两次</strong>Tab键，从而<strong>将形参列表和只缩进一层的函数体区分开来</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">parameter_0, parameter_1, parameter_2,</span></span></span><br><span class="line"><span class="function"><span class="params">parameter_3, parameter_4, parameter_5)</span>:</span></span><br><span class="line">    function body...</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>程序或模块包含多个函数</strong>，可使用<strong>两个空行</strong>将相邻的函数分开，这样更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。</p></li></ol><hr><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul><li><p><code>range()</code> 还可指定步长</p></li><li><p><code>map()</code></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line">list(map(func, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"><span class="comment"># 效果等价于 [i**2 for i in range(1, 6)]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list(map(str, map(func, a)))</span><br><span class="line"><span class="comment"># 结果为 ['1', '4', '9', '16', '25']</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>使用<code>lambda</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x:x*x</span><br></pre></td></tr></table></figure><p><strong>输入</strong>为x，<strong>输出</strong>为<code>x*x</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 避免显式构造函数func，简约</span></span><br><span class="line">list(map(<span class="keyword">lambda</span> x:x*x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line">list(map(<span class="keyword">lambda</span> x:<span class="string">'char is:'</span>+str(x), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"><span class="comment"># 结果为 ['char is:1', 'char is:2', 'char is:3' ...]</span></span><br></pre></td></tr></table></figure><hr><h2 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h2><ul><li>collections</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">31</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">print(collections.Counter(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：Counter(&#123;1: 3, 2: 3, 3: 1, 31: 1&#125;)</span></span><br></pre></td></tr></table></figure><ul><li>csv</li><li>datetime</li><li>math</li><li>pandas</li><li>numpy</li></ul><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="创建和使用类"><a href="#创建和使用类" class="headerlink" title="创建和使用类"></a>创建和使用类</h3><h4 id="创建-Dog-类"><a href="#创建-Dog-类" class="headerlink" title="创建 Dog 类"></a>创建 Dog 类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟小狗的简单尝试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        <span class="string">"""初始化属性name和age"""</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""模拟小狗被命令蹲下"""</span></span><br><span class="line">        print(self.name.title() + <span class="string">" is now sitting."</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""模拟小狗被命令时打滚"""</span></span><br><span class="line">        print(self.name.title() + <span class="string">" rolled over!"</span>)</span><br></pre></td></tr></table></figure><ul><li>根据约定，Python中<strong>首字母大写</strong>的名称指的是<strong>类</strong>。这个<strong>类定义中的括号是空的</strong>，因为我们<strong>要从空白创建这个类</strong>。</li></ul><ol><li><p>方法<code>__init__()</code></p><ul><li><p><strong>类中的函数</strong>称为<strong>方法</strong>。就目前而言，函数和方法唯一重要的差别是<strong>调用方法的方式</strong>。</p></li><li><p>上例中的方法<code>__init__()</code>是一个<strong>特殊</strong>的方法，<strong>每当根据Dog类创建新实例时，Python都会自动运行它</strong>。</p></li><li><p>在这个方法名称中，开头和末尾各有<strong>两个下划线</strong>，<strong>这是一种约定</strong>，旨在<strong>避免Python默认方法与普通方法发生名称冲突</strong>。</p></li><li><p>这个方法的定义中，形参<code>self</code><strong>必不可少</strong>，还<strong>必须位于其他形参的前面</strong>。</p><p>为何必须在方法定义中包含形参<code>self</code>呢？因为Python调用这个<code>__init__()</code>方法将<strong>自动传入实参<code>self</code></strong>。<strong>每个与类相关联的方法调用都自动传递实参<code>self</code></strong>，它是一个<strong>指向实例本身的引用</strong>，<strong>让实例能够访问类中的属性和方法</strong>。</p><p>我们创建Dog实例时，Python将调用Dog类的方法<code>__init__()</code>。我们将<strong>通过实参向<code>Dog()</code>传递name和age，self会自动传递</strong>。</p></li><li><p>以<code>self</code><strong>为前缀</strong>的变量都<strong>可供类中的所有方法使用</strong>，我们<strong>还可以通过类的任何实例来访问这些变量</strong>。</p><p><code>self.name = name</code>获取存储在形参name中的值，并将其存储到变量name中，然后<strong>该变量被关联到当前创建的实例</strong>。</p><p>像这样<strong>可以通过实例访问的变量</strong>称为<strong>属性</strong>。</p></li><li><p><code>sit()</code>和<code>roll_over()</code>方法<strong>不需要额外的信息，因此它们只有一个形参self</strong>。</p></li></ul></li><li><p>在 Python 2.7 中创建类</p><p>在 Python 2.7 中创建类时，需要做细微的修改——在括号内包含单词object：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span><span class="params">(object)</span>:</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="根据类创建实例"><a href="#根据类创建实例" class="headerlink" title="根据类创建实例"></a>根据类创建实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">'willie'</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>遇到上述代码时，Python使用实参<code>willie</code>和6调用Dog类中的方法<code>__init__()</code>。方法<code>__init__()</code><strong>并未显式地包含return语句，但Python自动返回一个表示这条小狗的实例</strong>。在这里，<strong>命名约定很有用</strong>：我们通常可以认为<strong>首字母大写的名称</strong>指的是<strong>类</strong>，<strong>小写的名称</strong>指的是<strong>根据类创建的实例</strong>。</p><ol><li><p>访问属性</p><p><code>my_dog.name</code>，在Dog类中引用这个属性使用的是<code>self.name</code></p></li><li><p>调用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dog.sit()</span><br><span class="line">my_dog.roll_over()</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="使用类和实例"><a href="#使用类和实例" class="headerlink" title="使用类和实例"></a>使用类和实例</h3><h4 id="Car-类"><a href="#Car-类" class="headerlink" title="Car 类"></a>Car 类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回整洁的描述性信息"""</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    </span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br></pre></td></tr></table></figure><hr><h4 id="给属性指定默认值"><a href="#给属性指定默认值" class="headerlink" title="给属性指定默认值"></a>给属性指定默认值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        --snip--</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条指出汽车里程的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">    </span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><hr><h4 id="修改属性的值"><a href="#修改属性的值" class="headerlink" title="修改属性的值"></a>修改属性的值</h4><ol><li><p><strong>直接修改</strong>属性的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br></pre></td></tr></table></figure></li><li><p><strong>通过方法修改</strong>属性的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    --snip--</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="string">"""将里程表读数设置为指定的值"""</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line">    </span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.update_odometer(<span class="number">23</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>可对方法<code>update_odometer()</code>进行扩展，<strong>禁止任何人将里程表读数往回调</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    --snip--</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将里程表读数设置为指定的值</span></span><br><span class="line"><span class="string">        禁止将里程表读数往回调</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"You can't roll back an odometer!"</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>通过方法</strong>对属性的值进行<strong>递增</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    --snip--</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        --snip--</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line">        <span class="string">"""将里程表读数增加指定的量"""</span></span><br><span class="line">        self.odometer_reading+= miles</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一个类<strong>继承</strong>另一个类时，它将自动获得另一个类的<strong>所有属性和方法</strong>。原有的类称为<strong>父类</strong>，新类称为<strong>子类</strong>。子类同时还可以<strong>定义自己的属性和方法</strong>。</p><h4 id="子类的方法-init"><a href="#子类的方法-init" class="headerlink" title="子类的方法__init__()"></a>子类的方法<code>__init__()</code></h4><p>创建子类的实例时，Python<strong>首先需要给父类的所有属性赋值</strong>，为此，子类的方法<code>__init__()</code><strong>需要父类施以援手</strong>。</p><p>下面来创建一个简单的ElectricCar类版本，它<strong>具备Car类的所有功能</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="string">"""电动汽车的独特之处"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化父类的属性"""</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        </span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><ul><li>创建子类时，<strong>父类必须包含在当前文件中，且位于子类前面</strong>。</li><li>定义子类时，<strong>必须在括号内指定父类的名称</strong>。</li><li><code>super()</code>是一个特殊函数，帮助Python<strong>将父类和子类关联起来</strong>。<strong>父类</strong>也称为<strong>超类</strong>(<strong>superclass</strong>)，名称super因此而得名。</li></ul><hr><h4 id="Python-2-7-中的继承"><a href="#Python-2-7-中的继承" class="headerlink" title="Python 2.7 中的继承"></a>Python 2.7 中的继承</h4><p>在Python 2.7 中，继承语法稍有不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Python 2.7 中创建类时，需要在括号内包含单词object</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        --snip--</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        super(ElectricCar, self).__init__(make, model, year)</span><br></pre></td></tr></table></figure><ul><li>函数<code>super()</code>需要两个实参：子类名和对象self。</li></ul><hr><h4 id="给子类定义属性和方法"><a href="#给子类定义属性和方法" class="headerlink" title="给子类定义属性和方法"></a>给子类定义属性和方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="string">"""电动汽车的独特之处"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        电动汽车的独特之处</span></span><br><span class="line"><span class="string">        初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery_size = <span class="number">70</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条描述电瓶容量的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kwh battery."</span>)</span><br><span class="line">        </span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, <span class="number">2016</span>)</span><br><span class="line">my_tesla.describe_battery()</span><br></pre></td></tr></table></figure><hr><h4 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h4><p>对于父类的方法，只要它<strong>不符合子类模拟的实物的行为</strong>，<strong>都可对其进行重写</strong>。为此，可在子类中<strong>定义一个与要重写的父类方法同名的方法</strong>。</p><p>假设Car类有一个名为<code>fill_gas_tank()</code>的方法，它对全电动汽车来说毫无意义。下面演示一种重写方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    --snip--</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_gas_tank</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""电动汽车没有油箱"""</span></span><br><span class="line">        print(<span class="string">"This car doesn't need a gas tank!"</span>)</span><br></pre></td></tr></table></figure><p>使用继承时，可让子类保留从父类继承而来的精华，并剔除不需要的糟粕。</p><hr><h4 id="将实例用作属性"><a href="#将实例用作属性" class="headerlink" title="将实例用作属性"></a>将实例用作属性</h4><p>使用代码模拟实物时，可能会发现给类添加的细节越来越多：<strong>属性</strong>和<strong>方法清单</strong>以及<strong>文件</strong>都<strong>越来越长</strong>。这种情况下，可能需要将类的一部分作为一个独立的类提取出来，将大型类拆分称多个协同工作的小类。</p><p>例如，不断给ElectricCar类添加细节时，我们可能会发现其中包含很多<strong>专门针对汽车电瓶的属性和方法</strong>。可以将这些属性和方法提取出来，放到另一个名为Battery的类中，并<strong>将一个Battery实例用作ElectricCar类的一个属性</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    --snip--</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟电动汽车电瓶的简单尝试"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, battery_size=<span class="number">70</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化电瓶的属性"""</span></span><br><span class="line">        self.battery_size = battery_size</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条描述电瓶容量的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kwh battery."</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="string">"""电动汽车的独特之处"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery = Battery()</span><br><span class="line">        </span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, <span class="number">2016</span>)</span><br><span class="line">my_tesla.battery.describe_battery()</span><br></pre></td></tr></table></figure><p>这看似做了很多额外的工作，但现在我们想多详细地描述电瓶都可以，且<strong>不会导致ElectricCar类混乱不堪</strong>。</p><hr><h3 id="导入类"><a href="#导入类" class="headerlink" title="导入类"></a>导入类</h3><p>Python允许<strong>将类存储在模块中</strong>，然后在主程序中<strong>导入所需的模块</strong>(模块是<strong>扩展名为<code>.py</code>的文件</strong>，<strong>包含要导入到程序中的代码</strong>)。</p><h4 id="导入单个类"><a href="#导入单个类" class="headerlink" title="导入单个类"></a>导入单个类</h4><p>下面是<strong>模块car.py</strong>，其中只包含Car类的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""一个可用于表示汽车的类"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模仿汽车的简单尝试"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回整洁的描述性名称"""</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条消息，指出汽车的里程"""</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self. mileage)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将里程表读数设置为指定的值</span></span><br><span class="line"><span class="string">        拒绝将历程表往回拨</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line">        <span class="string">"""将里程表读数增加指定的量"""</span></span><br><span class="line">        self.odometer_reading += miles</span><br></pre></td></tr></table></figure><p>下面创建另一个文件——<strong>my_car.py</strong>，在其中<strong>导入Car类并创建其实例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.reading_odometer()</span><br></pre></td></tr></table></figure><p>导入类是一种有效的编程方式，<strong>让大部分逻辑存储在独立的文件中</strong>，<strong>使主程序文件变得整洁而易于阅读</strong>。</p><hr><h4 id="在一个模块中存储多个类"><a href="#在一个模块中存储多个类" class="headerlink" title="在一个模块中存储多个类"></a>在一个模块中存储多个类</h4><p>虽然同一个模块中的类之间应存在某种相关性，但可根据需要在一个模块中存储任意数量的类。</p><p>类Battery和ElectricCar都可以帮助模拟汽车，因此可以将其加入模块car.py中。</p><hr><h4 id="从一个模块中导入多个类"><a href="#从一个模块中导入多个类" class="headerlink" title="从一个模块中导入多个类"></a>从一个模块中导入多个类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car, ElectricCar</span><br></pre></td></tr></table></figure><ul><li>从一个模块中导入多个类时，<strong>用逗号分隔各个类</strong>。</li></ul><hr><h4 id="导入整个模块-1"><a href="#导入整个模块-1" class="headerlink" title="导入整个模块"></a>导入整个模块</h4><p>可以导入整个模块，再<strong>使用句点表示法访问需要的类</strong>。这中导入方法很简单，代码也易于阅读。<strong>由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> car</span><br><span class="line"></span><br><span class="line">my_beetle = car.Car(<span class="string">'volkswagen'</span>, <span class="string">'beetle'</span>, <span class="number">2016</span>)</span><br><span class="line"></span><br><span class="line">my_tesla = car.ElectricCar(<span class="string">'tesla'</span>, <span class="string">'roadster'</span>, <span class="number">2016</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="导入模块中的所有类"><a href="#导入模块中的所有类" class="headerlink" title="导入模块中的所有类"></a>导入模块中的所有类</h4><p>要导入模块中的每个类，可使用下面的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>但是<strong>不推荐这种导入方式</strong>(同<strong>导入模块中的所有元素</strong>)，原因有二：</p><ol><li>这种导入方式<strong>没有明确地指出你使用了模块中的哪些类</strong>。</li><li>还可能引发名称方面的困惑。<strong>如果不小心导入了一个与程序文件中其他东西同名的类</strong>，将<strong>引发难以诊断的错误</strong>。</li></ol><p>需要从一个模块中导入很多类时，最好<strong>导入整个模块</strong>，并<strong>用<code>module_name.class_name</code>语法来访问类</strong>。</p><hr><h4 id="在一个模块中导入另一个模块"><a href="#在一个模块中导入另一个模块" class="headerlink" title="在一个模块中导入另一个模块"></a>在一个模块中导入另一个模块</h4><p>有时候，需要将类分散到多个模块中，<strong>以免模块太大，或在同一个模块中存储不相关的类</strong>。将类存储在多个模块中时，你<strong>可能会发现一个模块中的类依赖于另一个模块中的类</strong>。这种情况下，可在前一个模块中导入必要的类。</p><p>例如，下面将Car类存储在一个模块中，并将ElectricCar和Battery类存储再另一个模块中。我们将第二个模块命名为electric_car.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""一组可用于表示电动汽车的类"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span><span class="params">()</span>:</span></span><br><span class="line">    --snip--</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    --snip--</span><br></pre></td></tr></table></figure><p>现在可以分别从每个模块中导入类，以根据需要创建任何类型的汽车了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"><span class="keyword">from</span> electric_car <span class="keyword">import</span> ElectricCar</span><br><span class="line"></span><br><span class="line">my_beetle = Car(<span class="string">'volkswagen'</span>, <span class="string">'beetle'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_beetle.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'roadster'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><hr><h3 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h3><p>Python标准库是<strong>一组模块</strong>，安装好的Python都包含它。<strong>可使用标准库中的任何函数和类</strong>，为此只需在程序开头包含一条简单的<strong>import语句</strong>。</p><p>下面来看<strong>模块collection</strong>中的一个类——<strong>OrderedDict</strong>。要创建字典并记录其中的键-值对的<strong>添加顺序</strong>，即可使用模块collections中的OrderedDict类。再来看一看第6章的favorite_languages.py示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">favorite_languages = OrderedDict()</span><br><span class="line"></span><br><span class="line">favorite_languages[<span class="string">'jen'</span>] = <span class="string">'python'</span></span><br><span class="line">favorite_languages[<span class="string">'sarah'</span>] = <span class="string">'c'</span></span><br><span class="line">favorite_languages[<span class="string">'edward'</span>] = <span class="string">'ruby'</span></span><br><span class="line">favorite_languages[<span class="string">'phil'</span>] = <span class="string">'python'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, language <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    print(name.title() + <span class="string">"'s favorite language is "</span> +</span><br><span class="line">         language.title() + <span class="string">"."</span>)</span><br></pre></td></tr></table></figure><p>这是一个很不错的类，它<strong>兼具列表和字典的主要优点</strong>(在<strong>将信息关联起来的同时保留原来的顺序</strong>)。</p><h4 id="模块random"><a href="#模块random" class="headerlink" title="模块random"></a>模块random</h4><p>模块random包含<strong>以各种方式生成随机数的函数</strong>，其中的<code>randint()</code>返回一个<strong>位于指定范围内的整数</strong>。</p><p>例如，下面的代码返回一个1~6内的整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">x = randint(<span class="number">1</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="类编码风格"><a href="#类编码风格" class="headerlink" title="类编码风格"></a>类编码风格</h3><ul><li><strong>类名</strong>：应采用<strong>驼峰命名法</strong>。</li><li><strong>实例名</strong>和<strong>模块名</strong>：应采用<strong>小写格式</strong>，并在单词之间加上下划线。</li><li>在<strong>类</strong>中，可使用<strong>一个空行</strong>来<strong>分隔方法</strong>；在<strong>模块</strong>中，可使用<strong>两个空行</strong>来<strong>分隔类</strong>。</li><li>需要同时导入标准库中的模块和自己编写的模块时，先编写导入标准库模块的import语句，再<strong>添加一个空行</strong>，然后编写导入自己编写的模块的import语句。这种做法<strong>让人更容易明白程序使用的各个模块来自何方</strong>。</li></ul><hr><h2 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h2><h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><p>文本文件可存储的数据量多的难以置信，每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其如此。例如可以编写一个这样的程序：<strong>读取一个文本文件的内容，重新设置这些数据的格式并将其写入文件，让浏览器能够显示这些内容</strong>。</p><p>要使用文本文件中的信息，<strong>首先需要将信息读取到内存中</strong>。为此，可以<strong>一次性读取文件的全部内容</strong>，也可以<strong>每次一行逐步读取</strong>。</p><h4 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h4><p>首先创建一个文件，它包含精确到小数点后30位的圆周率值，且在小数点后<strong>每10位处都换行</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.1415926535</span><br><span class="line">  8979323846</span><br><span class="line">  2643383279</span><br></pre></td></tr></table></figure><p>将上述文件保存为<code>pi_digits.txt</code>，<strong>保存到本章程序所在的目录中</strong>。</p><p>下面的程序<strong>打开并读取这个文件</strong>，再<strong>将其内容显示到屏幕上</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'pi_digits.txt'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    contents = file_object.read()</span><br><span class="line">    print(contents)</span><br></pre></td></tr></table></figure><p>再这个程序中，<strong>第一行代码做了大量的工作</strong>：</p><ul><li><p>函数<code>open()</code></p><ul><li>接受一个参数——<strong>要打开的文件的名称</strong>。</li><li>Python<strong>在当前执行的文件所在的目录中查找指定的文件</strong>。</li><li>返回一个<strong>表示文件的对象</strong>，Python将这个对象存储在我们将在后面使用的变量中。</li></ul></li><li><p><strong>关键字with</strong>在<strong>不需要访问文件后将其关闭</strong></p><ul><li><p>也可以调用<code>open()</code>和<code>close()</code>来打开和关闭文件，但这样做时，<strong>如果程序存在bug导致<code>close()</code>语句未执行，文件将不会关闭</strong>。</p><p>如果在程序中<strong>过早调用</strong><code>close()</code>，你会发现<strong>需要使用文件时它已关闭(无法访问)，这会导致更多的错误</strong>。</p></li><li><p>并非在任何情况下都能轻松确定关闭文件的恰当时机，但<strong>通过关键字with，可以让Python确定合适的时机自动关闭文件</strong>。</p></li></ul></li><li><p>有了表示文件的对象后，<strong>使用方法<code>read()</code>读取这个文件的全部内容</strong>，<strong>作为一个字符串</strong>。</p><ul><li><code>read()</code><strong>到达文件末尾</strong>时返回一个<strong>空字符串</strong>，这个空字符串<strong>显示出来就是一个空行</strong>。</li><li>要<strong>删除末尾的空行</strong>，可在print语句中使用<code>rstrip()</code>：<code>print(contents.rstrip())</code></li></ul></li></ul><hr><h4 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h4><p>Python<strong>默认在当前执行的文件所在的目录中查找指定的文件</strong>，但有时可能要打开不在程序文件所属目录中的文件。要让Python<strong>打开不与程序文件位于同一个目录中的文件</strong>，需要提供<strong>文件路径</strong>。</p><ul><li><p><strong>相对</strong>文件路径：</p><p>相对于<strong>当前运行的程序所在目录</strong>的路径。</p><ul><li><p>在 Linux 和 OS X 中，可以这样编写代码：</p><p><code>with open(&#39;text_files/filename.txt&#39;) as file_object:</code></p><p>这行代码让Python到<strong>当前文件夹下的</strong><code>text_files</code>文件夹中寻找指定的.txt文件。</p></li><li><p>在 Windows 系统中，在文件路径中使用<strong>反斜杠</strong>(<code>\</code>)：</p><p><code>with open(&#39;text_files\filename.txt&#39;) as file_object:</code></p></li></ul></li><li><p><strong>绝对</strong>文件路径：</p><p>将文件<strong>在计算机中的准确位置</strong>告诉Python。</p><p>绝对路径通常比相对路径<strong>更长</strong>，因此将其<strong>存储在一个变量中</strong>，再将该变量传递给<code>open()</code>会有所帮助。</p><ul><li><p>在 Linux 和 OS X 中，可以这样编写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">'/home/ehmatthes/other_files/text_files/filename.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure></li><li><p>在 Windows 系统中，它们类似于下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">'C:\Ysers\ehmatthes\other_files\text_files\filename.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>Windows系统<strong>有时能够正确解读</strong>文件路径中的<strong>斜杠</strong>。如果使用Windows系统，且结果不符合预期，请<strong>确保</strong>在文件路径中使用的是<strong>反斜杠</strong>。</li><li><strong>反斜杠</strong>在Python中被视为<strong>转义标记</strong>，为<strong>在Windows中确保万无一失</strong>，应<strong>以原始字符串的方式指定路径</strong>，即<strong>在开头的单引号前加上<code>r</code></strong>(以r开头，那么说明<strong>后面的字符，都是普通的字符</strong>了，即如果是<code>\n</code>，<strong>将表示一个反斜杠字符，一个字母n，而不是表示换行了</strong>)。</li></ul></li></ul><hr><h4 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h4><p>读取文件时，常常需要<strong>检查其中的每一行</strong>：你可能要在文件中<strong>查找特定的信息</strong>，或者<strong>要以某种方式修改文件中的文本</strong>。例如，你可能要遍历一个包含天气数据的文件，并使用天气描述中包含字样sunny的行；在新闻报道中，你可能会查找包含标签<code>&lt;headline&gt;</code>的行，并按特定的格式设置它。</p><p>要以<strong>每次一行的方式</strong>检查文件，可对文件对象使用<strong>for循环</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>我们<strong>打印每一行</strong>时，发现<strong>空白行</strong>更多了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3.1415926535</span><br><span class="line"></span><br><span class="line">  8979323846</span><br><span class="line">  </span><br><span class="line">  2643383279</span><br></pre></td></tr></table></figure><p>为什么会出现这些空白行呢？因为<strong>在这个文件中</strong>，<strong>每行的末尾都有一个看不见的换行符</strong>，而<strong>print语句也会加上一个换行符</strong>。要<strong>消除这些多余的空白行，可在print语句中使用<code>rstrip()</code></strong>：<code>print(line.rstrip())</code></p><hr><h4 id="创建一个包含文件各行内容的列表"><a href="#创建一个包含文件各行内容的列表" class="headerlink" title="创建一个包含文件各行内容的列表"></a>创建一个包含文件各行内容的列表</h4><p>使用<strong>关键字with</strong>时，<code>open()</code><strong>返回的文件对象只在with代码块内可用</strong>。如果要在<strong>with代码块外</strong>访问文件的内容，可<strong>在with代码块内</strong>将文件的各行<strong>存储在一个列表中</strong>，并在with代码块外使用该列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    print(line.rstrip())</span><br></pre></td></tr></table></figure><ul><li>方法<code>readlines()</code>从文件中<strong>读取每一行，并将其存储在一个列表中</strong>。</li></ul><hr><h4 id="使用文件的内容"><a href="#使用文件的内容" class="headerlink" title="使用文件的内容"></a>使用文件的内容</h4><p>首先创建一个字符串，它<strong>包含文件中存储的所有数字</strong>，且<strong>没有任何空格</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">    </span><br><span class="line">pi_string = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.rstrip()</span><br><span class="line">    </span><br><span class="line">print(pi_string)</span><br><span class="line">print(len(pi_string))</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926535</span>  <span class="number">8979323846</span>  <span class="number">2643383279</span></span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure><p>在变量pi_string存储的字符串中，<strong>包含原来位于左边的空格</strong>，为删除这些空格，<strong>可使用<code>strip()</code></strong>而不是<code>rstrip()</code></p><p>注意：</p><p>读取<strong>文本文件</strong>时，Python将其中的文本都<strong>解读为字符串</strong>。如果<strong>读取的是数字，并要将其作为数值使用</strong>，就必须使用函数<code>int()</code>或<code>float()</code>转换为数字。</p><hr><h4 id="包含小数点后一百万位的大型文件"><a href="#包含小数点后一百万位的大型文件" class="headerlink" title="包含小数点后一百万位的大型文件"></a>包含小数点后一百万位的大型文件</h4><p>只要系统内存足够多，想处理多少数据都可以。</p><hr><h4 id="圆周率值中包含你的生日吗"><a href="#圆周率值中包含你的生日吗" class="headerlink" title="圆周率值中包含你的生日吗"></a>圆周率值中包含你的生日吗</h4><p>为确认某个人的生日是否包含在圆周率值得前1 000 000位中，可将生日表示为一个由数字组成得字符串，再检查这个字符串是否包含在pi_string中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">    </span><br><span class="line">pi_string = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.strip()</span><br><span class="line">    </span><br><span class="line">birthday = input(<span class="string">"Enter your birthday, in thje form mmddyy: "</span>)</span><br><span class="line"><span class="keyword">if</span> birthday <span class="keyword">in</span> pi_string:</span><br><span class="line">    print(<span class="string">"Your birthday appears in the first million digits of pi!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Your birthday does not appear in the first million digits of pi."</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p><strong>保存数据</strong>最简单的方式之一是将其<strong>写入到文件中</strong>。</p><h4 id="写入空文件"><a href="#写入空文件" class="headerlink" title="写入空文件"></a>写入空文件</h4><p>要将文本写入文件，在调用<code>open()</code>时需要<strong>提供另一个实参</strong>，告诉Python<strong>要写入打开的文件</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'programming.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">"I love programming."</span>)</span><br></pre></td></tr></table></figure><ul><li><p>实参<code>&#39;w&#39;</code>告诉Python，我们要以<strong>写入模式</strong>打开这个文件。</p></li><li><p>打开文件时，可指定<strong>模式</strong></p><ul><li><strong>读取</strong>模式（<strong>‘r’</strong>）</li><li><strong>写入</strong>模式（<strong>‘w’</strong>）</li><li><strong>附加</strong>模式（<strong>‘a’</strong>)</li><li><strong>读写</strong>模式（<strong>‘r+’</strong>）</li></ul><p>如果<strong>省略了模式实参</strong>，默认以<strong>只读模式</strong>打开文件。</p></li><li><p>如果<strong>要写入的文件不存在</strong>，函数<code>open()</code>将<strong>自动创建它</strong>。然而，<strong>以写入(‘w’)模式打开文件时千万要小心</strong>，因为<strong>如果指定的文件已经存在，Python将在返回文件对象前清空该文件</strong>。</p></li><li><p>文件对象的方法<code>write()</code><strong>将一个字符串写入文件</strong>。</p></li><li><p>Python<strong>只能将字符串写入文本文件</strong>，要将数值数据存储到文本文件中，必须先使用函数<code>str()</code>将其转换为字符串格式。</p></li></ul><hr><h4 id="写入多行"><a href="#写入多行" class="headerlink" title="写入多行"></a>写入多行</h4><p>函数<code>write()</code><strong>不会在写入的文本末尾添加换行符</strong>，要让每个字符串都单独占一行，需要在<code>write()</code>语句中包含换行符。</p><hr><h4 id="附加到文件"><a href="#附加到文件" class="headerlink" title="附加到文件"></a>附加到文件</h4><p>如果要<strong>给文件添加内容，而不是覆盖原有内容</strong>，可以<strong>附加模式(‘a’)</strong>打开文件。如果指定的文件不存在，Python会创建一个空文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'programming.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'a'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">"I also love finding meaning in large datasets.\n"</span>)</span><br><span class="line">    file_object.write(<span class="string">"I love creating apps that can run in a browser.\n"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Python使用<strong>被称为异常的特殊对象</strong>来<strong>管理程序执行期间发生的错误</strong>。每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果编写了处理该异常的代码，程序将继续运行；<strong>如果未对异常进行处理，程序将停止，并显示一个<code>traceback</code>，其中包含有关异常的报告</strong>。</p><p>异常是使用<code>try-except</code>代码块处理的。<code>try-except</code>代码块让Python<strong>执行指定的操作</strong>，<strong>同时告诉Python发生异常时怎么办</strong>。使用了<code>try-except</code>代码块时，<strong>即便出现异常，程序也将继续运行</strong>：显示编写的友好的错误消息，而不是令用户迷惑的<code>traceback</code>。</p><ul><li><p>ZeroDivisionError 异常</p><p><code>ZeroDivisionError</code>就是一个<strong>异常对象</strong></p></li><li><p>ValueError 异常</p><p>尝试<strong>将非数字文本转换为数字</strong>时，将引发<code>ValueError</code></p></li><li><p>FileNotFoundError 异常</p></li><li></li></ul><hr><h4 id="使用-try-except-代码块"><a href="#使用-try-except-代码块" class="headerlink" title="使用 try-except 代码块"></a>使用 try-except 代码块</h4><p>当你认为可能发生了错误时，可编写一个<code>try-except</code>代码块来处理可能引发的异常。</p><p>处理<code>ZeroDivisionError</code>异常的<code>try-except</code>代码块类似于下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"You can't divide by zero!"</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="使用异常避免崩溃"><a href="#使用异常避免崩溃" class="headerlink" title="使用异常避免崩溃"></a>使用异常避免崩溃</h4><p>发生错误时，<strong>如果程序还有工作没有完成</strong>，<strong>妥善地处理错误</strong>就尤其重要。这种情况经常会出现在要求用户提供输入的程序中；如果程序能够妥善地处理无效输入就能再提示用户提供有效输入，而<strong>不至于崩溃</strong>。</p><hr><h4 id="else-代码块"><a href="#else-代码块" class="headerlink" title="else 代码块"></a>else 代码块</h4><p><strong>将可能引发错误地代码放在<code>try-except</code>代码块中</strong>，可提高这个程序抵御错误的能力。<strong>依赖于try代码块成功执行的代码</strong>都应放到<strong>else代码块</strong>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    answer = int(first_number) / int(second_number)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"You can't divide by 0!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(answer)</span><br></pre></td></tr></table></figure><hr><h4 id="处理-FileNotFoundError-异常"><a href="#处理-FileNotFoundError-异常" class="headerlink" title="处理 FileNotFoundError 异常"></a>处理 FileNotFoundError 异常</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'alice.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    msg = <span class="string">"Sorry, the file "</span> + filename + <span class="string">" does not exist."</span></span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure><p>如果文件不存在，这个程序什么都不做，因此错误处理代码的意义不大。</p><hr><h4 id="分析文本"><a href="#分析文本" class="headerlink" title="分析文本"></a>分析文本</h4><p>下面来提取童话<em>Alice in Wonderland</em>的文本，并尝试<strong>计算它包含多少个单词</strong>。</p><p>我们将使用方法<code>split()</code>，它<strong>根据一个字符串创建一个单词列表</strong>。方法<code>split()</code><strong>以空格为分隔符</strong>将字符串分拆成多个部分，<strong>并将这些部分都存储在一个列表中</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'alice.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    msg = <span class="string">"Sorry, the file "</span> + filename + <span class="string">" does not exist."</span></span><br><span class="line">    print(msg)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 计算文件大致包含多少个单词</span></span><br><span class="line">    words = contents.split()</span><br><span class="line">    num_words = len(words)</span><br><span class="line">    print(<span class="string">"The file "</span> + filename + <span class="string">" has about "</span> + str(num_words) + <span class="string">" words."</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="使用多个文件"><a href="#使用多个文件" class="headerlink" title="使用多个文件"></a>使用多个文件</h4><p>下面多分析几本书。我们先将这个程序的大部分代码移到一个名为<code>count_words()</code>的函数中，这样对多本书进行分析时将更容易：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""计算一个文件大致包含多少个单词"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        msg = <span class="string">"Sorry, the file "</span> + filename + <span class="string">" does not exist."</span></span><br><span class="line">        print(msg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 计算文件大致包含多少个单词</span></span><br><span class="line">        words = contents.split()</span><br><span class="line">        num_words = len(words)</span><br><span class="line">        print(<span class="string">"The file "</span> + filename + <span class="string">" has about "</span> + str(num_words) + <span class="string">" words."</span>)</span><br><span class="line">filename = <span class="string">'alice.txt'</span></span><br><span class="line">count_words(filename)</span><br></pre></td></tr></table></figure><hr><h4 id="失败时一声不吭"><a href="#失败时一声不吭" class="headerlink" title="失败时一声不吭"></a>失败时一声不吭</h4><p><strong>要让程序在失败时一声不吭，可通过pass语句，在except代码块中明确表明什么都不做</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""计算一个文件大致包含多少个单词"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        --snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        --snip--</span><br></pre></td></tr></table></figure><p><strong>pass语句</strong>还充当了<strong>占位符</strong>。它提醒你<strong>在程序的某个地方什么都没有做，并且以后也许要在这里做些什么</strong>。在这个程序中，我们可能决定将找不到的文件的名称写入到文件<code>missing_files.txt</code>中。</p><hr><h3 id="使用-模块json-存储数据"><a href="#使用-模块json-存储数据" class="headerlink" title="使用 模块json 存储数据"></a>使用 模块json 存储数据</h3><p>很多程序要求用户输入某种信息，如让用户<strong>存储游戏首选项</strong>或<strong>提供可视化的数据</strong>。不管专注的是什么，<strong>程序都把用户提供的信息存储在列表和字典等数据结构中</strong>。用户关闭程序时，几乎总是要保存他们提供的信息，一种简单的方式是<strong>使用模块json来存储数据</strong>。</p><ul><li>模块json能<strong>将简单的Python数据结构转储到文件中</strong>，<strong>并在程序再次运行时加载该文件中的数据</strong>。</li><li>还可以使用json<strong>在Python程序之间分享数据</strong></li><li>JSON数据格式不是Python专用，因此能够将以JSON格式储的数据与使用其他编程语言的人分享</li><li>JSON是一种轻便格式，很有用，也易于学习</li><li><strong>JSON(JavaScript Object Notation)</strong>格式最初是为JavaScript开发的，但随后成了一种常见格式，被众多语言采用</li></ul><p>我们来编写程序，使用<code>json.dump()</code>来<strong>存储一组数字</strong>，使用<code>json.load()</code><strong>将这些数字读取到内存中</strong>。</p><h4 id="使用-json-dump"><a href="#使用-json-dump" class="headerlink" title="使用 json.dump()"></a>使用 json.dump()</h4><ul><li>函数<code>json.dump()</code>接受两个实参：<ol><li>要存储的<strong>数据</strong></li><li>可用于存储数据的<strong>文件对象</strong></li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'numbers.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    json.dump(numbers, f_obj)</span><br></pre></td></tr></table></figure><ul><li>先导入<strong>模块json</strong>，再<strong>创建一个数字列表</strong>。</li><li>通常<strong>使用文件扩展名<code>.json</code></strong>来<strong>指出文件存储的数据为JSON格式</strong>。</li><li>使用函数<code>json.dump()</code>将数字列表存储到文件numbers.json中</li></ul><hr><h4 id="使用-json-load"><a href="#使用-json-load" class="headerlink" title="使用 json.load()"></a>使用 json.load()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'numbers.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">    numbers = json.load(f_obj)</span><br><span class="line">    </span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure><hr><h4 id="保存和读取用户生成的数据"><a href="#保存和读取用户生成的数据" class="headerlink" title="保存和读取用户生成的数据"></a>保存和读取用户生成的数据</h4><p>来看这样一个例子：用户<strong>首次运行程序时被提示输入自己的名字</strong>，这样<strong>再次运行程序时就记住他了</strong>。</p><ul><li><p>先存储用户的名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">username = input(<span class="string">"What is your name? "</span>)</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'username.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    json.dump(username, f_obj)</span><br><span class="line">    print(<span class="string">"We'll remember you when you come back, "</span> + username + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure></li><li><p>再编写一个程序，向其名字被存储的用户发出问候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'username.json'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">    username = json.load(f_obj)</span><br><span class="line">    print(<span class="string">"Welcome back, "</span> + username + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>我们需要将这两个程序合并到一个程序中。这个程序运行时，我们将尝试<strong>从文件username.json中获取用户名</strong>。因此首先编写一个<strong>尝试恢复用户名的try代码块</strong>。如果这个文件不存在，我们就在except代码块中提示用户输入用户名，并将其存储在username.json中，以便程序再次运行时能够获取它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果以前存储了用户名，就加载它</span></span><br><span class="line"><span class="comment"># 否则，就提示用户输入用户名并存储它</span></span><br><span class="line">filename = <span class="string">'username.json'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj<span class="string">"</span></span><br><span class="line"><span class="string">    username = json.load(f_obj)</span></span><br><span class="line"><span class="string">except FileNotFoundError:</span></span><br><span class="line">    username = input("What is your name? ")</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">        json.dump(username, f_obj)</span><br><span class="line">        print(<span class="string">"We'll remember you when you come back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Welcome back, "</span> + username + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>你经常会遇到这样的情况：代码能够正确地运行，但可做进一步的<strong>改进</strong>——<strong>将代码划分为一系列完成具体工作的函数</strong>。这样的过程被称为<strong>重构</strong>。<strong>重构让代码更清晰、更易于理解、更容易扩展</strong>。</p><p>要重构上述程序，可将大部分逻辑放到一个或多个函数中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""问候用户，并指出其名字"""</span></span><br><span class="line">    filename = <span class="string">'username.json'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            username = json.load(f_obj)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        username = input(<span class="string">"What is your name? "</span>)</span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">            json.dump(username, f_obj)</span><br><span class="line">            print(<span class="string">"We'll remember you when you come back"</span> + username + <span class="string">"!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Welcome back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line">        </span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><p>下面来重构<code>greet_user()</code>，让它不执行这么多任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stored_username</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""如果存储了用户名，就获取它"""</span></span><br><span class="line">    filename = <span class="string">'username.json'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            username = json.load(f_obj)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_new_username</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""提示用户输入用户名"""</span></span><br><span class="line">    username = input(<span class="string">"What is your name? "</span>)</span><br><span class="line">    filename = <span class="string">'username.json'</span></span><br><span class="line">    <span class="keyword">with</span> open(filename. <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">        json.dump(username, f_obj)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""问候用户，并指出其名字"""</span></span><br><span class="line">    username = get_stored_username()</span><br><span class="line">    <span class="keyword">if</span> username:</span><br><span class="line">        print(<span class="string">"Welcom back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = get_new_username()</span><br><span class="line">        print(<span class="string">"We'll remember you when you come back"</span> + username + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><p>在这个版本中，<strong>每个函数都执行单一而清晰的任务</strong>。</p><hr><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><p>下面是一个简单的函数，它接受名和姓并返回整洁的姓名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first, last)</span>:</span></span><br><span class="line">    <span class="string">"""生成整洁的姓名"""</span></span><br><span class="line">    full_name = first + <span class="string">' '</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><p>为核实函数像期望的那样工作，来编写一个使用这个函数的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Enter 'q' at any time to quit."</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    first = input(<span class="string">"\nPlease give me a forst name: "</span>)</span><br><span class="line">    <span class="keyword">if</span> first == <span class="string">'q'</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    last = input(<span class="string">"Please give me a last time: "</span>)</span><br><span class="line">    <span class="keyword">if</span> last == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    formatted_name = get_formatted_name(first, last)</span><br><span class="line">    print(<span class="string">"\tNeatly formatted name: "</span> + formatted_name + <span class="string">'.'</span>)</span><br></pre></td></tr></table></figure><p>现在假设我们要修改<code>get_formatted_name()</code>，使其还能处理中间名。这样做时，我们要确保<strong>不破坏这个函数处理只有名和姓的姓名的方式</strong>。为此，我们可以在每次修改<code>get_formatted_name()</code>后都进行测试：运行程序<code>names.py</code>，并输入像Janis Joplin这样的姓名，但这太繁琐了。所幸Python提供了一种<strong>自动测试函数输出</strong>的高效方式。</p><h4 id="单元测试和测试用例"><a href="#单元测试和测试用例" class="headerlink" title="单元测试和测试用例"></a>单元测试和测试用例</h4><p><strong>Python标准库中的模块unittest</strong>提供了<strong>代码测试工具</strong>。</p><ul><li><strong>单元</strong>测试：用于<strong>核实函数的某个方面</strong>没有问题</li><li><strong>测试用例</strong>：是<strong>一组单元测试</strong>，这些单元测试一起核实函数在各种情形下的行为都符合要求。</li></ul><p>良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。<strong>全覆盖式测试</strong>用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖很难。通常，<strong>最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖</strong>。</p><hr><h4 id="可通过的测试"><a href="#可通过的测试" class="headerlink" title="可通过的测试"></a>可通过的测试</h4><p><strong>创建测试用例的语法需要一段时间才能习惯</strong>，但测试用例创建后，<strong>再添加针对函数的单元测试就很简单了</strong>。要为函数编写测试用例，可<strong>先导入模块unittest以及要测试的函数</strong>，再创建一个<strong>继承unittest.TestCase</strong>的类，并编写一系列方法对函数行为的不同方面进行测试。</p><p>下面是一个只包含一个方法的测试用例，它检查函数<code>get_formatted_name()</code>在给定名和姓时能否正确地工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""测试name_function.py"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Janis Joplin 这样的姓名吗？ """</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">'janis'</span>, <span class="string">'joplin'</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">'Janis Joplin'</span>)</span><br><span class="line">        </span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure><ul><li><p>代码行<code>unittest.main()</code>让Python<strong>运行这个文件中的测试</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">Ran 1 test in 0.000s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li>第一行的句点<code>.</code>表明<strong>有一个测试通过了</strong></li><li>最后的<strong>OK</strong>表明该测试用例中的<strong>所有单元测试都通过了</strong></li></ul></li><li><p><strong>测试类的命名</strong>最好让它看起来与要测试的函数相关，并<strong>包含字样Test</strong>。这个类<strong>必须继承unittest.TestCase类</strong>，<strong>这样Python才知道如何运行你编写的测试</strong>。</p></li><li><p>我们运行上述程序时，<strong>所有以<code>test_</code>打头的方法都会自动运行</strong>。</p></li><li><p>unittest最有用的功能之一：一个<strong>断言</strong>方法。</p><p><strong>断言方法用来核实得到的结果是否与期望的结果一致(应该满足的条件是否确实满足)</strong>。上述代码通过调用<code>unittest</code>的方法<code>assertEqual()</code>，并向它传递<code>formatted_name</code>和<code>&#39;Janis Joplin&#39;</code>。</p></li></ul><hr><h4 id="不能通过的测试"><a href="#不能通过的测试" class="headerlink" title="不能通过的测试"></a>不能通过的测试</h4><p>测试未通过时结果是什么样的呢？我们来修改<code>get_formatted_name()</code>，使其能够处理中间名，但这样做时，故意让这个函数无法正确地处理像<code>Janis Joplin</code>这样只有名和姓的姓名。</p><p>下面是函数<code>get_formatted_name()</code>的新版本，它要求<strong>通过一个实参指定中间名</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first, middle, last)</span>:</span></span><br><span class="line">    <span class="string">"""生成整洁的姓名"""</span></span><br><span class="line">    full_name = first + <span class="string">' '</span> + middle + <span class="string">' '</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><p>这次运行测试代码，将会得到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">E</span><br><span class="line">=======================================================</span><br><span class="line">ERROR: test_first_last_name (__main__.NamesTestCase)</span><br><span class="line">------------------------------------------------------</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">------------------------------------------------------</span><br><span class="line">Ran 1 test in 0.000s</span><br><span class="line"></span><br><span class="line">FAILED (errors=1)</span><br></pre></td></tr></table></figure><ul><li>第一行<strong>字母E</strong>指出测试用例中<strong>有一个单元测试导致了错误</strong>。</li><li>最后一行指出整个测试用例都未通过，因为运行该测试用例时发生了<strong>一个错误</strong>。</li></ul><hr><h4 id="添加新测试"><a href="#添加新测试" class="headerlink" title="添加新测试"></a>添加新测试</h4><p>我们再编写一个测试，用于<strong>测试包含中间名的姓名</strong>。为此，在NamesTestCase类中再添加一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""测试name_function.py"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Janis Joplin 这样的姓名吗？ """</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">'janis'</span>, <span class="string">'joplin'</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">'Janis Joplin'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_middle_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？ """</span></span><br><span class="line">        formatted_name = get_formatted_name(</span><br><span class="line">        <span class="string">'wolfgang'</span>, <span class="string">'mozart'</span>, <span class="string">'amadeus'</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">'Wolfgang Amadeus Mozart'</span>)</span><br><span class="line">        </span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure><ul><li><strong>测试方法名必须以<code>test_</code>打头</strong>，这样它才会在我们运行<code>test_name_function.py</code>时自动运行。</li><li><strong>可以在TestCase类中使用很长的方法名</strong>，这些方法名必须是描述性的，这样才能让你明白测试未通过时的输出。</li></ul><p>两个测试都通过的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.000s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><hr><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><h4 id="各种断言方法"><a href="#各种断言方法" class="headerlink" title="各种断言方法"></a>各种断言方法</h4><p>Python在<code>unittest.TestCase</code>类中提供了很多<strong>断言方法</strong>。</p><p>6个常用的断言方法：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>assertEqual(a, b)</code></td><td>核实<code>a == b</code></td></tr><tr><td><code>assertNotEqual(a, b)</code></td><td>核实<code>a != b</code></td></tr><tr><td><code>assertTrue(x)</code></td><td>核实x为<code>True</code></td></tr><tr><td>assertFalse(x)</td><td>核实x为<code>False</code></td></tr><tr><td><code>assertIn(item, list)</code></td><td>核实item在list中</td></tr><tr><td><code>assertNotIn(item, list)</code></td><td>核实item不在list中</td></tr></tbody></table><hr><h4 id="一个要测试的类"><a href="#一个要测试的类" class="headerlink" title="一个要测试的类"></a>一个要测试的类</h4><p>类的测试与函数的测试相似——所做的大部分工作都是测试类中方法的行为，但存在一些不同之处，下面来编写一个类进行测试。</p><p>来看一个帮助管理匿名调查的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousSurvey</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""收集匿名调查问卷的答案"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, question)</span>:</span></span><br><span class="line">        <span class="string">"""存储一个问题，并为存储答案做准备"""</span></span><br><span class="line">        self.question = question</span><br><span class="line">        self.responses = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_questinon</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示调查问卷"""</span></span><br><span class="line">        print(self.question)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_response</span><span class="params">(self, new_response)</span>:</span></span><br><span class="line">        <span class="string">"""存储单份调查答卷"""</span></span><br><span class="line">        self.responses.append(new_response)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_results</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示收集到的所有答卷"""</span></span><br><span class="line">        print(<span class="string">"Survey results:"</span>)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            print(<span class="string">'- '</span> + response)</span><br></pre></td></tr></table></figure><p>为证明AnonymousSurvey类能够正确地工作，我们来编写一个使用它地程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个问题，并创建一个表示调查地AnonymousSurvey对象</span></span><br><span class="line">question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">my_survey = AnonymousSurvey(question)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示问题并存储答案</span></span><br><span class="line">my_survey。show_question()</span><br><span class="line">print(<span class="string">"Enter 'q' at any time to quit.\n"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    response = input(<span class="string">"Language: "</span>)</span><br><span class="line">    <span class="keyword">if</span> response == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    my_survey.store_response(response)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 显示调查结果</span></span><br><span class="line">print(<span class="string">"\nThank you to everyone who participated in the survey!"</span>)</span><br><span class="line">my_survey.show_results()</span><br></pre></td></tr></table></figure><p>AnonymousSurvey类可用于<strong>进行简单的匿名调查</strong>。假设我们将它放在了模块survey中，并想<strong>进行改进</strong>：<strong>让每位用户都可输入多个答案；编写一个方法，它只列出不同的答案，并指出每个答案出现了多少次</strong>；<strong>再编写一个类，用于管理非匿名调查</strong>。</p><p>进行上述修改存在风险，可能会影响AnonymousSurvey类的当前行为。要确认在开发这个模块时没有破坏既有行为，可以编写针对这个类的测试。</p><hr><h4 id="测试-AnonymousSurvey-类"><a href="#测试-AnonymousSurvey-类" class="headerlink" title="测试 AnonymousSurvey 类"></a>测试 AnonymousSurvey 类</h4><p>下面来编写一个测试，对AnonymouSurvey类的行为进行验证：如果用户面对调查问题时只提供了一个答案，这个答案也能被妥善地存储；用户提供三个答案时，也将被妥善地存储：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonymousSurvey</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""针对AnonymousSurvey类的测试"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_single_response</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试单个答案会被妥善地存储"""</span></span><br><span class="line">        question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">        my_survey = AnonymousSurvey(question)</span><br><span class="line">        my_survey.store_response(<span class="string">'English'</span>)</span><br><span class="line">        </span><br><span class="line">        self.assertIn(<span class="string">'English'</span>, my_survey.responses)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_three_responses</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试三个答案会被妥善地存储"""</span></span><br><span class="line">        question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">        my_survey = AnonymousSurvey(question)</span><br><span class="line">        responses = [<span class="string">'English'</span>, <span class="string">'Spanish'</span>, <span class="string">'Mandarin'</span>]</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">            my_survey.store_response(response)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">            self.assertIn(response, my_survey.responses)</span><br><span class="line">        </span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure><p>上述做法的效果很好，但这些测试有些重复的地方。下面使用unittest的另一项功能来提高它们的效率。</p><hr><h4 id="方法-setUp"><a href="#方法-setUp" class="headerlink" title="方法 setUp()"></a>方法 setUp()</h4><p>unittest.TestCase类中包含了方法<code>setUp()</code>。<strong>让我们只需创建这些对象一次，并在每个测试方法中使用它们</strong>。如果在TestCase类章包含了方法<code>setUp()</code>，Python将先运行它，再运行各个以<code>test_</code>打头的方法。这样，<strong>在每个测试方法中都可使用在方法<code>setUp()</code>中创建的对象了</strong>。</p><p>下面使用<code>setUp()</code>来创建一个调查对象和一组答案，供方法<code>test_store_single_response()</code>和<code>test_store_three_responses()</code>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonymousSurvey</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""针对AnonymousSurvey类的测试"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        创建一个调查对象和一组答案，供使用的测试方法使用</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">        self.my_survey = AnonymousSurvey(question)</span><br><span class="line">        self.responses = [<span class="string">'English'</span>, <span class="string">'Spanish'</span>, <span class="string">'Mandarin'</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_single_response</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试单个答案会被妥善地存储"""</span></span><br><span class="line">        self.my_survey.store_response(self.responses[<span class="number">0</span>])</span><br><span class="line">        self.assertIn(self.responses[<span class="number">0</span>], self.my_survey.responses)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_three_responses</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试三个答案会被妥善地存储"""</span></span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.my_survey.store_response(response)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.assertIn(response, self.my_survey.responses)</span><br><span class="line">        </span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure><p>方法<code>setUp()</code>做了两件事：</p><ol><li>创建一个调查对象</li><li>创建一个答案列表</li></ol><p>存储这两样东西的<strong>变量名包含前缀self</strong>(即<strong>存储在属性中</strong>)，因此<strong>可在这个类的任何地方使用</strong>。</p><p>测试自己编写的类时，方法<code>SetUp()</code>让测试方法编写起来更容易：可<strong>在<code>setUp()</code>方法中创建一系列实例并设置它们的属性，再在测试方法中直接使用这些实例</strong>。</p><p>注意：</p><p>运行测试用例时，<strong>每完成一个单元测试，Python都打印一个字符</strong>：<strong>测试通过时打印一个句点；测试引发错误时打印一个E；测试导致断言失败时打印一个F</strong>。</p><hr><h2 id="Python项目"><a href="#Python项目" class="headerlink" title="Python项目"></a>Python项目</h2><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之数据分析</title>
      <link href="/2020/06/13/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2020/06/13/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>Numpy是Python的一种开源的<strong>数值计算扩展</strong>。可以用来<strong>存储和处理大型矩阵</strong>，比Python自身的<strong>嵌套列表结构(nested list structure)</strong>要<strong>高效得多</strong>。在实际工作中<strong>直接使用情况较少</strong>。</p><ul><li><p><strong>数组</strong></p><p>  <code>numpy.array()</code></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为：array([1, 2, 3, 4])</span></span><br><span class="line"><span class="comment"># 和 列表 相似，但处理效率要高很多</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="comment"># 得到数组 array([5, 2, 3, 4])</span></span><br><span class="line"></span><br><span class="line">a + <span class="number">1</span></span><br><span class="line"><span class="comment"># 数组中每个元素都+1，得到数组 array([6, 3, 4, 5])</span></span><br><span class="line"><span class="comment"># 减法、乘除法同理</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 可以生成多维数组</span></span><br></pre></td></tr></table></figure><ul><li><p>查看数组中<strong>存储的数据类型</strong>：<code>dtype</code></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(b.dtype)</span><br><span class="line"><span class="comment"># 输出为：int32</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><p>Pandas是<strong>基于Numpy</strong>的一种工具，是为了<strong>解决数据分析任务</strong>而创建的。Pandas<strong>提供了大量</strong>能使我们<strong>快速便捷地处理数据</strong>的<strong>函数和方法</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h3 id="两种数据结构"><a href="#两种数据结构" class="headerlink" title="两种数据结构"></a>两种数据结构</h3><h4 id="Series-一维"><a href="#Series-一维" class="headerlink" title="Series  (一维)"></a>Series  (一维)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(s1)</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># 0    1</span></span><br><span class="line"><span class="comment"># 1    2</span></span><br><span class="line"><span class="comment"># 2    3</span></span><br><span class="line"><span class="comment"># 3    4</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line">print(s.index)</span><br><span class="line"><span class="comment"># 输出为：RangeIndex(start=0, stop=4, step=1)</span></span><br><span class="line"></span><br><span class="line">s1[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">s2 = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">print(s2)</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># a    1</span></span><br><span class="line"><span class="comment"># b    2</span></span><br><span class="line"><span class="comment"># c    3</span></span><br><span class="line"><span class="comment"># d    4</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line">s2[<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">print(s2[[<span class="string">'a'</span>, <span class="string">'c'</span>]])</span><br><span class="line"><span class="comment"># 索引多个值 需要用 列表 来表示</span></span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># a    1</span></span><br><span class="line"><span class="comment"># c    3</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">'hunter'</span>:<span class="string">'smart'</span>, <span class="string">'peter'</span>:<span class="string">'handsome'</span>&#125;</span><br><span class="line">s3 = pd.Series(d)</span><br><span class="line">print(s3)</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># hunter       smart</span></span><br><span class="line"><span class="comment"># peter     handsome</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"></span><br><span class="line">s3 = pd.Series(d, index=[<span class="string">'hunter'</span>, <span class="string">'peter'</span>, <span class="string">'haha'</span>])</span><br><span class="line">print(s3)</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># hunter       smart</span></span><br><span class="line"><span class="comment"># peter     handsome</span></span><br><span class="line"><span class="comment"># haha           NaN</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串类型在Series里显示的类型为object</span></span><br><span class="line"><span class="comment"># 可转换类型</span></span><br><span class="line">s2 = s2.astype(<span class="string">'str'</span>) <span class="comment"># 将 数值类型 转换为 字符串类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将浮点数类型转换为int类型</span></span><br><span class="line">x_value = titanic[<span class="string">'Fare'</span>].astype(int)</span><br></pre></td></tr></table></figure><hr><h4 id="DataFrame-二维"><a href="#DataFrame-二维" class="headerlink" title="DataFrame (二维)"></a>DataFrame (二维)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">'name'</span>:[<span class="string">'qinlu'</span>, <span class="string">'lulu'</span>, <span class="string">'qinqin'</span>]</span><br><span class="line">    <span class="string">'sex'</span>:[<span class="string">'male'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>]</span><br><span class="line">    <span class="string">'age'</span>:[<span class="number">18</span>, <span class="number">18</span>, <span class="number">25</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的数据框</span></span><br><span class="line">data = pd.DataFrame()</span><br></pre></td></tr></table></figure><p>得到如下二维表格：</p><table><thead><tr><th></th><th>name</th><th>sex</th><th>age</th></tr></thead><tbody><tr><td>0</td><td>qinlu</td><td>male</td><td>18</td></tr><tr><td>1</td><td>lulu</td><td>male</td><td>18</td></tr><tr><td>2</td><td>qinqin</td><td>female</td><td>25</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment"># 效果类似 Series</span></span><br><span class="line">df</span><br></pre></td></tr></table></figure><p>得到如下二维表格：</p><table><thead><tr><th></th><th>0</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>2</td><td>3</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], columns=list(<span class="string">'abcd'</span>))</span><br><span class="line"><span class="comment"># 提供两行数据和 各列的列名</span></span><br><span class="line"></span><br><span class="line">df</span><br></pre></td></tr></table></figure><p>得到如下二维表格：</p><table><thead><tr><th></th><th>a</th><th>b</th><th>c</th><th>d</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>1</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table><p>DataFrame的<strong>列的顺序默认为提供的顺序</strong>。如下操作可以<strong>调整列的顺序</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = df[[<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>]]</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p>得到如下二维表格：</p><table><thead><tr><th></th><th>b</th><th>d</th><th>c</th><th>a</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>4</td><td>3</td><td>1</td></tr><tr><td>1</td><td>4</td><td>6</td><td>5</td><td>3</td></tr></tbody></table><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 概览数据</span></span><br><span class="line">df.info()</span><br><span class="line"><span class="comment"># &lt;class 'pandas.core.frame.DataFrame'&gt;</span></span><br><span class="line"><span class="comment"># RangeIndex: 3 entries, 0 to 2</span></span><br><span class="line"><span class="comment"># Data columns (total 3 columns):</span></span><br><span class="line"><span class="comment">#  #   Column  Non-Null Count  Dtype </span></span><br><span class="line"><span class="comment"># ---  ------  --------------  ----- </span></span><br><span class="line"><span class="comment">#  0   name    3 non-null      object</span></span><br><span class="line"><span class="comment">#  1   sex     3 non-null      object</span></span><br><span class="line"><span class="comment">#  2   age     3 non-null      int64 </span></span><br><span class="line"><span class="comment"># dtypes: int64(1), object(2)</span></span><br><span class="line"><span class="comment"># memory usage: 200.0+ bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个列的数据类型</span></span><br><span class="line">df.dtypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个列的数据类型</span></span><br><span class="line">df[<span class="string">'name'</span>].dtype</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取某一行</span></span><br><span class="line">df.iloc[<span class="number">0</span>] <span class="comment">#根据 索引(不论是否自定义了标签名) 读取某一行 (推荐，数据量大了之后更适用)</span></span><br><span class="line">df.loc[<span class="number">0</span>] <span class="comment"># 根据 具体标签名 读取某一行</span></span><br><span class="line"><span class="comment"># 上述两种方式输出相同：</span></span><br><span class="line"><span class="comment"># name    lulu</span></span><br><span class="line"><span class="comment"># sex     male</span></span><br><span class="line"><span class="comment"># age       18</span></span><br><span class="line"><span class="comment"># Name: 1, dtype: object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取多行</span></span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 闭区间</span></span><br><span class="line">df[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 开区间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取某一列</span></span><br><span class="line">df[<span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取多个列</span></span><br><span class="line">df[[<span class="string">'age'</span>, <span class="string">'name'</span>]]</span><br><span class="line">df.iloc[:, <span class="number">0</span>:<span class="number">7</span>] <span class="comment"># 所有行和前七列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取二维表格部分列</span></span><br><span class="line">df[[<span class="string">'age'</span>, <span class="string">'name'</span>]][<span class="number">1</span>:<span class="number">2</span>] <span class="comment"># 开区间</span></span><br><span class="line">df[[<span class="string">'age'</span>, <span class="string">'name'</span>]][<span class="string">'age'</span>] <span class="comment"># 获取部分列中的指定列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取二维表格部分区域</span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">2</span>, <span class="number">1</span>:<span class="number">2</span>] <span class="comment"># 指出 索引，iloc不支持布尔类型的过滤</span></span><br><span class="line">df.loc[<span class="string">'a'</span>, [<span class="string">'age'</span>, <span class="string">'name'</span>]] <span class="comment"># 指出 行和列的 标签名</span></span><br><span class="line">df.loc[df.age == <span class="number">19</span>, <span class="string">'age'</span>] <span class="comment"># 指出 符合条件的行的列值 和 列标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改具体值</span></span><br><span class="line">df[<span class="string">'age'</span>] = <span class="number">21</span> <span class="comment"># 统一更改整个列</span></span><br><span class="line">df[<span class="string">'age'</span>] += <span class="number">1</span> <span class="comment"># 统一更改整个列</span></span><br><span class="line">df[<span class="string">'age'</span>] = [<span class="number">21</span>, <span class="number">18</span>, <span class="number">18</span>] <span class="comment"># 自定义更改列中的值</span></span><br><span class="line">df[<span class="string">'age'</span>][<span class="number">1</span>] = <span class="number">22</span> <span class="comment"># 更改某个值</span></span><br><span class="line">df.loc[df.age == <span class="number">19</span>, <span class="string">'age'</span>] = <span class="number">20</span> <span class="comment"># 更改某个筛选范围的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改标签</span></span><br><span class="line">df.index = list(<span class="string">'abc'</span>) <span class="comment"># 更改行标签，通常处理的数据量很大，不建议修改</span></span><br><span class="line">df.columns = list(<span class="string">'abcd'</span>) <span class="comment"># 更改列标签</span></span><br></pre></td></tr></table></figure><hr><h5 id="Series通过reset-index-可以转换为DataFrame"><a href="#Series通过reset-index-可以转换为DataFrame" class="headerlink" title="Series通过reset_index()可以转换为DataFrame"></a>Series通过<code>reset_index()</code>可以转换为DataFrame</h5><p>Series原有的index也是<strong>变为一个列</strong></p><hr><h4 id="代表反转"><a href="#代表反转" class="headerlink" title="~代表反转"></a><code>~</code>代表反转</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ (df.age &gt; <span class="number">19</span>) <span class="comment">#等价于 df.age &lt;= 19</span></span><br></pre></td></tr></table></figure><hr><h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df[df.age == <span class="number">18</span>] <span class="comment"># 筛选出 年龄=18的 所有行(筛选 结果为True 的行)</span></span><br><span class="line">df.query(<span class="string">'age == 18'</span>) <span class="comment"># 和上一条代码等价，条件需要引号标注</span></span><br><span class="line"></span><br><span class="line">df[(df.age == <span class="number">18</span>) | (df.name == <span class="string">'qinqin'</span>)] <span class="comment"># 通过 括号和&amp;/|运算符 进行多条件筛选</span></span><br><span class="line">df.query(<span class="string">"(age == 18) | (name == 'qinqin')"</span>) <span class="comment"># 注意括号不要冲突</span></span><br></pre></td></tr></table></figure><hr><h4 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h4><p>pandas中<strong>增删的运算效率低</strong>，尽量不使用。</p><ul><li><code>del</code>：将指定列从存储空间中删除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> df.loc[df.age == <span class="number">19</span>, <span class="string">'age'</span>]</span><br></pre></td></tr></table></figure><ul><li><p><code>drop()</code>：删除指定项时<strong>返回的是视图</strong>，<strong>数据仍然在存储空间中</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.drop(<span class="string">'age'</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># axis=1表示列，axis=0表示行(默认)</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Pandas基础命令速查表"><a href="#Pandas基础命令速查表" class="headerlink" title="Pandas基础命令速查表"></a><a href="https://www.kesci.com/home/project/59e389b54663f7655c48f518/code" target="_blank" rel="noopener">Pandas基础命令速查表</a></h3><hr><h3 id="读取-写入文件"><a href="#读取-写入文件" class="headerlink" title="读取/写入文件"></a>读取/写入文件</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'xxxx.csv'</span>, encoding=<span class="string">'xxx'</span>, sep=<span class="string">','</span>, names=<span class="string">'abcdefg'</span>)</span><br><span class="line"></span><br><span class="line">df = pd.read_table(<span class="string">'xxxx'</span>, sep=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure><p><code>read_csv()</code>的参数：</p><ul><li><p>文件名</p></li><li><p><code>encoding</code>：指定编码</p><p>  python<strong>默认以utf-8编码</strong>读取文件。如果报错无法正确显示文件内容，可以<strong>将编码改为gbk</strong>等进行读取。</p></li><li><p><code>sep</code>：指定分隔符，<strong>默认为逗号<code>,</code></strong></p><p>有的文件由于不标准等原因，采用其他分隔符如<code>\t</code>，可<strong>通过指定分隔符优化显示</strong>。</p><p><code>sep=&#39;\s+&#39;</code>：将<strong>tab</strong>和<strong>多个空格</strong>都<strong>当成一样的分隔符</strong>。</p></li><li><p><code>parse_dates</code>：将数据<strong>解析为日期</strong></p><p>  <code>parse_dates = True</code>：<strong>尝试解析所有</strong>可能为日期类型的列；</p><p>  <code>parse_dates = [1, 2]</code>：<strong>尝试解析给定列</strong>为日期类型的列。</p><p>  <code>parse_dates = [[1, 2]]</code>：<strong>尝试解析给定列</strong>为日期类型的列，<strong>并将这些列聚合成为1个列</strong></p></li><li><p><code>names</code></p><p>  指定<strong>列名</strong>，<strong>默认为文件中的第一行</strong>。如果自定义列名，文件中的第一行<strong>将作为第一行数据显示</strong>。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.info() <span class="comment"># 概览数据</span></span><br><span class="line"></span><br><span class="line">df.head(<span class="number">10</span>) <span class="comment"># 默认读取前5行</span></span><br><span class="line">df.tail(<span class="number">20</span>) <span class="comment"># 默认读取最后5行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据当前已有的列生成新列</span></span><br><span class="line">df[<span class="string">'avg'</span>] = (df.bottom + df.top) / <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p><code>to_csv()</code></p><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p><code>T</code>：<strong>转置</strong>表格</p><p>  <code>df.T</code></p></li><li><p><code>shape</code>：获取数据框的<strong>行数</strong>和<strong>列数</strong>（<strong>元组</strong>存储）</p><p>  如<code>df.shape</code>：可能得到如<code>(10,5)</code>（10行5列）</p></li><li><p><code>columns</code>：获取所有列</p></li><li><p><code>index</code>：查看索引信息</p></li><li><p><code>set_index()</code>：<strong>设置索引</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crime = crime.set_index(<span class="string">'Year'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="筛选函数"><a href="#筛选函数" class="headerlink" title="筛选函数"></a>筛选函数</h4><ul><li><p><code>sort_values()</code>：<strong>按值排序</strong>，默认<strong>升序</strong></p><p>参数：</p><ul><li><p><code>by</code>：指出排序依据的字段</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by = <span class="string">'avg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下述方式效果类似(返回的是avg的有序数组)</span></span><br><span class="line">df.avg.sort_values()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据多个条件排序</span></span><br><span class="line">df.sort_values(by = [<span class="string">'avg'</span>, <span class="string">'city'</span>]) <span class="comment"># 排序根据unicode而不是拼音，如果想要按照拼音顺序，需要将中文和英文字母关联(可新建一个城市首字母缩写的列)</span></span><br></pre></td></tr></table></figure></li><li><p><code>ascending</code>：默认为True(升序)</p></li><li><p><code>inplace</code>：是否<strong>用排序后的数据集替换原来的数据</strong>，<strong>默认为False</strong></p></li></ul></li><li><p><code>sort_index()</code>：<strong>按索引排序</strong></p></li><li><p><code>rank()</code>：给出<strong>排名</strong></p><p>  参数：</p><ul><li><p><code>ascending</code>：默认为True(升序)</p></li><li><p><code>method</code></p><ul><li><code>&#39;average&#39;</code> (<strong>默认</strong>，如前5个人分数相同，则排名为<strong>(1+5) / 2</strong>  （<strong>最大值和最小值的加权平均数</strong>）)</li><li><code>&#39;min&#39;</code> (取最小值)</li><li><code>&#39;max&#39;</code></li><li><code>&#39;first&#39;</code> (<strong>不考虑并列情况</strong>)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'rank'</span>] = df.avg.rank(ascending=<span class="literal">False</span>, method=<span class="string">'min'</span>) <span class="comment"># 按照平均工资排名，将排名作为新的列加入表格</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>unique()</code>：<strong>去除重复</strong>项</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.city.unique()</span><br></pre></td></tr></table></figure></li><li><p><code>value_counts()</code>：对Series的<strong>每个值进行计数</strong>并且<strong>排序</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.education.value_counts()</span><br></pre></td></tr></table></figure></li><li><p><code>describe()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.avg.describe()</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count 5031.000000</span><br><span class="line">mean 17.111409</span><br><span class="line">std 8.996242</span><br><span class="line">min 1.500000</span><br><span class="line">25% 11.500000</span><br><span class="line">50% 15.000000</span><br><span class="line">75% 22.500000</span><br><span class="line">max 75.000000</span><br><span class="line">Name: avg dtype: float64</span><br></pre></td></tr></table></figure><ul><li><code>count</code>：计数</li><li><code>mean</code>：平均数</li><li><code>std</code>：<strong>标准差</strong></li></ul><p><code>describe()</code>的统计内容会<strong>自动忽略空值</strong></p></li><li><p><code>count()</code></p></li><li><p><code>max()</code></p></li><li><p><code>min()</code></p></li><li><p><code>last()</code></p></li><li><p><code>mean()</code></p><p>  对<strong>整个数据框</strong>求平均值，结果为<strong>按列(默认)分别计算平均值</strong>，得到一个<strong>Series</strong>；</p><p>  对Series求平均值，结果则为一个平均数</p><p>  参数：<code>axis=0</code> （0为按列，1为按行）</p></li><li><p><code>sum()</code></p></li><li><p><code>median()</code>：<strong>中位数</strong></p></li><li><p><code>std()</code>：<strong>标准差</strong></p></li><li><p><code>var()</code>：<strong>方差</strong></p></li><li><p><code>cumsum()</code>：<strong>累加</strong></p></li><li><p><code>pandas.cut()</code>：<strong>分类统计</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4等分</span></span><br><span class="line">pd.cut(df.avg, bins=<span class="number">4</span>, label=list(<span class="string">'abcd'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义分隔区间</span></span><br><span class="line"><span class="comment"># 为了能够全部包含需要分类的数据区间，最后的值一般一个取极大的值</span></span><br><span class="line">pd.cut(df.avg, bins=[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>], label=[<span class="string">'0~5'</span>, <span class="string">'5~10'</span>, <span class="string">'10~20'</span>, <span class="string">'20~30'</span>, <span class="string">'30~100'</span>])</span><br></pre></td></tr></table></figure></li><li><p><code>pandas.qcut()</code></p></li><li><p><code>isin()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到英格兰(England)、意大利(Italy)和俄罗斯(Russia)的射正率(Shooting Accuracy)</span></span><br><span class="line">euro12.loc[euro12[<span class="string">'Team'</span>].isin([<span class="string">'England'</span>, <span class="string">'Italy'</span>, <span class="string">'Russia'</span>]), [<span class="string">'Team'</span>, <span class="string">'Shooting Accuracy'</span>]]</span><br></pre></td></tr></table></figure><p><strong>可以和<code>~</code>配合使用，达到不存在的函数<code>isnotin()</code>的效果</strong>。</p></li><li><p><code>idxmax()</code>：返回<strong>请求轴</strong>上<strong>第一次</strong>出现<strong>最大值</strong>(不包括<code></code>NA/null`)的<strong>索引</strong></p><p>  参数：</p><ul><li><code>axis=0</code>：0对应行，1对应列</li></ul></li></ul><hr><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p><strong>MySQL</strong>难以完成<strong>分组排序</strong>。</p><ul><li><p><code>groupby()</code>：分组</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(by = <span class="string">'city'</span>)</span><br><span class="line"><span class="comment"># 得到如下已存入内存的提示：</span></span><br><span class="line"><span class="comment"># &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x0000012CF16A41C8&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前分组下，对各分组中的各列进行统计</span></span><br><span class="line">df.groupby(by = <span class="string">'city'</span>).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前分组下，各分组中各列的最大值</span></span><br><span class="line">df.groupby(by = <span class="string">'city'</span>).max()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前分组下，对各分组中某列的最大值</span></span><br><span class="line">df.groupby(by = <span class="string">'city'</span>)[<span class="string">'avg'</span>].max()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多字段分组</span></span><br><span class="line">df.groupby(by = [<span class="string">'city'</span>, <span class="string">'workYear'</span>]).mean()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> df.groupby(by=[<span class="string">'city'</span>]):</span><br><span class="line">    <span class="comment"># 打印每个分组中的元素数量</span></span><br><span class="line">    print(len(k[<span class="number">1</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打印分组的依据元素(具体的city)</span></span><br><span class="line">    print(k)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打印分割线</span></span><br><span class="line">    print(<span class="string">'**'</span> *<span class="number">10</span>) <span class="comment"># 20个星号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打印分组中元素的详细内容</span></span><br><span class="line">    print(v)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打印同个城市中，最高薪资和最低薪资的差值</span></span><br><span class="line">    print(max(v.avg) - min(v[<span class="string">'avg'</span>]))</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="多表关联"><a href="#多表关联" class="headerlink" title="多表关联"></a>多表关联</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">position = pd.read_csv(<span class="string">'position.csv'</span>)</span><br><span class="line">company = pd.read_csv(<span class="string">'company.csv'</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>merge()</code>函数 —— 根据<strong>具体的键值</strong></p><p>相当于<strong>SQL中的JOIN</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">position.merge(right = company, how=<span class="string">'left'</span>, on=<span class="string">'companyId'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改列名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一：单独更改一个列名</span></span><br><span class="line">col = list(company.columns)</span><br><span class="line">col[<span class="number">0</span>] = <span class="string">'id'</span></span><br><span class="line">company.columns = col</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：利用rename()更改指定列名</span></span><br><span class="line">company.rename(columns=&#123;<span class="string">'0'</span>:<span class="string">'id'</span>, <span class="string">'1'</span>:<span class="string">'xxx'</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pd.merge(left=position, right=company, how=<span class="string">'inner'</span>, left_on=<span class="string">'companyId'</span>, right_on=<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>left/right</code>：关联的表</li><li><code>how</code>：<strong>关联的方式</strong><ul><li><code>inner</code>(<strong>默认</strong>)</li><li><code>outer</code></li><li><code>left</code></li></ul></li><li><p><code>right</code></p></li><li><p><code>on</code>：具体的键值(在<strong>两个表中对应列名相同</strong>时使用)</p></li><li><code>left_on/right_on</code>：具体的键值(在<strong>两个表中对应列名不同</strong>时使用，关联之后<strong>保留不同名的列</strong>)</li></ul><hr></li><li><p><code>join()</code>：根据<strong>索引</strong>(<strong>行号</strong>)</p><p>按照索引关联很有<strong>局限性</strong>。</p><ul><li>只要两个表<strong>列名不同</strong>，不加任何参数就可直接使用</li><li>如果两个表有重复的列名，需要制定<code>lsuffix</code>，<code>rsuffix</code>参数</li><li><strong>默认左外连接</strong>(LEFT JOIN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.join(df2)</span><br></pre></td></tr></table></figure></li><li><p><code>concat()</code>：<strong>堆叠</strong></p><p>  类似于SQL中的<strong>UNION</strong>，多个表<strong>暴力堆叠</strong>，新的表<strong>包含多个表的所有列</strong>，没有对应列值的表项为NaN。</p><p>  参数：</p><ul><li><p><code>axis</code>:</p><ul><li><strong>0</strong>：<strong>上下</strong>堆叠(<strong>默认</strong>，<strong>相同列名</strong>会<strong>合并</strong> )</li><li><strong>1</strong>：<strong>左右</strong>堆叠</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([company, position], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>区分辨别</strong></p><p><strong>Series</strong>级别可以直接输入<strong>索引标签</strong>进行筛选；<strong>DataFrame</strong>级别，需要通过<code>loc</code>进行筛选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">position.groupby(by=[<span class="string">'city'</span>, <span class="string">'education'</span>]).mean().avg[<span class="string">'上海'</span>]</span><br><span class="line"></span><br><span class="line">position.groupby(by=[<span class="string">'city'</span>, <span class="string">'education'</span>]).mean().loc[<span class="string">'上海'</span>, <span class="string">'博士'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># reset_index() 重置索引</span></span><br><span class="line">position.groupby(by=[<span class="string">'city'</span>, <span class="string">'education'</span>]).mean().reset_index()[<span class="string">'上海'</span>, <span class="string">'博士'</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>不借助<code>groupby</code></strong>，如何<strong>设置多重索引</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sort_values 用于排序，set_index 将列设置为索引</span></span><br><span class="line">position.sort_values(by=[<span class="string">'city'</span>, <span class="string">'education'</span>]).set_index([<span class="string">'city'</span>, <span class="string">'education'</span>])</span><br></pre></td></tr></table></figure><hr><ul><li><p><code>agg()</code><strong>函数</strong></p><p>  <code>agg()</code>是聚合函数，得到DataFrame。参数有：</p><ul><li><code>func</code>：<strong>实现某种统计功能的函数</strong></li><li><p><code>axis=0</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grouped_user 是通过groupby('user_id')得到的 DataFrameGroupBy 对象</span></span><br><span class="line">user_life = grouped_user[<span class="string">'order_dt'</span>].agg([<span class="string">'first'</span>, <span class="string">'last'</span>]) <span class="comment"># order_dt列是时间格式，first 和 last 函数能分别得到最早和最迟的时间</span></span><br><span class="line">user_life.head()</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="文本函数"><a href="#文本函数" class="headerlink" title="文本函数"></a>文本函数</h4><ul><li><p><code>str.count()</code>：统计指定字符出现的次数</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.positionLabels.str.count(<span class="string">'分析师'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>str.find()</code>：查找指定字符出现的位置</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.positionLabels.str.find(<span class="string">'数据'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>str[1:-1]</code>：去除<strong>表示列表的方括号</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.positionLabels.str[<span class="number">1</span>:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>str.replace(&quot;&#39;&quot;, &quot;&quot;)</code>：<strong>去除列表中元素的单引号</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.positionLabels.str[<span class="number">1</span>:<span class="number">-1</span>].str.replace(<span class="string">"'"</span>, <span class="string">""</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>str.startwith()</code>：筛选<strong>以指定字符开头</strong>的字符串</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">euro12[<span class="string">'Team'</span>].str.startwith(<span class="string">'G'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>str.split()</code>：<strong>拆分</strong>单元格内容</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df2 = df[<span class="string">'某一列'</span>].str.split(<span class="string">'指定分隔符'</span>, expand=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 默认会删去分隔符</span></span><br><span class="line"><span class="comment"># expand=True 能让拆分后的单元格内容 由 列表类型 变为 DataFrame(默认为False)</span></span><br></pre></td></tr></table></figure></li><li><p><code>str.extract()</code>：<strong>提取</strong>单元格中<strong>所需内容</strong></p><p>  参数：</p><ul><li><code>pat</code>：字符串或<strong>正则表达式</strong><ul><li><strong>只有用<code>()</code>包裹的部分才会被保留</strong></li><li>Python中使用正则表达式<strong>命名捕获组语法</strong>为：<code>(?P&lt;name&gt;Expression)</code>，即<strong>将<code>name</code>作为列名</strong></li></ul></li><li><code>flags</code>：整型</li><li><p><code>expand</code>：是否将提取的内容由列表类型变为DataFrame</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取 '建筑年代'列 的数字，剥离 年建</span></span><br><span class="line">df3[<span class="string">'建筑年代'</span>] = df3[<span class="string">'建筑年代'</span>].str.extract(<span class="string">'(\d+)年建'</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>str(xxx)</code>：将其他类型的数据(如时间)<strong>转为字符串</strong></p></li></ul><hr><h4 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h4><ul><li><p>Python中的 datetime模块</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">now = datetime.now() <span class="comment"># 获取当前日期和时间</span></span><br><span class="line">print(now)</span><br><span class="line"></span><br><span class="line">print(datetime.date.today()) <span class="comment"># 获取当前日期</span></span><br><span class="line"></span><br><span class="line">delta = now - datetime(<span class="number">2017</span>,<span class="number">6</span>,<span class="number">27</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>) <span class="comment"># 获取日期相差值</span></span><br><span class="line">print(delta) <span class="comment"># 得到 xxdays, xx:xx:xx.xxx</span></span><br><span class="line"></span><br><span class="line">print(delta.days) <span class="comment"># 72天数</span></span><br><span class="line"></span><br><span class="line">print(delta.seconds) <span class="comment"># 秒数</span></span><br><span class="line">print(delta.microseconds) <span class="comment"># 微秒数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2061年？我们真的有这一年的数据？创建一个函数并用它去修复这个bug</span></span><br><span class="line"><span class="comment"># x是一个 YYYY-mm-dd格式 的日期</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix_century</span><span class="params">(x)</span>:</span></span><br><span class="line">    year = x.year</span><br><span class="line">    <span class="keyword">if</span> year &gt; <span class="number">2000</span>:</span><br><span class="line">       year -= <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> datetime.date(year, x.month, x.day)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text = <span class="string">'2019-09-07'</span></span><br><span class="line">y = datetime.strptime(text, <span class="string">'%Y-%m-%d'</span>) <span class="comment"># 把字符串转为日期</span></span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前日期的前后n日期</span></span><br><span class="line">print(datetime.date.today()+timedelta(days=<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得某一日期的月初和月末</span></span><br><span class="line">text=<span class="string">'2019-09-07'</span></span><br><span class="line">month_first=datetime.strptime(text[:<span class="number">8</span>]+<span class="string">'01'</span>,<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">print(month_first) <span class="comment">#输出结果为:2019-09-01 00:00:00</span></span><br><span class="line"></span><br><span class="line">month_end=datetime.strptime(text[:<span class="number">5</span>] + str(int(text[<span class="number">5</span>:<span class="number">7</span>])+<span class="number">1</span>) + <span class="string">'-01'</span>,<span class="string">'%Y-%m-%d'</span>)+timedelta(days=<span class="number">-1</span>)</span><br><span class="line">print(month_end) <span class="comment"># 输出结果为:2019-09-30 00:00:00</span></span><br></pre></td></tr></table></figure><ul><li><code>datetime.now()</code>：获取<strong>当前日期和时间</strong>(和MySQL的<code>NOW()</code>相同)</li><li><code>datetime.date.today()</code>：获取<strong>当前日期</strong></li><li><code>datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])</code>：生成指定的时间</li><li><code>datetime.date(year, month, day)</code>：构造<strong>日期格式</strong>，但是<strong>数据类型不变</strong></li><li><code>datetime.strptime()</code>：把字符串转为日期(和pandas的to_datetime函数作用相同)</li></ul></li></ul><hr><ul><li><p>Pandas中的 to_datetime函数</p><p>  <code>pandas.to_datetime()</code>：<strong>将指定列的 数据类型 转换为 指定格式的 时间类型</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">crime[<span class="string">'Year'</span>] = pandas.to_datetime(crime[<span class="string">'Year'</span>], format=<span class="string">'%Y'</span>)</span><br><span class="line"></span><br><span class="line">date=[<span class="string">'2017-6-26'</span>, <span class="string">'2017-6-27'</span>]</span><br><span class="line">print(pd.to_datetime(date))</span><br><span class="line"><span class="comment">#输出结果为:DatetimeIndex(['2017-06-26', '2017-06-27'], dtype='datetime64[ns]', freq=None)</span></span><br></pre></td></tr></table></figure><p>  <strong>format参数</strong>和<a href="https://hunter1023.github.io/2020/06/28/Python%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化-模块 datetime </a>中<strong>含义一致</strong></p></li></ul><hr><ul><li><p><code>astype()</code></p><p>  可以<strong>将时间类型的数据更改精度</strong>。<code>pandas.to_datetime()</code><strong>默认转换的时间类型</strong>为<code>datetime64[ns]</code>，<strong>精度为ns(纳秒)级</strong>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'datetime'</span>] = pd.to_datetime(df[<span class="string">'datetime'</span>], format=<span class="string">'%Y%m%d'</span>)</span><br><span class="line">df[<span class="string">'month'</span>] = df[<span class="string">'datetime'</span>].values.astype(<span class="string">'datetime64[M]'</span>) <span class="comment"># 将精度转换为M(月份)级别，日子一律会更改为1日</span></span><br></pre></td></tr></table></figure><p>  上述代码，使用<code>values</code>将Series内的数值以<code>ndarray</code>或<code>ndarray-like</code>的形式返回，因为<code>datetime64[ns]</code>无法直接转换为<code>datetime64[M]</code>类型</p></li></ul><hr><ul><li><p><code>pandas.date_range()</code>：<strong>创建时间序列</strong></p><p>  <strong>参数：</strong></p><ul><li><code>start</code>：起始时间</li><li><code>end</code>：结束时间</li><li><code>periods</code>：当<strong>只声明了</strong>起始时间<strong>或</strong>结束时间时，需要告知<strong>时间范围</strong></li><li><p><code>freq</code>：<strong>时间频率</strong>（默认为<code>&#39;D&#39;</code>(<strong>Calendar</strong> day frequency)）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">pd.date_range(start=datetime.now(), periods=<span class="number">6</span>, freq=<span class="string">'B'</span>) <span class="comment"># 'B'的含义为 营业日频率(business day frequency)</span></span><br><span class="line"><span class="comment"># 得到：</span></span><br><span class="line"><span class="comment"># DatetimeIndex(['2020-07-13 20:34:18.990072', '2020-07-14 20:34:18.990072',</span></span><br><span class="line"><span class="comment">#               '2020-07-15 20:34:18.990072', '2020-07-16 20:34:18.990072',</span></span><br><span class="line"><span class="comment">#               '2020-07-17 20:34:18.990072', '2020-07-20 20:34:18.990072'],</span></span><br><span class="line"><span class="comment">#              dtype='datetime64[ns]', freq='B')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd.date_range(start=<span class="string">'20130809'</span>,periods=<span class="number">8</span>,freq=<span class="string">'SM'</span>) <span class="comment"># 'SM'的含义为 月中和月末(semi-month end frequency)</span></span><br><span class="line"><span class="comment"># 得到：</span></span><br><span class="line"><span class="comment"># DatetimeIndex(['2020-07-15', '2020-07-31', '2020-08-15', '2020-08-31',</span></span><br><span class="line"><span class="comment">#               '2020-09-15', '2020-09-30', '2020-10-15', '2020-10-31'],</span></span><br><span class="line"><span class="comment">#              dtype='datetime64[ns]', freq='SM-15')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd.date_range(start=datetime.now(),periods=<span class="number">5</span>,freq=<span class="string">'2H20min'</span>) <span class="comment"># 时间间隔140min</span></span><br><span class="line"></span><br><span class="line">pd.date_range(start=<span class="string">'20190623'</span>, periods=<span class="number">10</span>, freq=<span class="string">'1D10U'</span>) <span class="comment"># 时间间隔1天10微秒</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p><code>numpy.timedelta64()</code></p><p>Numpy允许两个Datetime值相减，这个操作产生一个<strong>带有时间单位</strong>的数字。由于NumPy的核心<strong>没有物理量(物理单位)系统</strong>，因此<strong>创建了<code>timedelta64</code>数据类型以补充<code>datetime64</code></strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.datetime64(<span class="string">'2017-08-03'</span>) - np.datetime64(<span class="string">'2017-07-15'</span>)</span><br><span class="line"><span class="comment"># 得到的结果是 x = numpy.timedelta64(19,'D') # 第一个参数为数字，第二个参数为单位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用timedelta64() 消除单位</span></span><br><span class="line">x / np.timedelta64(<span class="number">1</span>, <span class="string">'D'</span>) <span class="comment"># 得到的结果是19.0</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>以日期时间序列为索引</strong>的最多日期<strong>相差天数</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(df.index.max() - df.index.min()).days</span><br></pre></td></tr></table></figure></li><li><p><strong>以日期时间序列为索引</strong>的数据框中一共<strong>有多少个月</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = df.resample(<span class="string">'BM'</span>).last()</span><br><span class="line">len(d.index) <span class="comment"># 'DatetimeIndex' object has no attribute 'count'，因此不能使用count函数计数</span></span><br></pre></td></tr></table></figure></li><li><p>把字符串转成日期</p></li></ul><hr><h5 id="重新采样"><a href="#重新采样" class="headerlink" title="重新采样"></a>重新采样</h5><p>重新采样指<strong>将时间序列从一个频率转换为另一个频率</strong>的过程。</p><ul><li><p><strong>降</strong>采样（向下采样）</p><p>  高频时间序列变为低频，<strong>时间粒度变大</strong>。如：原有100个时间点，变为10个时间点</p></li><li><p>升采样（向上采样）</p><p>  低频时间序列变为高频，<strong>时间粒度变小</strong>。，</p></li><li><p>同频之间的切换</p><p>  比如W-WED(weekly on Wednesday 每周三)转换到W-FRI(每周五）</p></li></ul><p><strong>函数<code>resample()</code></strong>：</p><p>不同于<strong>groupby关注特征值</strong>的分组操作，它在<strong>以时间序列为索引</strong>的数据框中使用，对时间索引分组操作来聚合运算。</p><p>参数：</p><ul><li><p><code>rule</code>：所需采样频率的字符串</p><p>  | 字符串    | 含义                                                         |<br>  | ——— | ———————————————————— |<br>  | B         | 营业日频率<br>(business day frequency)                     |<br>  | C         | 自定义营业日频率<br>(custom business day frequency)        |<br>  | D         | 日历日频率<br>(calendar day frequency)                     |<br>  | W         | 每周一次频率<br>(weekly frequency)                         |<br>  | M         | 月末频率<br>(month <strong>end</strong> frequency)                      |<br>  | SM        | 月中和月末频率<br>(semi-month end frequency (<strong>15th</strong> and <strong>end</strong> of month)) |<br>  | BM        | 营业月末频率<br>(business month end frequency)             |<br>  | CBM       | 自定义月末频率<br>(custom business month end frequency)    |<br>  | MS        | 月初频率<br>(month <strong>start</strong> frequency)                    |<br>  | SMS       | 月初和月中频率<br>(semi-month start frequency (<strong>1st</strong> and <strong>15th</strong>)) |<br>  | BMS       | 营业月初频率<br>(business month start frequency)           |<br>  | CBMS      | 自定义营业月初频率<br>(custom business month start frequency) |<br>  | Q         | 季度末频率<br>(quater <strong>end</strong> frequency)                   |<br>  | BQ        | 营业季度末频率<br>(business quater end frequency)          |<br>  | QS        | 季度初频率<br>(quater start frequency)                     |<br>  | BQS       | 营业季度初频率<br>(business quater start frequency)        |<br>  | A / Y     | 年末频率<br>(year end frequency)                           |<br>  | BA / BY   | 营业年末频率<br>(business year end frequency)              |<br>  | AS / YS   | 年初频率<br>(year start frequency)                         |<br>  | BAS / BYS | 营业年初频率<br>(business year start frequency)            |<br>  | BH        | 营业小时频率<br>(business hour frequency)                  |<br>  | H         | 小时频率<br>(hourly frequency)                             |<br>  | T / min   | 分钟频率<br>(minutely frequency)                           |<br>  | S         | 秒频率<br>(secendly frequency)                             |<br>  | L / ms    | 毫秒频率<br>(milliseconds)                                 |<br>  | U / us    | 微秒频率<br>(microseconds)                                 |<br>  | N         | 纳秒频率<br>(nanoseconds)                                  |</p></li><li><p><code>axis=0</code>：需要采样的轴向(0为行方向)</p></li><li><p><code>closed</code>：在<strong>降</strong>采样时，各时间段<strong>哪一侧(left/right)是</strong>闭合的。</p></li><li><p><code>label</code>：在降采样时，index<strong>用区间的左界值还是右界值</strong>。</p></li></ul><hr><h4 id="空值相关"><a href="#空值相关" class="headerlink" title="空值相关"></a>空值相关</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">--snip--</span><br><span class="line"><span class="comment"># 赋空值</span></span><br><span class="line"><span class="comment"># NaN是C语言类型的空值，比直接赋值None更合适</span></span><br><span class="line">position.loc[position.city==<span class="string">'深圳'</span>, <span class="string">'city'</span>] = np.NaN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计数据框中每列缺失值的数量（每列缺失的行数）</span></span><br><span class="line">position.isnull().sum()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计数据框中每列有多少非空值(非空行)</span></span><br><span class="line"><span class="comment"># 方式一：</span></span><br><span class="line">position.notnull().sum</span><br><span class="line"><span class="comment"># 方式二：</span></span><br><span class="line">position.shape[<span class="number">0</span>] - position.isnull().sum()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对空值进行填充</span></span><br><span class="line">position.fillna(<span class="number">1</span>, inplace=<span class="literal">True</span>) <span class="comment"># 统一填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空值所在的行(默认)或列</span></span><br><span class="line">position.dropna()</span><br></pre></td></tr></table></figure><hr><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找重复值(默认：第一次遇到不会当作重复值，将第二次开始遇到的值作为重复值看待)</span></span><br><span class="line">position[position.duplicated()]</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 判断是否有重复</span></span><br><span class="line">s.is_unique</span><br><span class="line"></span><br><span class="line">s[s.duplicated()] <span class="comment"># 会筛选出索引为1处对应的值1，索引为0处的1不会被筛选出来</span></span><br><span class="line">s[s.duplicated(keep=<span class="string">'last'</span>)] <span class="comment"># 保留最后一个重复的值，即索引为0处的1会被筛选出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重</span></span><br><span class="line">s.drop_duplicates() <span class="comment"># 默认保留第一个重复值(keep=’first')</span></span><br><span class="line"><span class="comment"># 获取每月的消费人数 (需要根据user_id去重)</span></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">plt.plot(df[<span class="string">'user_id'</span>].apply(<span class="keyword">lambda</span> x:len(x.drop_duplicates())))</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">d = df.groupby([<span class="string">'month'</span>, <span class="string">'user_id'</span>]).count().reset_index()</span><br><span class="line">plt.plot(d.groupby(<span class="string">'month'</span>)[<span class="string">'user_id'</span>].count())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回去重后的列</span></span><br><span class="line">s.unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回去重后的元素个数</span></span><br><span class="line">s.nunique()</span><br></pre></td></tr></table></figure><hr><h4 id="移动数据：shift"><a href="#移动数据：shift" class="headerlink" title="移动数据：shift()"></a>移动数据：<code>shift()</code></h4><p>参数：</p><ul><li><p><code>periods</code>：移动的<strong>幅度</strong>(可正可负)，<strong>默认为1</strong>。</p><p>  只移动数据，<strong>不移动索引，移动之后没有对应值的，赋值为<code></code>NaN`</strong></p></li><li><p><code>freq</code>：用于<strong>时间序列索引</strong>，<strong>默认为<code>None</code></strong></p><ul><li><code>DateOffset</code></li><li><code>timedelta</code></li><li><p><code>time rule string</code></p><p>按照参数值<strong>移动时间索引</strong>，<strong>不移动数据值</strong>。</p></li></ul></li><li><p><code>axis</code>：指定<strong>移动方向</strong></p><ul><li><code>0</code>：上下移动(<strong>默认</strong>)</li><li><code>1</code>：左右移动</li></ul></li></ul><hr><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p><code>apply()</code>可以<strong>将函数应用到所有的行/列上进行处理</strong>。</p><ul><li><p><code>apply()</code>中的匿名函数<code></code>lambda<code>中的</code>x`<strong>到底指代什么</strong>：</p><ol><li><p>对<strong>某一列</strong>操作时：</p><p> 每一个x<strong>依次对应各行</strong>的具体值</p></li><li><p>对<strong>多个列</strong>(axis<strong>=0</strong>，默认)操作时：</p><p> 每一个x<strong>依次对应每一列</strong></p></li><li><p>对<strong>多个列</strong>(axis<strong>=1</strong>)操作时：</p><p> 每一个x<strong>依次对应每一行</strong>(依次对每个单元格进行操作)</p></li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Series级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用匿名函数，向 position表格中的avg列的每一行 都在末尾添加一个字符k</span></span><br><span class="line">position.avg.apply(<span class="keyword">lambda</span> x:str(x)+<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显式创建函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">20</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'20+k'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> str(x)+<span class="string">'k'</span></span><br><span class="line"></span><br><span class="line">position.avg.apply(func)</span><br><span class="line"><span class="comment"># -----------------------------------------------</span></span><br><span class="line"><span class="comment"># DataFrame级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x.avg &gt; <span class="number">20</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'20+k'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0~20k'</span></span><br><span class="line"></span><br><span class="line"> position.apply(func, axis=<span class="number">1</span>) <span class="comment"># axis=1应用于每行；axis=0应用于每列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">20</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'20+k'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0~20k'</span></span><br><span class="line"></span><br><span class="line"> position.apply(<span class="keyword">lambda</span> x:func(x.avg), axis=<span class="number">1</span>) <span class="comment"># axis=1应用于每行；axis=0应用于每列</span></span><br></pre></td></tr></table></figure><hr><ul><li><p>匿名函数lambda中<strong>条件语句</strong>的使用</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 条件语句为 A if 条件 else B</span></span><br><span class="line"><span class="comment"># 即 满足条件则输出A，否则输出B</span></span><br><span class="line">x.apply(<span class="keyword">lambda</span> x:<span class="string">'1'</span> <span class="keyword">if</span> x&gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">'0'</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><p>将<code>apply()</code><strong>应用到聚合函数上</strong></p><p>获取<strong>不同城市</strong>中工资水平<strong>前五</strong>的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    r = x.sort_values(<span class="string">'avg'</span>, ascending=<span class="literal">False</span>) <span class="comment"># 按工资降序排序</span></span><br><span class="line">    <span class="keyword">return</span> r[:n] <span class="comment"># 返回前n</span></span><br><span class="line"></span><br><span class="line">position.groupby(<span class="string">'city'</span>).apply(func, n=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="Pandas中map-apply-和applymap-的区别"><a href="#Pandas中map-apply-和applymap-的区别" class="headerlink" title="Pandas中map(), apply()和applymap()的区别"></a>Pandas中<code>map()</code>, <code>apply()</code>和<code>applymap()</code>的区别</h4><p>参考：<a href="https://blog.csdn.net/maymay_/article/details/80229053" target="_blank" rel="noopener">Pandas中的map(), apply()和applymap()的应用</a></p><p><strong>它们的区别在于应用的对象不同</strong>：</p><ul><li><p><code>map()</code></p><p>  是一个Series的函数，将一个自定义的函数<strong>应用于Series结构中的每个元素</strong></p></li><li><p><code>apply()</code></p><p>  将函数作用于<strong>DataFrame</strong>中的<strong>每个行</strong>或者<strong>列</strong></p></li><li><p><code>applymap()</code></p><p>  将函数作用于<strong>DataFrame</strong>中的<strong>每个元素</strong></p></li></ul><hr><h4 id="数据透视"><a href="#数据透视" class="headerlink" title="数据透视"></a>数据透视</h4><p><code>pivot_table()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">position.pivot_table(index=[<span class="string">'city'</span>, <span class="string">'education'</span>], </span><br><span class="line">                     columns=<span class="string">'workYear'</span>,</span><br><span class="line">                     values=[<span class="string">'avg'</span>, <span class="string">'top'</span>], </span><br><span class="line">                     margins=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># index 指定索引（可多重）</span></span><br><span class="line"><span class="comment"># columns 可选，用于细分数据(相当于Excel透视表里的列标签)</span></span><br><span class="line"><span class="comment"># values 筛选列(相当于Excel透视表里的数值)</span></span><br><span class="line"><span class="comment"># margins=True 对各列进行汇总计算，默认为False</span></span><br><span class="line"><span class="comment"># aggfunc 应用于参数values</span></span><br><span class="line"></span><br><span class="line">position.pivot_table(index=[<span class="string">'city'</span>, <span class="string">'education'</span>], </span><br><span class="line">                     columns=<span class="string">'workYear'</span>,</span><br><span class="line">                     values=[<span class="string">'avg'</span>, <span class="string">'top'</span>], </span><br><span class="line">                     aggfunc=&#123;<span class="string">'avg'</span>:<span class="string">'mean'</span>, <span class="string">'top'</span>:np.sum&#125;).reset_index().to_csv(<span class="string">'test.csv'</span>) <span class="comment"># avg求平均值，对top求和</span></span><br></pre></td></tr></table></figure><p>注：数据透视<strong>不适合用来去重</strong></p><hr><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><ul><li>安装相关工具包</li></ul><p><code>pip install pymysql</code></p><p><strong>注意：</strong>如果是安装了Anaconda，<strong>要在Jupyter Notebook中载入pymysql包</strong>，则<strong>必须在Jupyter Notebook中打开Python3或Ternimal的页面输入上述代码</strong>。另外单独安装的Python是独立于Anaconda的，两者下载的工具包可能无法通用。</p><ul><li><p>连接</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conn = pymysql.connect(</span><br><span class="line">host = <span class="string">'localhost'</span>, <span class="comment"># 本地数据库，也可输入 '127.0.0.1'</span></span><br><span class="line">    user = <span class="string">'root'</span>,</span><br><span class="line">    password = <span class="string">'123456'</span>,</span><br><span class="line">    db = <span class="string">'test'</span>,</span><br><span class="line">    port = <span class="number">3306</span>,</span><br><span class="line">    charset = <span class="string">'utf8'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询数据库</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cur = conn.cursor() <span class="comment"># 获取游标</span></span><br><span class="line">cur.execute(<span class="string">'SELECT * FROM courses'</span>) <span class="comment"># 执行SQL语句</span></span><br><span class="line">data = cur.fetchall() <span class="comment"># 调取SQL语句执行后的结果(元组的形式)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">    print(d[<span class="number">0</span>], d[<span class="number">1</span>], d[<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li><p>提交对数据库的修改</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.commit()</span><br></pre></td></tr></table></figure></li><li><p>关闭数据库的连接</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="使用Pandas对数据库进行操作"><a href="#使用Pandas对数据库进行操作" class="headerlink" title="使用Pandas对数据库进行操作"></a>使用Pandas对数据库进行操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(query, db=<span class="string">'data'</span>)</span>:</span></span><br><span class="line">    sql = query</span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost:3306/&#123;0&#125;?charset=utf8'</span>.format(db)) <span class="comment"># 允许使用pymysql方法连接mysql数据库</span></span><br><span class="line">df = pd.read_sql(sql, engine) <span class="comment"># 将数据库中数据作为DataFrame读取</span></span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">reader(<span class="string">"SHOW TABLES"</span>)</span><br><span class="line"></span><br><span class="line">df_company = reader(<span class="string">"SELECT * FROM company"</span>)</span><br><span class="line">df_dataanalyst = reader(<span class="string">"SELECT * FROM dataanalyst"</span>)</span><br><span class="line">merged = pd.merge(df_dataanalyst, df_company, on=<span class="string">'companyId'</span>)</span><br><span class="line"></span><br><span class="line">result = merged.groupby([<span class="string">'city'</span>, <span class="string">'companyFullName'</span>]).count()[<span class="string">'positionId'</span>].reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">result.to_sql(name=<span class="string">'newtable'</span>, </span><br><span class="line">             con=<span class="string">'mysql+pymysql://root:123456@localhost:3306/data?charset=utf8'</span>,</span><br><span class="line">             if_exists=<span class="string">'append'</span>，<span class="comment">#  表不存在时，创建新表(if_exists默认为fail，表不存在时无法写入)，但为了符合数据库中的数据格式要求，最好按默认的fail</span></span><br><span class="line">             index = <span class="literal">False</span>) <span class="comment"># 不将索引作为字段写入数据库</span></span><br></pre></td></tr></table></figure><hr><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>Matplotlib是一个Python的<strong>2D绘图库</strong>。它以各种<strong>硬拷贝格式</strong>和<strong>跨平台的交互式环境</strong>生成<strong>出版质量级别的图形</strong>。我们通常<strong>使用该库将数据可视化</strong>，更形象直观地暴露问题所在。</p><hr><h2 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h2><p>Scikit-learn(Sklearn)是<strong>机器学习中常用的第三方模块</strong>，<strong>对常用的机器学习方法进行了封装</strong>，是建立在Numpy、Scipy、Matplotlib之上，简单高效的<strong>数据挖掘</strong>和<strong>数据分析工具</strong>。</p><hr><h2 id="Jupyter"><a href="#Jupyter" class="headerlink" title="Jupyter"></a>Jupyter</h2><p>Jupyter是一个<strong>Web应用程序</strong>，可以用来<strong>编写Python代码</strong>、<strong>图表展示</strong>、<strong>数值处理和转换</strong>、<strong>数值模拟</strong>和<strong>统计建模</strong>等各种任务。</p><h3 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>自动补全</td></tr><tr><td>Shift + Tab</td><td>显示函数示例</td></tr><tr><td>Shift + Enter</td><td>执行当前，并跳转至下一Cell</td></tr><tr><td>Ctrl + Enter</td><td>执行当前，并留在当前Cell</td></tr></tbody></table><hr><h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><p><strong>Anaconda</strong>是一个免费开源的<strong>Python和R语言的发行版本</strong>，用于<strong>计算科学（数据科学、机器学习、大数据处理和预测分析）</strong>，Anaconda致力于简化包管理和部署。Anaconda的包使用<strong>软件包管理系统Conda</strong>进行管理。</p><p>Anaconda<strong>3</strong>默认包含Python <strong>3.7</strong>，但是用户<strong>可以创建虚拟环境来使用任意版本的Python包</strong>。</p><h3 id="Anaconda-Navigator"><a href="#Anaconda-Navigator" class="headerlink" title="Anaconda Navigator"></a>Anaconda Navigator</h3><p>Anaconda Navigator是包含在Anaconda中的<strong>图形用户界面</strong>，用户可以通过Anaconda Navigator启动应用，在<strong>不使用命令行的情况下管理软件包、创建虚拟环境和管理路径</strong>。</p><p>Anaconda Navigator包含如下应用：</p><ul><li>JupyterLab</li><li>Jupyter Notebook</li><li>QtConsole</li><li>Spyder</li><li>Glueviz</li><li>Orange</li><li>Rstudio</li><li>Visual Studio Code</li></ul><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="利用apply-，使用自定义函数更新DataFrame每行单元格的内容，但是得到的不是DataFrame对象"><a href="#利用apply-，使用自定义函数更新DataFrame每行单元格的内容，但是得到的不是DataFrame对象" class="headerlink" title="利用apply()，使用自定义函数更新DataFrame每行单元格的内容，但是得到的不是DataFrame对象"></a>利用apply()，使用自定义函数更新DataFrame每行单元格的内容，但是得到的不是DataFrame对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 定性 用户18个月的消费</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">active_status</span><span class="params">(data)</span>:</span></span><br><span class="line">    status = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">18</span>): <span class="comment"># 一共18个月的记录</span></span><br><span class="line">        <span class="comment"># 如果本月没有消费</span></span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> len(status) &gt; <span class="number">0</span>: <span class="comment"># 记录过状态</span></span><br><span class="line">                <span class="keyword">if</span> status[i<span class="number">-1</span>] == <span class="string">'unreg'</span>: <span class="comment"># 上个月是未注册</span></span><br><span class="line">                    status.append(<span class="string">'unreg'</span>) <span class="comment"># 仍然是未注册</span></span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 之前已注册(有过消费)</span></span><br><span class="line">                    status.append(<span class="string">'unactive'</span>) <span class="comment"># 为不活跃</span></span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># 没记录过状态</span></span><br><span class="line">                status.append(<span class="string">'unreg'</span>) <span class="comment"># 为未注册</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 本月有消费</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(status) == <span class="number">0</span>: <span class="comment"># 没记录过状态</span></span><br><span class="line">                status.append(<span class="string">'new'</span>) <span class="comment"># 新用户(第一次消费)</span></span><br><span class="line">            <span class="keyword">else</span>:               <span class="comment"># 之前记录过</span></span><br><span class="line">                <span class="keyword">if</span> status[i<span class="number">-1</span>] == <span class="string">'unactive'</span>: <span class="comment"># 上个月为不活跃</span></span><br><span class="line">                    status.append(<span class="string">'return'</span>)   <span class="comment"># 更新为 回流</span></span><br><span class="line">                <span class="keyword">elif</span> status[i<span class="number">-1</span>] == <span class="string">'unreg'</span>: <span class="comment"># 上个月为未注册</span></span><br><span class="line">                    status.append(<span class="string">'new'</span>)     <span class="comment"># 新用户(第一次消费)</span></span><br><span class="line">                <span class="keyword">else</span>:                      </span><br><span class="line">                    status.append(<span class="string">'active'</span>) <span class="comment"># 更新为活跃</span></span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line">cdnow_purchase.apply(active_status, axis=<span class="number">1</span>) <span class="comment"># 对每一行进行操作</span></span><br></pre></td></tr></table></figure><ul><li><p>原因：</p><p>  <strong>自定义函数的返回值</strong>是<strong>列表</strong>，而<strong>不是Series</strong>，导致apply()之后的结果不是一个DataFrame对象。</p></li><li><p>解决方法：</p><p>  将自定义函数的<strong>返回值转换为Series对象</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="keyword">return</span> pd.Series(status, index=cdnow_purchase.columns) <span class="comment"># index参数是原DataFrame对象的各列列名</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel技巧</title>
      <link href="/2020/06/01/Excel%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/06/01/Excel%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>编辑单元格内容</td><td>F2</td></tr><tr><td>单元格内换行</td><td><strong>Alt</strong> + enter</td></tr><tr><td>设置单元格格式</td><td>Ctrl + <strong>1</strong></td></tr><tr><td><a href="https://zhuanlan.zhihu.com/p/33511879" target="_blank" rel="noopener">Ctrl+E的众多效用</a><br>（拼接单元格内容、拆分提取单元格内容、<br>替换字符、去除空格和符号、自动换行…）</td><td>Ctrl + E</td></tr></tbody></table><hr><h2 id="绝对引用行-列"><a href="#绝对引用行-列" class="headerlink" title="绝对引用行/列"></a>绝对引用行/列</h2><p>使用<code>$</code>符号即可<strong>绝对引用</strong>行<strong>或</strong>列</p><hr><h2 id="多个单元格中有部分内容需要重复输入"><a href="#多个单元格中有部分内容需要重复输入" class="headerlink" title="多个单元格中有部分内容需要重复输入"></a>多个单元格中有部分内容需要重复输入</h2><p>如：邮箱后缀、电话区号、订单号前缀</p><p>希望达到效果：只需向单元格中输入不一样的内容部分，<strong>重复部分自动填充</strong></p><p>操作：</p><ol><li><p>选定需要设置的单元格范围，<strong>设置单元格格式</strong>(Ctrl + 1)</p></li><li><p>数字 - 分类 - 自定义 - 类型</p></li><li><p>输入框中填写需要的格式</p><ol><li><p><strong>添加邮箱共同后缀</strong></p><p>输入<code>@&quot;@163.com&quot;</code></p></li></ol><ol start="2"><li><p><strong>添加电话区号</strong>：</p><p>输入<code>&quot;0755-&quot;@</code></p></li></ol></li></ol><hr><h2 id="批量从身份证号中提取生日"><a href="#批量从身份证号中提取生日" class="headerlink" title="批量从身份证号中提取生日"></a>批量从身份证号中提取生日</h2><p>编辑单元格：<code>=TEXT(MID(身份证号所在单元格, 起始位数, 提取长度), &quot;生日格式&quot;(如0000-00-00))</code></p><hr><h2 id="筛选出重复值-唯一值"><a href="#筛选出重复值-唯一值" class="headerlink" title="筛选出重复值(唯一值)"></a>筛选出重复值(唯一值)</h2><ol><li>选中<strong>需要筛选出重复值(唯一值)的范围</strong></li><li>开始 - 样式 - 条件格式 - <strong>突出显示单元格规则</strong> - <strong>重复值</strong></li></ol><hr><h2 id="去除重复值"><a href="#去除重复值" class="headerlink" title="去除重复值"></a>去除重复值</h2><ol><li>选择需要去重的单元格区域</li><li><strong>数据 - 数据工具 - 删除重复值</strong></li></ol><hr><h2 id="长数字输入"><a href="#长数字输入" class="headerlink" title="长数字输入"></a>长数字输入</h2><ul><li>Excel单元格<strong>常规型数字</strong>的特殊机制<ol><li>输入的数字<strong>＞11位</strong>时，<strong>自动</strong>采用<strong>科学计数法</strong></li><li>数字的<strong>精度</strong>是<strong>15</strong>位</li></ol></li></ul><p>最佳解决方式：</p><p>设置单元格格式(<strong>Ctrl + 1</strong>) - 数字 - 分类 - <strong>文本</strong></p><hr><h2 id="冻结窗口"><a href="#冻结窗口" class="headerlink" title="冻结窗口"></a>冻结窗口</h2><ul><li>冻结<strong>指定的某行/列</strong>：选中需要冻结的行或列，选择<strong>视图 - 窗口 - 冻结窗格</strong>即可</li><li>冻结<strong>指定的多行以及多列</strong>：<ol><li><strong>视图 - 窗口 - 拆分</strong>，会显示一个<strong>十字型的拆分参考线</strong>。</li><li>移动拆分参考线至所需的行、列</li><li>视图 - 窗口 - <strong>冻结窗口</strong></li></ol></li></ul><hr><h2 id="选中整行-整列-数据"><a href="#选中整行-整列-数据" class="headerlink" title="选中整行/整列 数据"></a>选中整行/整列 数据</h2><ul><li>选中整行<strong>数据</strong>：选定<strong>起始单元格</strong>，<code>Ctrl + Shift + →</code></li><li>选中整列<strong>数据</strong>：选定<strong>起始单元格</strong>，<code>Ctrl + Shift + ↓</code></li></ul><hr><h2 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h2><p>数据透视表(Pivot Table) 是一种交互式的表，可以进行某些计算，如求和与计数等，所进行的计算与数据跟数据透视表中的排列有关。</p><p>之所以称为数据透视表，是因为<strong>可以动态地改变它们的版面布置</strong>，<strong>以便按照不同方式分析数据</strong>，也可以重新安排行号、列标和页字段。每一次改变版面布置时，数据透视表会立即按照新的布置重新计算数据。另外，<strong>如果原始数据发生更改，则可以更新数据透视表</strong>。</p><ol><li>选择需要透视的表格区域</li><li>插入 - 表格 - 数据透视表</li></ol><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="VLOOKUP函数"><a href="#VLOOKUP函数" class="headerlink" title="VLOOKUP函数"></a>VLOOKUP函数</h3><p>按<strong>列</strong>查找，最终返回查询序列中所对应的值。</p><p>与之对应的HLOOKUP是按行查找的。</p><ul><li>使用场景：<ol><li>两张表格</li><li>两张表格中<strong>存在相同列</strong></li><li>表2中存在表1不具备的字段，想把表2中的字段关联到表1中</li></ol></li><li>单元格中输入：<code>=VLOOKUP(lookup_value，table_array，col_index_num，range_lookup)</code><ol><li>lookup_value：查找的值</li><li>table_array：要查找的区域</li><li>col_index_num：需要返回的元素在区域中的第几<strong>列</strong></li><li>range_lookup：<strong>精确</strong>匹配/<strong>近似</strong>匹配<ul><li><strong>1</strong>/<strong>TRUE</strong>：<strong>近似</strong>匹配</li><li><strong>0</strong>/<strong>FALSE</strong>：<strong>精确</strong>匹配</li></ul></li></ol></li></ul><hr><h3 id="INDEX-MATCH-函数"><a href="#INDEX-MATCH-函数" class="headerlink" title="INDEX + MATCH 函数"></a>INDEX + MATCH 函数</h3><ul><li><p>使用场景：</p><p>  功能与VLOOKUP函数基本相同，但是<strong>能弥补VLOOKUP函数的局限性</strong>(想要关联的列<strong>在相同列的左侧</strong>时，<strong>无法匹配</strong>)。</p></li><li><p><code>MATCH(lookup_value, lookup_array, [match_type])</code></p><ol><li>lookup_value：查找的值</li><li>lookup_array：查找<strong>区域(只能1列宽)</strong></li><li><p>[match_type]：</p><ul><li>1：<strong>小于</strong></li><li>0：<strong>精确匹配</strong></li><li>-1：<strong>大于</strong></li></ul><p>结果返回<strong>查找区域中的所在行数</strong></p></li></ol></li><li><p><code>INDEX(array, row_num, [column_num])</code></p><ol><li>array：查找区域</li><li>row_num：所在<strong>行数</strong>(<strong>通过MATCH函数获取</strong>)</li><li>[column_num]：所在列数</li></ol></li></ul><hr><h3 id="AND-函数-OR-函数"><a href="#AND-函数-OR-函数" class="headerlink" title="AND 函数 / OR 函数"></a>AND 函数 / OR 函数</h3><ul><li><code>AND(logical1,[logical2],...)</code></li><li><code>OR(logical1,[logical2],...)</code></li></ul><p>用于<strong>条件判断</strong></p><hr><h3 id="IF-函数"><a href="#IF-函数" class="headerlink" title="IF 函数"></a>IF 函数</h3><p><code>IF(logical_test, [value_if_true], [value_if_false])</code>：</p><ol><li>logical_test：<strong>逻辑判断</strong></li><li>[value_if_true]：结果为true时的值(<strong>字符串</strong>使用<strong>双引号标注</strong>)</li><li>[value_if_false]：结果为false时的值</li></ol><p>例子：使用IF函数，判断业绩完成情况</p><p>单元格中输入：<code>=IF(N4-M4&gt;=0,&quot;已完成&quot;, M4-N4)</code></p><h4 id="IF-函数嵌套-示例"><a href="#IF-函数嵌套-示例" class="headerlink" title="IF 函数嵌套 示例"></a>IF 函数嵌套 示例</h4><p><code>=IF(AND(O4=&quot;已完成&quot;,R4=&quot;已完成&quot;),&quot;已完成&quot;,IF(AND(O4=&quot;已完成&quot;,R4&lt;&gt;&quot;已完成&quot;),&quot;仅业绩完成&quot;,IF(AND(O4&lt;&gt;&quot;已完成&quot;,R4=&quot;已完成&quot;),&quot;仅入会完成&quot;,&quot;均未完成&quot;)))</code></p><hr><h3 id="COUNTIFS-函数"><a href="#COUNTIFS-函数" class="headerlink" title="COUNTIFS 函数"></a>COUNTIFS 函数</h3><p><code>COUNTIFS(criteria_range1, criteria1,...)</code></p><ul><li><p>使用场景：</p><p>  对区域中<strong>符合条件的单元格</strong>进行筛选<strong>计数</strong>。</p></li><li><p>参数：</p><ul><li><p>criteria_range1: 筛选<strong>区域</strong></p></li><li><p>criteria1：<strong>筛选</strong>条件</p></li><li><p>criteria_range2</p><p>  …</p></li></ul></li></ul><hr><h3 id="SUMIFS-函数"><a href="#SUMIFS-函数" class="headerlink" title="SUMIFS 函数"></a>SUMIFS 函数</h3><p><code>SUMIFS(sum_range, criteria_range1, criteria1,...)</code></p><ul><li><p>使用场景：</p><p>  对区域中<strong>符合条件的单元格</strong>进行筛选<strong>求和</strong>。</p></li><li><p>参数：</p><ul><li><p>sum_range：<strong>求和区域</strong></p></li><li><p>criteria_range1：筛选<strong>区域</strong></p></li><li><p>criteria1：<strong>筛选</strong>条件</p></li><li><p>criteria_range2</p><p>  …</p><p><strong>求和区域和筛选区域，类似VLOOKUP函数中两张表的感觉</strong>。</p></li></ul></li></ul><hr><h3 id="LEFT、MID、RIGHT-函数"><a href="#LEFT、MID、RIGHT-函数" class="headerlink" title="LEFT、MID、RIGHT 函数"></a>LEFT、MID、RIGHT 函数</h3><ul><li><code>LEFT(text, [num_chars])</code></li><li><code>MID(text, start_num, num_chars)</code></li><li><code>RIGHT(text, [num_chars])</code><ul><li>text：文本所在单元格</li><li>start_num：起始位置是第几个字符</li><li>num_chars：截取的字符长度</li></ul></li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/68af835de06a" target="_blank" rel="noopener">数据分析中常用的9个Excel函数 - 简书</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题目分类</title>
      <link href="/2020/02/16/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/"/>
      <url>/2020/02/16/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>根据《算法笔记》一书，对PAT甲级、乙级真题和<a href="http://codeup.cn/contest.php" target="_blank" rel="noopener">codeup</a>部分试题进行分类。</p><h2 id="1-C-C-快速入门"><a href="#1-C-C-快速入门" class="headerlink" title="1. C/C++快速入门"></a>1. C/C++快速入门</h2><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104146906" target="_blank" rel="noopener">codeup 杨辉三角</a></li></ul><hr><h3 id="1-2-指针"><a href="#1-2-指针" class="headerlink" title="1.2 指针"></a>1.2 指针</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104151149" target="_blank" rel="noopener">codeup C语言10.16</a></li></ul><hr><h3 id="1-3-结构体的使用"><a href="#1-3-结构体的使用" class="headerlink" title="1.3 结构体的使用"></a>1.3 结构体的使用</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104156997" target="_blank" rel="noopener">codeup C语言11.1</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104158080" target="_blank" rel="noopener">codeup C语言11.2</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104158719" target="_blank" rel="noopener">codeup C语言11.4</a></li></ul><hr><h2 id="2-入门模拟"><a href="#2-入门模拟" class="headerlink" title="2. 入门模拟"></a>2. 入门模拟</h2><h3 id="2-1-简单模拟"><a href="#2-1-简单模拟" class="headerlink" title="2.1 简单模拟"></a>2.1 简单模拟</h3><p><strong>不涉及算法，只是根据题目描述来编写代码，考察代码能力。</strong></p><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/weixin_39345384/article/details/104163314" target="_blank" rel="noopener">codeup 问题 B: A+B</a></td><td>\</td></tr><tr><td><strong>B1001 害死人不偿命的(3n+1)猜想</strong></td><td>\</td></tr><tr><td><strong>B1010 一元多项式求导</strong></td><td>\</td></tr><tr><td><strong>B1011 A+B和C</strong></td><td>\</td></tr><tr><td><strong>B1012 数字分类</strong></td><td>有条不紊地整理</td></tr><tr><td><strong>B1016 部分A+B</strong></td><td>\</td></tr><tr><td><strong>B1018 锤子剪刀布</strong></td><td><strong>注意scanf留在缓冲区的换行符<code>\n</code>的处理</strong></td></tr><tr><td><strong>B1026 程序运行时间</strong></td><td>\</td></tr><tr><td><strong>B1032 挖掘机技术哪家强</strong></td><td>统计各学校总分的方式</td></tr><tr><td><strong>B1046 划拳</strong></td><td>\</td></tr><tr><td><strong>A1002</strong> <strong>A+B for Polynomials</strong></td><td>非零系数项个数的统计</td></tr><tr><td><strong>A1009</strong> <strong>Product of Polynomials</strong></td><td>第二个多项式可边读边处理</td></tr><tr><td><strong>A1042</strong> <strong>Shuffling Machine</strong></td><td><strong>将扑克顺序号转为实际牌号的方式</strong></td></tr><tr><td><strong>A1046 Shortest Distance</strong></td><td>便于计算距离的方式</td></tr><tr><td><strong>A1065</strong> <strong>A+B and C (64bit)</strong></td><td><strong>B1011</strong> <strong>A+B 和 C 进阶版</strong><br><strong>负数相加若溢出，可能得到0</strong></td></tr></tbody></table><hr><h3 id="2-2-查找元素"><a href="#2-2-查找元素" class="headerlink" title="2.2 查找元素"></a>2.2 查找元素</h3><p>查找是学习写代码的一项基本功。</p><ul><li>一般来说，如果需要在一个比较小范围的数据集内内进行查找，<strong>直接遍历</strong>即可。</li><li>如果需要查找的范围较大，可以用<a href="#35-二分">二分查找</a><strong>等算法</strong>进行更快速的查找</li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1004</strong> <strong>成绩排名</strong></td><td>\</td></tr><tr><td><strong>B1028</strong> <strong>人口普查</strong></td><td><strong>1. 不合理年龄的判断方式</strong><br><strong>2. 需要考虑全不合理的情况</strong></td></tr><tr><td><strong>B1032</strong> <strong>挖掘机技术哪家强</strong></td><td>统计各学校总分的方式</td></tr><tr><td><strong>B1041</strong> <strong>考试座位号</strong></td><td>\</td></tr><tr><td><strong>A1011</strong> <strong>World Cup Betting</strong></td><td>\</td></tr><tr><td><strong>A1006</strong> <strong>Sign In and Sign Out</strong></td><td>方法类似 B1028 人口普查</td></tr><tr><td><strong>A1036</strong> <strong>Boys vs Girls</strong></td><td>\</td></tr></tbody></table><hr><h3 id="2-3-图形输出"><a href="#2-3-图形输出" class="headerlink" title="2.3 图形输出"></a>2.3 图形输出</h3><p>做法一般有两种：</p><ul><li>通过规律，直接进行输出</li><li>定义一个二维字符数组，通过规律填充，然后输出整个二维数组</li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1027</strong> <strong>打印沙漏</strong></td><td><strong>沙漏高度和符号数量的关系</strong></td></tr><tr><td><strong>B1036</strong> <strong>跟奥巴马一起编程</strong></td><td>\</td></tr><tr><td><strong>A1031</strong> <strong>Hello World for U</strong></td><td>根据 n1和n3为  $\leq$ n2，且满足 n1+n2+n3 = N+2 的最大值，求出n1，n2，n3</td></tr></tbody></table><hr><h3 id="2-4-日期处理"><a href="#2-4-日期处理" class="headerlink" title="2.4 日期处理"></a>2.4 日期处理</h3><p>需要处理好<strong>平年和闰年、大月和小月</strong>的问题，需要<strong>细心</strong>处理。</p><p>闰年的判断方法：</p><ol><li><p><strong>非整百年</strong>：能<strong>被4整除</strong>为闰年</p></li><li><p><strong>整百年</strong>：能<strong>被400整除</strong>的是闰年（<strong>1900年不是闰年</strong>）</p></li></ol><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104252546" target="_blank" rel="noopener">codeup 问题 A: 日期差值</a></li></ul><hr><h3 id="2-5-进制转换"><a href="#2-5-进制转换" class="headerlink" title="2.5 进制转换"></a>2.5 进制转换</h3><p>对一个<strong>P进制的数</strong>，如果要<strong>转换为Q进制</strong>，需要分两步：</p><ol><li><p>将 P进制数x <strong>转换为 十进制数y</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>, pro = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">    y += (x % <span class="number">10</span>) * pro;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">    pro *= p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将 十进制数y <strong>转换为 Q进制数z</strong></p><p>采用<strong>除基取余法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">40</span>], num = <span class="number">0</span>; <span class="comment">//数组z 存放 Q进制数y 的每一位，num为位数</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    z[num++] = y % Q; <span class="comment">//除基取余</span></span><br><span class="line">    y /= Q;</span><br><span class="line">&#125; <span class="keyword">while</span>(y != <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>do···while</code>语句而不是<code>while</code>的原因是：<strong>如果十进制数y = 0，使用<code>while</code>语句将使循环直接跳出，导致结果出错</strong>。</p></li></ol><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1022</strong> <strong>D进制的A+B</strong></td><td><strong>除基取余法</strong></td></tr><tr><td><strong>B1037</strong> <strong>在霍格沃茨找零钱</strong></td><td>\</td></tr><tr><td><strong>A1019</strong> <strong>General Palindromic Number</strong></td><td>\</td></tr><tr><td><strong>A1027</strong> <strong>Colors in Mars</strong></td><td>\</td></tr><tr><td><strong>A1058</strong> <strong>A+B in Hogwarts</strong></td><td>题型同 乙级1037 在霍格沃茨找零钱<br>单位转换过程可能会超过int范围</td></tr></tbody></table><hr><h3 id="2-6-字符串处理"><a href="#2-6-字符串处理" class="headerlink" title="2.6 字符串处理"></a>2.6 字符串处理</h3><p>考察<strong>代码能力</strong>的题型。一般需要<strong>仔细分析清楚</strong>题目中的<strong>输入和输出格式</strong>才能顺利AC。</p><p>有些题目中，可能<strong>实现逻辑非常麻烦</strong>，有很多<strong>细节</strong>和<strong>边界</strong>情况，此类题目需要<strong>多做多想，积累经验</strong>。</p><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1002</strong> <strong>写出这个数</strong></td><td><strong>数字转为字符串</strong>：<br>C语言：<code>sprintf(str, &quot;%d&quot;, num)</code><br>C++：<code>to_string(num)</code></td></tr><tr><td><strong>B1006</strong> <strong>换个格式输出整数</strong></td><td>\</td></tr><tr><td><strong>B1009</strong> <strong>说反话</strong></td><td><strong>句子颠倒，单词本身不颠倒</strong><br>C++ 待更新</td></tr><tr><td><strong>B1014</strong> <strong>福尔摩斯的约会</strong><br><strong>A1061</strong> <strong>Dating</strong></td><td><strong>正确归纳</strong>解码方式</td></tr><tr><td><strong>B1021</strong> <strong>个位数统计</strong></td><td>\</td></tr><tr><td><strong>B1024</strong> <strong>科学计数法</strong><br><strong>A1073</strong> <strong>Scientific Notation</strong></td><td><strong>1. 利用正则表达式，分开读取 数字部分 和 指数部分</strong><br>2. 指数 &lt; 0：整数部分必然为 0<br>3. 指数 &gt;= 0：<br>     - <strong>仍有小数点，何时输出小数点</strong><br>     - 没有小数点，后续输出0</td></tr><tr><td><strong>B1031</strong> <strong>查验身份证</strong></td><td>\</td></tr><tr><td><strong>B1048</strong> <strong>数字加密</strong></td><td><strong>1. 对齐两个整数</strong> <br>     - 若加密正整数A 比 B 长，B<strong>高位补0</strong>后进行加密 <br>     - 若加密正整数A 比 B 短，B<strong>多余的部分正常输出，等同于A高位补0</strong>后进行加密 <br> 2. 结果从数字高位(<strong>字符串低位</strong>)<strong>开始输出</strong></td></tr><tr><td><strong>A1001</strong> <strong>A+B Format</strong></td><td>从<strong>数字高位(字符串低位)开始</strong>，需要添加<code>,</code>的位置满足<strong><code>(i + 1) % 3 == len % 3</code> 且 不是最后一位</strong></td></tr><tr><td><strong>A1005</strong> <strong>Spell It Right</strong></td><td>\</td></tr><tr><td><strong>A1035</strong> <strong>Password</strong></td><td>(待优化)</td></tr><tr><td><strong>A1077</strong> <strong>Kuchiguse</strong></td><td><strong>1. 通过<code>reverse()</code>反转字符串，将后缀转换为前缀，便于比较</strong><br>2. <code>getline()</code>之前注意<strong>读取换行符</strong>。</td></tr><tr><td><strong>A1082</strong> <strong>Read Number in Chinese</strong></td><td>1. <strong>四位数字分为一节</strong>，单位为个、万、亿<br>2. <strong>一节中数字全为0</strong>，则不输出<strong>节的单位</strong><br>3. 节中<strong>第一个非零数之前有0</strong>，则输出<strong>1个</strong>0</td></tr></tbody></table><hr><h2 id="3-算法初步"><a href="#3-算法初步" class="headerlink" title="3. 算法初步"></a>3. 算法初步</h2><h3 id="3-1-排序"><a href="#3-1-排序" class="headerlink" title="3.1 排序"></a>3.1 排序</h3><h4 id="3-1-1-简单选择排序（-O-n-2-）"><a href="#3-1-1-简单选择排序（-O-n-2-）" class="headerlink" title="3.1.1 简单选择排序（$O(n^2)$）"></a>3.1.1 简单选择排序（$O(n^2)$）</h4><p>简单选择排序是指，对一个序列A中的元素<code>A[0] ~ A[n-1]</code>，令<code>i</code>从 0 到 n-1 枚举，进行 n 趟操作，每一趟从<strong>待排部分</strong>$[i, n-1]$中<strong>选择最小元素（记录下标）</strong>，令其<strong>与待排部分</strong>的<strong>第一个元素A[i]</strong>进行交换，使得$[0, i]$<strong>区间有序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//降序 简单选择排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">//选出最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[i])</span><br><span class="line">                k = j; <span class="comment">//记录更小元素的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = A[i]; <span class="comment">//交换A[k]与A[i]</span></span><br><span class="line">        A[i] = A[j];</span><br><span class="line">        A[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-2-直接插入排序（-O-n-2-）"><a href="#3-1-2-直接插入排序（-O-n-2-）" class="headerlink" title="3.1.2 直接插入排序（$O(n^2)$）"></a>3.1.2 直接插入排序（$O(n^2)$）</h4><p>直接插入排序是指，对序列A的n个元素<code>A[0]~A[n-1]</code>，令 i <strong>从 1 </strong>到 n-1 枚举，进行 n - 1 趟操作。</p><p>某一趟时，序列A的前 i 个元素 <code>A[0]~A[i-1]</code>已经有序，则该趟在范围$[0, i - 1]$中，<strong>从后往前</strong>寻找某个位置j，使得<code>A[i]</code>插入后，范围$[0, i]$有序(<strong><code>A[j]~A[i]</code>后移一位</strong>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//升序 直接插入排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = A[i], j = i;</span><br><span class="line">        <span class="comment">//从后往前遍历，便于编写代码</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; A[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-3-冒泡排序（-O-n-2-）"><a href="#3-1-3-冒泡排序（-O-n-2-）" class="headerlink" title="3.1.3 冒泡排序（$O(n^2)$）"></a>3.1.3 冒泡排序（$O(n^2)$）</h4><p>冒泡排序的本质在于<strong>交换</strong>，即每次通过交换的方式把当前<strong>剩余元素的最大值(升序)</strong>移动到一端，当<strong>剩余元素减少到0</strong>时，排序结束。整个过程执行 <strong>n-1 趟</strong>，每一趟<strong>从左到右依次比较相邻的元素</strong>，如果<strong>大的数在左边，则交换</strong>，该趟结束时，<strong>最大数</strong>被移动到<strong>当前剩余数的最右边</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//升序 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">//进行 n - 1 趟排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-4-排序题与sort函数的应用"><a href="#3-1-4-排序题与sort函数的应用" class="headerlink" title="3.1.4 排序题与sort函数的应用"></a>3.1.4 排序题与sort函数的应用</h4><p>PAT中的排序题，大部分<strong>只需要得到排序的最终结果，而不需要去写排序的完整过程(例如冒泡排序、快速排序等)</strong>，因此推荐直接使用<strong>C语言的库函数<code>qsort</code></strong>或是<strong>C++的<code>sort</code>函数</strong>进行排序。<code>qsort</code>函数的使用需要运用指针，且写法上没有<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p><ul><li><p><strong>结构体数组的排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; ssd[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>如果想先<strong>按x</strong>从大到小排序，<strong>在x相等的情况下</strong>，<strong>按y</strong>从小到大排序(即<strong>二级排序</strong>)，cmp的写法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="comment">//返回值为true时，a排在b之前</span></span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">//降序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y; <span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>排名的实现</strong></p><p>很多排序题要求<strong>在排序之后</strong>计算每个个体的<strong>排名</strong>，规则一般是：<strong>分数相同的排名相同，占用一个排位</strong>。例如有5个学生的分数分别为90、88、88、88、86，其排名分别为1、2、2、2、5。</p><p><strong>方法：</strong></p><p>将第一个个体排名记为1，遍历剩余个体，如果当前分数等于上一个个体的分数，则当前个体排名等于<strong>上一个个体的排名</strong>，否则当前个体的排名等于<strong>数组下标+1</strong></p></li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1015</strong> <strong>德才论</strong><br><strong>A1062</strong> <strong>Talent and Virtue</strong></td><td>设置flag作为考生的分类，便于所有考生<strong>统一排序</strong></td></tr><tr><td><strong>A1012</strong> <strong>The Best Rank</strong></td><td>1. <strong>利用全局变量设计cmp函数</strong><br>2. 通过<strong>记录所有科目的排名</strong>，最后选出最好的排名以及对应科目<br>3. 相同分数者排名相同，<strong>下一不同分数者</strong>排名为<strong>数组下标+1</strong></td></tr><tr><td><strong>A1016</strong> <strong>Phone Bills</strong></td><td><strong>（待优化）</strong><br>1. <strong>通话记录统一先排序</strong>后处理<br>2. <strong>连续的两个通话记录，判断是否为 同一用户 且 为先通话后挂断的状态</strong><br>3. <strong>通话时长的统计方法</strong><br>4. 单位美分cents 要转换为 美元$</td></tr><tr><td><strong>A1025</strong> <strong>PAT Ranking</strong></td><td>\</td></tr><tr><td><strong>A1028</strong> <strong>List Sorting</strong></td><td>\</td></tr><tr><td><strong>A1055</strong> <strong>The World’s Richest</strong></td><td><strong>超时问题。要求输出的人数$\leq$100，通过筛去每个年龄多余的人解决</strong></td></tr><tr><td><strong>A1075</strong> <strong>PAT Judge</strong></td><td><strong>(待优化)</strong><br>1. <strong>不能编译</strong>的提交<strong>得分为0</strong><br>2. 没有提交过的答案需要输出为<code>-</code>，利用<code>&lt;cstring&gt;</code>中的<code>memset</code>函数，<strong>为 得分数组 赋值 -1，表示没有提交过答案</strong><br>3. <strong>没有任何一题通过编译 或 没有提交过答案的人</strong>不记录排名，<strong>设置 是否有通过编译的标识</strong>，进行筛选<br>4. 读取数据时，<strong>将用户数组下标看作id</strong>，便于统计<br>5. 排序<strong>以 是否有通过编译 为 第一排序条件</strong></td></tr><tr><td>A1080</td><td></td></tr><tr><td>A1083</td><td></td></tr><tr><td>A1095</td></tr></tbody></table><hr><h3 id="3-2-散列"><a href="#3-2-散列" class="headerlink" title="3.2 散列"></a>3.2 散列</h3><h4 id="3-2-1-散列-hash-的定义与整数散列"><a href="#3-2-1-散列-hash-的定义与整数散列" class="headerlink" title="3.2.1 散列(hash)的定义与整数散列"></a>3.2.1 散列(hash)的定义与整数散列</h4><blockquote><p>例题:</p><p>给出$N$个正整数，再给出$M$个正整数，问这$M$个数中的每个数分别是否在$N$个数中出现过，其中 $N, M \leq10^5$，且所有正整数均不超过$10^5$。例如 $N = 5，M = 3$， $N$个正整数为 ${8， 3， 7， 6， 2}$，欲查询的$M$个正整数为 ${7， 4， 2}$。</p></blockquote><p>对这个问题，最直观的思路是：对每个欲查询的正整数$x$，遍历所有$N$个数，看是否有一个数与$x$相等。这种做法的时间复杂度为$O(NM)$，显然不是好方法。可以采取<strong>用空间换时间</strong>的方式，用<strong>数组下标</strong>作为<strong>对应整数的标识</strong>，即设定一个<code>bool</code>型数组<code>hashTable[100001]</code>，其中<code>hashTable[x] == true</code>表示正整数$x$在$N$个整数中出现过。这样就可以在一开始读入$N$个正整数时进行预处理。于是，对$M$个欲查询的数，就能直接通过<code>hashTable</code>数组判断出每个数是否出现过，这种做法的时间复杂度为$O(N+M)$。<strong>直接把输入的数作为数组的下标</strong>来对这个数的性质进行统计的方法<strong>非常实用，务必掌握</strong>。</p><p>但是这个方法有一个问题：如果<strong>输入的整数可能是$10^9$大小</strong>，甚至是<strong>字符串</strong>，就<strong>不能将其直接作为数组下标</strong>了。因此我们寻找一种做法，<strong>将元素通过一个函数转换为一个在能接受范围内的整数，使得该整数尽可能唯一地代表这个元素</strong>。这样的方法称为<strong>散列(hash)</strong>，用于转换的函数称为<strong>散列函数H</strong>，也就是说，如果元素在转换前为<code>key</code>，那么转换后就是一个整数<code>H(key)</code>。</p><h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><p>对<code>key</code>是<strong>整数</strong>的情况来说，常用的<strong>散列函数</strong>有：</p><ol><li><p><strong>直接定址法</strong></p><ul><li><p>恒等变换，即 <code>H(key) = key</code></p></li><li><p>线性变换，即 <code>H(key) =  a * key + b</code></p></li></ul></li><li><p><strong>除留余数法</strong></p><p>把<code>key</code><strong>除以一个数<code>mod</code>得到的余数</strong>作为 <code>hash</code>值 的方法，即 <code>H(key) = key % mod</code></p><p>通过这个散列函数，可以把很大的数转换为不超过 mod 的整数，这样就可以将它作为可用的数组下标。显然，当<code>mod</code>是一个<strong>素数</strong>时，<code>H(key)</code><strong>能尽可能覆盖<code>[0,mod]</code>范围内的每一个数</strong>。</p></li><li><p>平方取中法(<strong>很少用</strong>)</p><p>取<code>key</code>的<strong>平方的中间若干位</strong>作为hash值</p></li></ol><hr><h5 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h5><p>当两个不同的数<code>key1</code>和<code>key2</code>他们的hash值相同时，这样的情况称为<strong>冲突</strong>。<strong>解决冲突的常用方法：</strong></p><ol><li><p><strong>开放定址法(获取新的hash值)</strong></p><ul><li><p><strong>线性探查法 (Linear Probing)</strong></p><p>当表中下标为<code>H(key)</code>的位置已经被其他元素占用，则<strong>检查下一个位置<code>H(key)+1</code></strong>，以此类推。<strong>如果检查过程中超过了表长<code>m</code>，那么就回到表的首位继续循环</strong>，直到找到一个可用的位置，或是所有位置都已经被使用。</p><p><code>H = (H(key) + i) % m</code>；<strong>(i = 0, 1, 2, …, m-1)</strong></p><p><strong>缺点</strong>：容易导致<strong>大量元素在相邻的散列地址上“聚集”(堆积)，大大降低查找效率</strong>。</p></li><li><p><strong>平方探查法 (Quadratic Probing)</strong></p><p>当表中下标为<code>H(key)</code>的位置已经被其他元素占用，则按如下顺序检查表中位置</p><p><code>H = (H(key) + i) % m</code>；i = $0, 1^2, -1^2, 2^2, -2^2, …, k^2, -k^2;(k \leq m/2)$</p><p>可<strong>避免聚集</strong>问题。</p><p>缺点：<strong>不能探测到散列表上所有单元</strong>(但至少能探测到一半单元)。</p></li><li><p><strong>再散列法(双散列法)</strong></p><p><code>H = (H1(key) + i * H2(key)) % m</code>；<strong>i 是冲突次数</strong></p></li></ul></li><li><p><strong>链地址法 (拉链法)</strong></p><p>不计算新的hash值，而是把 <strong>所有H(key)相同的key</strong>(称为<strong>同义词</strong>) <strong>存储在一个线性链表中</strong>，由散列地址唯一标识。</p></li></ol><hr><p>一般来说，可以使用<strong>标准库模板库中的<code>map</code></strong>来直接使用hash的功能（C++11以后可以用 <code>unordered_map</code>，<strong>速度更快</strong>），因此除非必须模拟这些方法或是对算法的效率要求比较高，一般不需要自己实现上面解决冲突的方法。</p><hr><h4 id="3-2-2-字符串hash初步"><a href="#3-2-2-字符串hash初步" class="headerlink" title="3.2.2 字符串hash初步"></a>3.2.2 字符串hash初步</h4><p>如果<strong><code>key</code>不是整数</strong>，应该如何设计散列函数？</p><blockquote><p>例题：</p><p>如何将一个二维整点$P$的坐标映射为一个整数，使得整点$P$可以由该整数唯一标识？</p></blockquote><p>假设一个整点$P$的坐标是$(x,y)$，其中$0\leq x,y\leq Range$，那么可以令<code>hash</code>函数为<code>H(P) = x * Range + y</code>，这样对数据范围内的任意两个整点$P1$与$P2$，<code>H(P1)</code>都不会等于<code>H(P2)</code>，就可以用<code>H(P)</code>来唯一地标识该整点P，<strong>接着</strong>便可以<strong>通过整数hash的方法进一步映射到较小的范围</strong>。</p><p>字符串hash是指<strong>将一个字符串S映射为一个整数</strong>，使得该整数可以尽可能唯一地代表字符串S。</p><p>为了讨论问题方便，<strong>假设字符串均由大写字母A~Z构成</strong>，不妨把 A~Z 视为 0~25。接着按照<strong>26进制转换为10进制</strong>的思路，实现将字符串映射为整数的需求(转换成的整数最大为$26^{len}-1$，len为字符串长度)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span> </span>&#123; <span class="comment">//将字符串S转换为整数</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>); <span class="comment">//将26进制转换为10进制</span></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免转换成的整数过大，需要注意 字符串长度len 不能太长。如果字符串中<strong>还有小写字母，可以把 A~Z 作为 0~25，把 a~z 作为 26~51</strong>，这样就变成了<strong>52进制转换为10进制</strong>的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0l</span> i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(S[i])) &#123;</span><br><span class="line">            id = id * <span class="number">52</span> + (S[i] - <span class="string">'A'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">islower</span>(S[i])) &#123;</span><br><span class="line">            id = id * <span class="number">52</span> + (S[i] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果字符中还有数字，一般有两种处理方法：</p><ol><li><p>按照小写字母的处理方法，<strong>增大进制数至62</strong>。</p></li><li><p>如果保证在字符串的<strong>末尾是个确定的数字</strong>，就可以把前面英文字母的部分按上面的思路转换成整数，再<strong>将末尾的数字直接拼接上去</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>);</span><br><span class="line">   id = id * <span class="number">10</span> + (S[len - <span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>例题：</p><p>给出N个字符串(由三位大写字母组成)，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span> </span>&#123; <span class="comment">//将字符串S转换为整数</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>); <span class="comment">//将26进制转换为10进制</span></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="keyword">int</span> hashTable[<span class="number">26</span> * <span class="number">26</span> * <span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">string</span> S[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; S[i];</span><br><span class="line">        <span class="keyword">int</span> id = hashFunc(S[i], <span class="number">3</span>);</span><br><span class="line">        hashTable[id]++; <span class="comment">//字符串出现的次数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> id = hashFunc(tmp, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; hashTable[id] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出字符串出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-3-相关习题"><a href="#3-2-3-相关习题" class="headerlink" title="3.2.3 相关习题"></a>3.2.3 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1005</strong> <strong>继续(3n+1)猜想</strong></td><td>奇数在判断过程中，可能大小会超过100</td></tr><tr><td><strong>B1029</strong> <strong>旧键盘</strong><br><strong>A1084</strong> <strong>Broken Keyboard</strong></td><td>待优化</td></tr><tr><td><strong>B1033</strong> <strong>旧键盘打字</strong></td><td><strong>不能用<code>scanf</code>或<code>cin</code>读取字符串</strong>，应采用<code>gets(str)</code>或<code>getline(cin, str)</code>，因为题目<strong>只保证第 2 行输入的文字串非空</strong></td></tr><tr><td><strong>B1038</strong> <strong>统计同成绩学生</strong></td><td>\</td></tr><tr><td><strong>B1039</strong> <strong>到底买不买</strong><br><strong>A1092</strong> <strong>To Buy or Not to Buy</strong></td><td>\</td></tr><tr><td><strong>B1042</strong> <strong>字符统计</strong></td><td>\</td></tr><tr><td><strong>B1043</strong> <strong>输出PATest</strong></td><td>\</td></tr><tr><td><strong>B1047</strong> <strong>编程团体赛</strong></td><td>\</td></tr><tr><td>A1041</td><td></td></tr><tr><td>A1050</td><td></td></tr><tr><td>A1048</td></tr></tbody></table><hr><h3 id="3-3-递归"><a href="#3-3-递归" class="headerlink" title="3.3 递归"></a>3.3 递归</h3><h4 id="3-3-1-分治"><a href="#3-3-1-分治" class="headerlink" title="3.3.1 分治"></a>3.3.1 分治</h4><p><strong>分治(divide and conquer)</strong>的全称为“<strong>分而治之</strong>”。分治法<strong>将原问题划分成若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解</strong>。分治法的三个步骤：</p><ol><li>分解：将原问题分解为若干和原问题拥有相同或相似结构的子问题。</li><li>解决：递归求解所有子问题。如果存在子问题的规模小到可以直接解决，就直接解决它。</li><li>合并：将子问题的解合并为原问题的解。</li></ol><p>分治法<strong>分解出的子问题</strong>应当是<strong>相互独立、没有交叉</strong>的。如果存在两个子问题有相交部分，就不应该使用分治法解决。分治法作为一种算法思想，<strong>既可以使用递归的手段实现，也可以通过非递归的手段实现</strong>。一般来说，<strong>使用 递归 实现较为容易</strong>。</p><hr><h4 id="3-3-2-递归"><a href="#3-3-2-递归" class="headerlink" title="3.3.2 递归"></a>3.3.2 递归</h4><p>递归很适合用来<strong>实现分治思想</strong>。</p><p>递归的逻辑中一般有两个重要概念：</p><ol><li><strong>递归边界</strong></li><li><strong>递归调用</strong></li></ol><p>其中<strong>递归调用</strong>是将原问题<strong>分解为若干个子问题</strong>的手段，而<strong>递归边界</strong>则是<strong>分解的尽头</strong>。递归的代码结构中一定存在这两个该概念，<strong>它们支撑起了整个递归最关键的逻辑</strong>。</p><blockquote><p>经典例子1：使用递归求解n的阶乘</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * F(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; F(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经典例子2：求 Fibonacci 数列的第n项</p><p>Fibonacci 数列(即斐波那契数列) 是满足 F(0) = 1, F(1) = 1, F(n) = F(n-1) + F(n-2) (n $\geq$ 2) 的数列，数列的前几项为 1, 1, 2, 3, 5, 8, 13, 21, … 。</p></blockquote><p>从定义中可以获知<strong>递归边界为 F(0) = 1 和 F(1) = 1</strong>，且递归调用为 F(n) = F(n-1) + F(n-2)  (n $\geq$ 2) ，因此可以仿照求解n的阶乘的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) &#123; <span class="comment">//递归边界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> F(n<span class="number">-1</span>) + F(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; F(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来看<strong>全排列(Full Permutation)</strong>。全排列指<strong>n个整数能形成的 所有排列</strong>。</p><p>现在需要按字典序从小到大的顺序输出$1\sim n$的全排列，其中$(a_1, a_2, …, a_n)$的字典序小于$(b_1, b_2, …, b_n)$是指存在一个$i$，使得$a_1=b_1$、$a_2 = b_2$、…、$a_{i-1} = b_{i-1}$、$a_i &lt; b_i$成立。</p><p>从递归的角度考虑，就可以分为若干个子问题：“输出以1开头的全排列”、“输出以2开头的全排列” … “输出以n开头的全排列”。<strong>不妨设定一个数组<code>P</code></strong>，用来存放当前的排列；再设定一个<strong>散列数组<code>hashTable</code></strong>，其中<code>hashTable[x]</code>，当整数<code>x</code>已经在数组<code>P</code>中时，为<code>1</code>。</p><p>按顺序往<code>P</code>的第1位到第n位中填入数字。<strong>不妨假设当前已经填好了<code>P[1] ~ P[index-1]</code>，正准备填<code>P[index]</code></strong>。显然需要枚举 1 ~ n，如果当前枚举的数字<code>x</code>还没有在<code>P[1] ~ P[index-1]</code>中(即<code>hashTable[x] == 0</code>)，那么就把它填入<code>P[index]</code>，同时将<code>hashTable[x]</code>置为<code>1</code>，然后去处理<code>P</code>的第<code>index + 1</code>位(<strong>即进行递归</strong>)；<strong>当递归完成时，再将<code>hashTable[x]</code>还原为<code>0</code>，以便让<code>P[index]</code>填下一个数字</strong>。</p><p>那么<strong>递归边界</strong>是什么呢？显然，当<code>index</code>达到<code>n + 1</code>时，说明<code>P</code>的的第<code>1 ~ n</code>位都已经填好了，此时可以把数组P输出，表示生成了一个排列，然后直接<code>return</code>即可。下面给出<code>n = 3</code>时的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>) &#123; <span class="comment">//递归边界，已经处理完排列的 1~n 位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; P[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123; <span class="comment">//枚举 1~n，试图将 x 填入 P[index]</span></span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="number">0</span>) &#123; <span class="comment">//如果 x 不在 P[1] ~ P[index - 1] 中</span></span><br><span class="line">            P[index] = x; <span class="comment">//令 P 的第 index 位为 x，即把x加如当前排列</span></span><br><span class="line">            hashTable[x] = <span class="number">1</span>; <span class="comment">//记 x 已在 P 中</span></span><br><span class="line">            generateP(index + <span class="number">1</span>, n); <span class="comment">//处理排列的第 index + 1 号位</span></span><br><span class="line">            hashTable[x] = <span class="number">0</span>; <span class="comment">//已处理完 P[index] 为 x 的子问题，还原状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>, P[<span class="number">11</span>], hashTable[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">generateP(<span class="number">1</span>); <span class="comment">//从P[1]开始填</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后的最后</strong>来看<strong>$n$皇后问题</strong>。$n$皇后问题是指在一个$n*n$的国际象棋棋盘上放置$n$个皇后，使得这$n$个皇后<strong>两两均不在同一行、同一列、同一条对角线上</strong>，求合法的方案数。</p><p>对于这个问题，如果采用组合数的方式来枚举每一种情况(即从$n^2$个位置中选择$n$个位置)，那么需要$C_{n\times n}^n$的枚举量。但是<strong>换个思路，考虑到每行只能放置一个皇后、每列也只能放置一个皇后，如果把n列皇后所在的行号依次写出，那么就会是$1 \sim n$的一个排列</strong>。于是只需要枚举$1 \sim n$的所有排列，查看每个排列对应的放置方案是否合法，统计其中合法的方案即可。</p><p>于是可以<strong>在全排列的代码基础上进行求解</strong>。由于当达到递归边界时表示生成了一个排列，所以<strong>需要在起内部判断是否为合法方案</strong>，即<strong>遍历每两个皇后</strong>，判断它们<strong>是否在同一条对角线上</strong>(显然不在同一行和同一列)，若不是，则累计计数变量<code>cnt</code>即可。主要代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>) &#123; <span class="comment">//递归边界，生成一个排列</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//flag为true表示当前排列为一个合法方案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//遍历任意两个皇后</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(i - j) == <span class="built_in">abs</span>(P[i] - P[j])) <span class="comment">//如果在一条对角线上</span></span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="comment">//当前方案合法</span></span><br><span class="line">            cnt++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="number">0</span>) &#123;</span><br><span class="line">            P[index] = x;</span><br><span class="line">            hashTable[x] = <span class="number">1</span>;</span><br><span class="line">            generateP(index + <span class="number">1</span>);</span><br><span class="line">            hashTable[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种<strong>枚举所有情况，然后判断每一种情况是否合法的朴素做法</strong>称为<strong>暴力法</strong>。</p><p>通过思考可以发现，当已经放置了一部分皇后时，<strong>可能剩余的皇后无论怎样放置都不可能合法，就不需要继续递归，直接返回上层即可</strong>。这种做法称为<strong>回溯法</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>) &#123; <span class="comment">//递归边界，生成一个 合法方案</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123; <span class="comment">//第 x 行</span></span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="number">0</span>) &#123; <span class="comment">//第 x 行还没有皇后</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//flag 为 1 表示当前皇后不会和之前的皇后冲突</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt; index; pre++) &#123; <span class="comment">//遍历之前的皇后</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(x - P[pre])) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>; <span class="comment">//与之前的皇后在一条对角线冲突</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//如果可以把皇后放在第 x 行</span></span><br><span class="line">                P[index] = x; <span class="comment">//令第 index 列皇后的行号为 x</span></span><br><span class="line">                hashTable[x] = <span class="number">1</span>; <span class="comment">//第 x 行已被占用</span></span><br><span class="line">                generateP(index + <span class="number">1</span>); <span class="comment">//递归处理第 index + 1 行皇后</span></span><br><span class="line">                hashTable[x] = <span class="number">0</span>; <span class="comment">//递归完毕，还原第 x 行 为 为占用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-4-贪心"><a href="#3-4-贪心" class="headerlink" title="3.4 贪心"></a>3.4 贪心</h3><h4 id="3-4-1-简单贪心"><a href="#3-4-1-简单贪心" class="headerlink" title="3.4.1 简单贪心"></a>3.4.1 简单贪心</h4><p>贪心法是<strong>求解一类最优化问题</strong>的方法，它总是考虑在当前状态下<strong>局部最优(或较优)</strong>的策略，来<strong>使全局的结果达到最优(或较优)</strong>。要获得<strong>最优</strong>结果，要求中间的每步策略都是最优的，因此<strong>严谨使用</strong>贪心法来求解最优化问题<strong>需要对采取的策略进行证明</strong>。证明的一般思路是使用<strong>反证法及数学归纳法</strong>，即假设策略不能导致最优解，然后通过一系列推导来得到矛盾，以此证明策略是最优的，最后用数学归纳法保证全局最优。不过对平常使用来说，也许没有时间或不太容易对想到的策略进行严谨的证明(<strong>贪心的证明往往比贪心本身更难</strong>)，因此一般来说，<strong>如果在想到某个似乎可行的策略，并且自己无法举出反例，那么就勇敢的实现它</strong>。</p><hr><h4 id="3-4-2-区间贪心"><a href="#3-4-2-区间贪心" class="headerlink" title="3.4.2 区间贪心"></a>3.4.2 区间贪心</h4><p><strong>区间不相交问题</strong>：给出$N$个开区间$(x, y)$，从中选择尽可能多的开区间，使得这些开区间两两没有交集。例如对开区间$(1, 3)$、$(2,4)$、$(3, 5)$、$(6, 7)$来说，可以选出最多三个区间$(1, 3)$、$(3, 5)$、$(6, 7)$，它们互相没有交集。</p><p>首先考虑最简单的情况，如果开区间$I_1$被开区间$I_2$包含(如图4-5a所示)，则选择$I_1$是最好的选择，因为这样就<strong>有更大的空间去容纳其他开区间</strong>。</p><p>接下来<strong>把所有开区间按左端点$x$从大到小排序</strong>，如果去掉区间包含的情况，那么一定有$y_1 &gt; y_2 &gt; … &gt; y_n$成立(如图4-5b所示)。观察发现，$I_1$右边有一段一定不会和其他区间重叠，如果把它去掉，那么$I_1$的左边剩余部分就会被$I_2$包含，由图4-5a的情况可知，应当选择$I_1$。因此对这种情况，<strong>总是先选择 左端点最大 的区间</strong>。值得注意的是，<strong>总是先选择右端点最小的区间</strong>的策略也是可行的。</p><p><img src="https://i.loli.net/2020/03/07/KlvHnuEwTJkcVsP.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inteval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="comment">//开区间左右端点</span></span><br><span class="line">&#125; I[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Inteval a, Inteval b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) &#123; <span class="comment">//先按左端点从大到小排序</span></span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x; </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//左端点相同的 按右端点从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n, n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; I[i].x &gt;&gt; I[i].y;</span><br><span class="line">    sort(I, I + n, cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, lastX = I[<span class="number">0</span>].x; <span class="comment">//记录不相交区间的个数，上一个被选中区间的左端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(I[i].y &lt;= lastX) &#123; <span class="comment">//如果该区间右端点在 lastX 左边</span></span><br><span class="line">            lastX = I[i].x; <span class="comment">//以 I[i] 作为新选中的区间</span></span><br><span class="line">            cnt++; <span class="comment">//不相交区间个数加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与这个问题类似的是<strong>区间选点问题：给出$N$个闭区间$[x, y]$，求最少需要确定多少个点，才能使每个闭区间中都至少存在一个点</strong>。例如对闭区间$[1,4]$、$[2, 6]$、$[5, 7]$来说，需要两个点(例如3、5)才能保证每个闭区间内都有至少一个点。</p><p>事实上，这个问题和区间不相交问题的策略是一致的。首先，回到图4-5a，如果闭区间$I_1$被闭区间$I_2$包含，那么在$I_1$中取点可以保证这个点一定在$I_2$内。接着<strong>把所有区间按左端点从大到小排序，去除掉区间包含的情况</strong>，就可以得到图4-5b。由于每个闭区间中都需要存在一个点，因此<strong>对左端点最大的区间$I_1$来说，取左端点就能让它尽可能多地覆盖其他区间</strong>。区间选点问题的代码只需要把区间不想交问题代码中的<code>I[i].y &lt;= lastX</code>改为<code>I[i].y &lt; lastX</code>即可。</p><p>总的来说，不是所有问题都适合使用贪心法，但是这并不妨碍贪心算法称为一个简洁、实用、高效的算法。</p><hr><h4 id="3-4-3-相关习题"><a href="#3-4-3-相关习题" class="headerlink" title="3.4.3 相关习题"></a>3.4.3 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1020</strong> <strong>月饼</strong><br><strong>A1070</strong> <strong>Mooncake</strong></td><td>库存量和售价都应该定义为double类型</td></tr><tr><td><strong>B1023</strong> <strong>组个最小数</strong></td><td>\</td></tr><tr><td><strong>A1033</strong> <strong>To Fill or Not to Fill</strong></td><td><strong>能到达的距离</strong>内，<strong>由近到远遍历</strong>，有三种情况：<br><br>1. 最近距离的加油站都到不了<br>2. 出现油价比目前低的加油站，就直接去<br>    2.1 <strong>油不够</strong>，只加能刚好到达的油量<br>    2.2 <strong>不用加油</strong><br>3. 没有更低价的加油站，就<strong>加满油(能尽量少加更贵的油)</strong>，去<strong>价格相对 最低</strong>的加油站</td></tr><tr><td>A1037</td><td></td></tr><tr><td>A1038</td><td></td></tr><tr><td>A1067</td></tr></tbody></table><hr><h3 id="3-5-二分"><a href="#3-5-二分" class="headerlink" title="3.5 二分"></a>3.5 二分</h3><h4 id="3-5-1-二分查找"><a href="#3-5-1-二分查找" class="headerlink" title="3.5.1 二分查找"></a>3.5.1 二分查找</h4><p>二分查找的<strong>高效之处</strong>在于，<strong>每一步都可以去除当前区间中的一半元素</strong>，因此其时间复杂度是$O(\log n)$，这是十分优秀的。</p><p>在严格<strong>递增</strong>序列中查找给定的数$x$的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; x) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[n] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, binarySearch(A, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">6</span>), binarySearch(A, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果过二分<strong>上界超过<code>int</code>型数据范围的一半</strong>，当欲查询元素在序列较靠后位置时，语句<code>mid = (left + right) / 2</code>中的<code>left + right</code>就<strong>有可能超过int而导致溢出</strong>，通常<strong>使用等价语句<code>mid = left + (right - left) / 2</code>作为代替</strong>，以避免溢出。另外，二分法可以<strong>使用递归</strong>进行实现，但在程序设计时，<strong>更多采用非递归的写法</strong>。</p><p>接下来探讨更进一步的问题：如果递增序列$A$中的<strong>元素可能重复</strong>，那么如何对给定的欲查询元素$x$，<strong>求出序列中第一个$\geq x$的元素位置$L$以及第一个$&gt;x$的元素的位置$R$</strong>，这样元素$x$在序列中的存在区间就是$[L, R)$。</p><p>例如对下标从0开始、有5个元素的序列${1,3,3,3,6}$来说，如果要查询3，则应当得到$L = 1$、$R = 4$；如果查询 5，则应当得到$L = R = 4$。<strong>如果序列中没有$x$，$L$和$R$也可以理解为 假设序列中存在$x$，则$x$应当在的位置</strong>。</p><p>先来考虑第一个小问：求序列中的第一个$\geq x$的元素位置。</p><ol><li>若<code>A[mid] &gt;= x</code>，说明第一个$\geq x$的元素的位置一定在<strong><code>mid</code>处或<code>mid</code>的左侧，应往左子区间[left, mid]继续查询，即令<code>right = mid</code></strong></li><li>若<code>A[mid] &lt; x</code>，说明第一个$\geq x$的元素的位置一定在<strong><code>mid</code>右侧，应往右子区间[mid+1, right]继续查询，即令<code>left = mid + 1</code></strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt;= x) &#123; <span class="comment">//中间值 &gt;= x</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//中间值 &lt; x</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">//返回夹出来的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码有两个需要注意的地方：</p><ol><li>循环条件为<code>left &lt; right</code>，而不是之前的<code>left &lt;= right</code>，这是由问题本身决定的。因为<strong>如果想要返回第一个<code>&gt;= x</code>的元素的位置，就不需要判断元素<code>x</code>本身是否存在</strong>。</li><li>二分的<strong>初始区间</strong>应当能<strong>覆盖到所有可能返回的结果</strong>，考虑到欲查询元素可能比序列中所有元素都大，此时应当返回n，因此<strong>二分上界是n</strong>，故二分的初始区间为<code>[left, right] = [0, n]</code>。</li></ol><p>接下来解决第二小问：求序列中第一个大于x的元素的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, itn right, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt; x) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">//返回夹出来的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lower_bound</code>和<code>upper_bound</code>函数都在解决这样一个问题：<strong>寻找有序序列中第一个满足某条件的元素的位置</strong>。这是一个非常重要且经典的问题，平时能碰到的大部分二分法问题都可以归结于这个问题。</p><hr><h4 id="3-5-2-二分法拓展"><a href="#3-5-2-二分法拓展" class="headerlink" title="3.5.2 二分法拓展"></a>3.5.2 二分法拓展</h4><p>首先介绍如何计算$\sqrt2$的<strong>近似值</strong>。</p><p>对$f(x) = x^2$来说，在$x \in [1, 2]$范围内，$f(x)$随着$x$的增大而增大，<strong>这就给使用二分法创造了条件</strong>。</p><p><strong>以精确到$10^{-5}$为例</strong>，令浮点型<code>left</code>和<code>right</code>的<strong>初值分别是 1 和 2</strong>，然后根据中点<code>mid</code>处$f(x)$的值与 2 的大小来选择子区间进行逼近：</p><ol><li>若<code>f(mid) &gt; 2</code>，说明<code>mid</code> &gt; $\sqrt2$，令<code>right = mid</code></li><li>若<code>f(mid) &lt; 2</code>，说明<code>mid</code> &lt; $\sqrt2$，令<code>left = mid</code></li></ol><p>上面两个步骤当<code>right - left</code> &lt; $10^{-5}$时结束，显然<strong>当<code>left</code>与<code>right</code>的距离 &lt; $10^{-5}$ 时已满足精度要求</strong>，<code>mid</code>即为所求的近似值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>; <span class="comment">//精度为 10^&#123;-5&#125;，科学计数法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calSqrt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> left = <span class="number">1</span>, right = <span class="number">2</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; eps) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &gt; <span class="number">2</span>) &#123; <span class="comment">//即 mid &gt; sqrt(2)</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，计算$\sqrt2$的近似值的问题是这样一个问题的特例：<strong>给定一个定义在$[L, R]$上的单调函数$f(x)$，求方程<code>f(x) = 0</code>的根</strong>。</p><p>同样假设精度要求为<code>eps</code> = $10^{-5}$，函数$f(x)$在$[L,R]$上递增，<strong>令<code>left</code>与<code>right</code>的初值分别为$L$、$R$</strong>。根据<strong>中点<code>mid</code>的函数值<code>f(mid)</code> 与 0 的大小关系</strong>来判断往哪个子区间继续逼近<code>f(x) = 0</code>的根：</p><ol><li>若<code>f(mid) &gt; 0</code>，说明<code>f(x) = 0</code>的根在<code>mid</code>左侧，应往左子区间继续逼近，即令<code>right = mid</code></li><li>若<code>f(mid) &lt; 0</code>，说明<code>f(x) = 0</code>的根在<code>mid</code>右侧，应往右子区间继续逼近，即令<code>left = mid</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>; <span class="comment">//精度为 10^&#123;-5&#125;，科学计数法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> left = L, right = R, mid;</span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; eps) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid; <span class="comment">//f(x) = 0 的根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-5-3-快速幂"><a href="#3-5-3-快速幂" class="headerlink" title="3.5.3 快速幂"></a>3.5.3 快速幂</h4><h4 id="3-5-4-相关习题"><a href="#3-5-4-相关习题" class="headerlink" title="3.5.4 相关习题"></a>3.5.4 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1010</strong> <strong>Radix</strong></td><td>1. <strong>基数上界为 已确认数字的十进制大小 + 1 与 下界中的较大值（确保不会出现多个解(而且基数不确定的数，只有一位数的时候才可能多个解) )</strong><br>2. 基数过大时，数值转换为十进制会发生<strong>上溢，存储结果为负数</strong></td></tr><tr><td>A1044</td><td></td></tr><tr><td>A1048</td></tr></tbody></table><hr><h3 id="3-6-tow-pointers"><a href="#3-6-tow-pointers" class="headerlink" title="3.6 tow pointers"></a>3.6 tow pointers</h3><h4 id="3-6-1-什么是two-pointers"><a href="#3-6-1-什么是two-pointers" class="headerlink" title="3.6.1 什么是two pointers"></a>3.6.1 什么是two pointers</h4><h4 id="3-6-2-归并排序"><a href="#3-6-2-归并排序" class="headerlink" title="3.6.2 归并排序"></a>3.6.2 归并排序</h4><h4 id="3-6-3-快速排序"><a href="#3-6-3-快速排序" class="headerlink" title="3.6.3 快速排序"></a>3.6.3 快速排序</h4><h4 id="3-6-4-相关习题"><a href="#3-6-4-相关习题" class="headerlink" title="3.6.4 相关习题"></a>3.6.4 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1030</strong> <strong>完美数列</strong><br><strong>A1085</strong> <strong>Perfect Sequence</strong></td><td>\</td></tr><tr><td><strong>B1035</strong> <strong>插入与归并</strong><br><strong>A1089</strong> <strong>Insert or Merge</strong></td><td>1. 插入排序：<strong>未排序部分和初始序列一定相同</strong><br> 2. 归并排序：<strong>末尾不足数量的子序列同样需要排序</strong><br> 3. <strong>插入排序 更容易判断，将其作为判断排序类型的切入点</strong><br>4. 插入和归并排序的<strong>实际操作由排序函数<code>sort</code>/<code>qsort</code></strong>代替</td></tr><tr><td>A1029</td><td></td></tr><tr><td>A1048</td></tr></tbody></table><hr><h3 id="3-7-其他高效技巧与算法"><a href="#3-7-其他高效技巧与算法" class="headerlink" title="3.7 其他高效技巧与算法"></a>3.7 其他高效技巧与算法</h3><h4 id="3-7-1-打表"><a href="#3-7-1-打表" class="headerlink" title="3.7.1 打表"></a>3.7.1 打表</h4><h4 id="3-7-2-活用递推"><a href="#3-7-2-活用递推" class="headerlink" title="3.7.2 活用递推"></a>3.7.2 活用递推</h4><h4 id="3-7-3-随机选择法"><a href="#3-7-3-随机选择法" class="headerlink" title="3.7.3 随机选择法"></a>3.7.3 随机选择法</h4><h4 id="3-7-4-相关习题"><a href="#3-7-4-相关习题" class="headerlink" title="3.7.4 相关习题"></a>3.7.4 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1040</strong> <strong>有几个PAT</strong><br><strong>A1093</strong> <strong>Count PAT’s</strong></td><td>1. A前有P，后有T才能形成PAT；<br>2. 当前A能构成的PAT数量 = 之前P的数量 * 之后T的数量<br>3. 突破口：<strong>先遍历一遍，获取T的数量</strong></td></tr><tr><td><strong>B1045</strong> <strong>快速排序</strong><br><strong>A1101</strong> <strong>Quick Sort</strong></td><td>1. <strong>可能的主元：左侧的最大值比自身小；右侧的最小值比自身大</strong><br>2. <strong>输出即使没有主元，也得换行</strong></td></tr></tbody></table><hr><h2 id="4-数学问题"><a href="#4-数学问题" class="headerlink" title="4.  数学问题"></a>4.  数学问题</h2><h3 id="4-1-简单数学"><a href="#4-1-简单数学" class="headerlink" title="4.1 简单数学"></a>4.1 简单数学</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1003</td><td></td></tr><tr><td>B1019<br>A1069</td><td></td></tr><tr><td>B1049<br>A1104</td><td></td></tr><tr><td>A1008</td><td></td></tr><tr><td>A1049</td></tr></tbody></table><hr><h3 id="4-2-最大公约数与最小公倍数"><a href="#4-2-最大公约数与最小公倍数" class="headerlink" title="4.2 最大公约数与最小公倍数"></a>4.2 最大公约数与最小公倍数</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1008</td></tr></tbody></table><hr><h3 id="4-3-分数的四则运算"><a href="#4-3-分数的四则运算" class="headerlink" title="4.3 分数的四则运算"></a>4.3 分数的四则运算</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1034<br>A1088</td><td></td></tr><tr><td>A1081</td></tr></tbody></table><hr><h3 id="4-4-素数"><a href="#4-4-素数" class="headerlink" title="4.4 素数"></a>4.4 素数</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1007</td><td></td></tr><tr><td>B1013</td><td></td></tr><tr><td>A1015</td><td></td></tr><tr><td>A1078</td></tr></tbody></table><hr><h3 id="4-5-质因子分解"><a href="#4-5-质因子分解" class="headerlink" title="4.5 质因子分解"></a>4.5 质因子分解</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1059</td><td></td></tr><tr><td>A1096</td></tr></tbody></table><hr><h3 id="4-6-大整数运算"><a href="#4-6-大整数运算" class="headerlink" title="4.6 大整数运算"></a>4.6 大整数运算</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1023</td><td></td></tr><tr><td>A1024</td></tr></tbody></table><hr><h3 id="4-7-扩展欧几里得算法"><a href="#4-7-扩展欧几里得算法" class="headerlink" title="4.7 扩展欧几里得算法"></a>4.7 扩展欧几里得算法</h3><h3 id="4-8-组合数"><a href="#4-8-组合数" class="headerlink" title="4.8 组合数"></a>4.8 组合数</h3><hr><h2 id="5-C-标准模板库介绍"><a href="#5-C-标准模板库介绍" class="headerlink" title="5. C++标准模板库介绍"></a>5. C++标准模板库介绍</h2><h3 id="5-1-vector"><a href="#5-1-vector" class="headerlink" title="5.1 vector"></a>5.1 vector</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1039</td><td></td></tr><tr><td>A1047</td></tr></tbody></table><hr><h3 id="5-2-set"><a href="#5-2-set" class="headerlink" title="5.2 set"></a>5.2 set</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1063</td></tr></tbody></table><hr><h3 id="5-3-string"><a href="#5-3-string" class="headerlink" title="5.3 string"></a>5.3 string</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1060</td></tr></tbody></table><hr><h3 id="5-4-map"><a href="#5-4-map" class="headerlink" title="5.4 map"></a>5.4 map</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1044<br>A1100</td><td></td></tr><tr><td>A1022</td><td></td></tr><tr><td>A1054</td><td></td></tr><tr><td>A1071</td></tr></tbody></table><hr><h3 id="5-5-queue"><a href="#5-5-queue" class="headerlink" title="5.5 queue"></a>5.5 queue</h3><h3 id="5-6-priority-queue"><a href="#5-6-priority-queue" class="headerlink" title="5.6 priority_queue"></a>5.6 priority_queue</h3><h3 id="5-7-stack"><a href="#5-7-stack" class="headerlink" title="5.7 stack"></a>5.7 stack</h3><h3 id="5-8-pair"><a href="#5-8-pair" class="headerlink" title="5.8 pair"></a>5.8 pair</h3><h3 id="5-9-algorithm"><a href="#5-9-algorithm" class="headerlink" title="5.9 algorithm"></a>5.9 algorithm</h3><hr><h2 id="6-数据结构专题1"><a href="#6-数据结构专题1" class="headerlink" title="6. 数据结构专题1"></a>6. 数据结构专题1</h2><h3 id="6-1-栈的应用"><a href="#6-1-栈的应用" class="headerlink" title="6.1 栈的应用"></a>6.1 栈的应用</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1051</strong> <strong>Pop Sequence</strong></td><td>1. 可能会发生<strong>堆栈溢出</strong><br>2. <strong>栈顶元素和当前需要出栈的元素相同时，出栈。该判断之前必须先判断栈是否不为空(否则会报错)</strong><br>3. 标记出栈序列中待出栈元素下标，最终<strong>标记只有超出序列下标，才可能是出栈序列</strong></td></tr></tbody></table><hr><h3 id="6-2-队列的应用"><a href="#6-2-队列的应用" class="headerlink" title="6.2 队列的应用"></a>6.2 队列的应用</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1056</strong> <strong>Mice and Rice</strong></td><td>1. 输入的第二行是按老鼠的序号给出的重量。<strong>第三行给出的是老鼠的序号，而不是按序号给出的比赛序号</strong><br>2. 用<strong>队列记录老鼠的序号</strong>(而不是记录老鼠的结构体，<strong>有利于减少内存的占用</strong>)，<strong>晋级的老鼠重新入队</strong><br>3. 最后的分组中，老鼠数量可能不足(利用&lt;cmath>中的<code>ceil</code>函数<strong>向上取整</strong>)</td></tr></tbody></table><hr><h3 id="6-3-链表处理"><a href="#6-3-链表处理" class="headerlink" title="6.3 链表处理"></a>6.3 链表处理</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1025</strong> <strong>反转链表</strong><br><strong>A1074</strong> <strong>Reversing Linked List</strong></td><td>1. 通过<strong>数组下标来表示地址</strong>，便于链接各个节点<br> 2. 可能<strong>存在无效结点</strong><br>3. <strong>只根据 链表顺序的地址 进行反转</strong>，有利于节约开销</td></tr><tr><td><strong>A1032</strong> <strong>Sharing</strong></td><td>\</td></tr><tr><td><strong>A1052</strong> <strong>Linked List Sorting</strong></td><td>存在<strong>无有效结点</strong>的情况</td></tr><tr><td>A1097</td></tr></tbody></table><hr><h2 id="7-搜索专题"><a href="#7-搜索专题" class="headerlink" title="7. 搜索专题"></a>7. 搜索专题</h2><h3 id="7-1-深度优先搜索DFS"><a href="#7-1-深度优先搜索DFS" class="headerlink" title="7.1 深度优先搜索DFS"></a>7.1 深度优先搜索DFS</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1103</strong> <strong>Integer Factorization</strong></td><td>1. 利用<code>vector</code>(<strong>可根据<code>size</code>函数确认符合要求的元素个数</strong>)，<strong>预先存储所有 ≤ N的 元素(整数的P次幂值)</strong><br>2. <strong>为了保证底数最大的序列被选中，从大到小遍历</strong><br>3. DFS函数的参数：<strong>当前</strong>元素下标，<strong>已选</strong>元素数量，<strong>已选</strong>元素之和，<strong>已选</strong>元素的底数之和<br>4. DFS函数的<strong>递归边界</strong>：已选元素数量为K且和为N<br>5. DFS函数的<strong>递归调用</strong>：<strong>选择当前元素和不选择当前元素</strong><br>6. <strong>剪枝</strong>：<strong>和超过N 或 已选元素数量超过K 或 遍历完底数序列</strong>时，不必再递归</td></tr></tbody></table><hr><h3 id="7-2-广度优先搜索BFS"><a href="#7-2-广度优先搜索BFS" class="headerlink" title="7.2 广度优先搜索BFS"></a>7.2 广度优先搜索BFS</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1091</strong> <strong>Acute Stroke</strong></td><td>1. <strong>设定相对当前位置的前后左右上下6个方向的增量</strong>，便于枚举<br>2. 设置数组<code>inq</code><strong>记录当前位置是否入过队</strong><br>3. <strong>越界、当前位置为0、已入过队的位置</strong>无需再判断。<br>4. 在BFS函数中，<strong>利用队列进行BFS</strong>，使用STL的<code>queue</code>，<code>push</code>函数只将所选元素的<strong>副本入队，后续对原元素的操作不改变队列中的副本</strong>。</td></tr></tbody></table><hr><h2 id="8-数据结构专题2"><a href="#8-数据结构专题2" class="headerlink" title="8. 数据结构专题2"></a>8. 数据结构专题2</h2><h3 id="8-1-树与交叉树"><a href="#8-1-树与交叉树" class="headerlink" title="8.1 树与交叉树"></a>8.1 树与交叉树</h3><h3 id="8-2-二叉树的遍历"><a href="#8-2-二叉树的遍历" class="headerlink" title="8.2 二叉树的遍历"></a>8.2 二叉树的遍历</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1020</strong> <strong>Tree Traversals</strong></td><td>\</td></tr><tr><td><strong>A1086</strong> <strong>Tree Traversals Again</strong></td><td><strong>先序</strong>序列相当于<strong>入栈</strong>次序；<strong>中序</strong>序列相当于<strong>出栈</strong>次序</td></tr><tr><td><strong>A1102</strong> <strong>Invert a Binary Tree</strong></td><td>1. 题目给的是<strong>结点编号</strong>的关系，故<strong>采用静态链表</strong>存储二叉树<br>2. 反转二叉树即<strong>每个结点的左右子树对换</strong>，选择<strong>后序</strong>遍历</td></tr></tbody></table><hr><h3 id="8-3-树的遍历"><a href="#8-3-树的遍历" class="headerlink" title="8.3 树的遍历"></a>8.3 树的遍历</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1004</strong> <strong>Counting Leaves</strong></td><td>1. 利用数组<strong>存储每层的叶结点个数</strong><br>2. 根据<strong>出队结点的层数，获取最大层数</strong>，遍历输出每层叶结点个数<br></td></tr><tr><td><strong>A1053</strong> <strong>Path of Equal Weight</strong></td><td>1. 输出的路径序列要求降序，因此<strong>在读入结点时</strong>就将孩子节点<strong>按权重降序</strong>排序，这样，之后遍历时得到的路径即为降序<br><br>2. 利用<code>vector</code>的<code>begin</code>和<code>end</code>函数获得<code>vector</code>的<strong>首元素地址</strong>和<strong>尾后地址</strong>，用于<code>sort</code>函数排序<br>3. 利用<code>vector</code>存储路径，在<strong>递归子结点之前</strong>，用<code>push_back</code>函数<strong>将子结点加入路径</strong>，递归<strong>回溯后</strong>，用<code>pop_back</code><strong>将先前加入的子结点移出路径</strong></td></tr><tr><td><strong>A1079</strong> <strong>Total Sales of Supply Chain</strong></td><td>1. <strong>静态写法</strong>表示树，即用数组下标指代结点<br>2. 结点的结构体中设有<strong>货物量</strong>变量，用来<strong>判断是否为零售商</strong>（本题采用了BFS；也可DFS）</td></tr><tr><td><strong>A1090</strong> <strong>Highest Price in Supply Chain</strong></td><td>由于<strong>不涉及结点的数据域</strong>，可以直接<strong>用<code>vector&lt;int&gt; child[maxn]</code>存放树</strong></td></tr><tr><td>A1094</td><td></td></tr><tr><td>A1106</td></tr></tbody></table><hr><h3 id="8-4-二叉查找树BST"><a href="#8-4-二叉查找树BST" class="headerlink" title="8.4 二叉查找树BST"></a>8.4 二叉查找树BST</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1043</strong> <strong>Is It a Binary Search Tree</strong></td><td>1. <strong>静态写法</strong>(<strong>变长数组</strong>)表示二叉树<br>2. 根据BST左子树所有结点的数据域 &lt; 根结点的数据域，右子树所有结点的数据域 <strong>≥</strong> 根结点的数据域(<strong>由输入样例得出大小关系</strong>，镜像则相反)，<strong>获取左右子树的边界，判断是否符合先序序列，若符合</strong>，则按照<strong>左右根的顺序递归，将符合的根结点存入<code>vector</code>(获取后序序列)</strong><br>3. <strong>若vecotr中元素数量 = 输入序列的元素数量(能顺利转换为BST的后序序列)，说明输入序列为先序序列</strong></td></tr><tr><td><strong>A1064</strong> <strong>Complete Binary Search Tree</strong></td><td>1. 输入的元素<strong>升序排序</strong>，即为二叉树的<strong>中序遍历序列</strong>。<br>2. <strong>静态写法</strong>(<strong>变长数组</strong>)按照<strong>层序存储</strong>完全二叉排序树<br>3. 对二叉树进行<strong>中序遍历</strong>，依次<strong>填入中序遍历序列的元素</strong>即可得到层序存储的二叉树。注意：中序遍历时，二叉树数组<strong>根结点的下标</strong>：<br>        <strong>若设为1</strong>，则左右孩子结点下标为<code>root * 2</code>和<code>root * 2 + 1</code>；<br>        <strong>若设为0</strong>，则左右孩子结点下标为<code>root * 2 + 1</code>和<code>root * 2 + 2</code><br>4. <strong>顺序输出</strong>二叉树数组元素即为<strong>层序遍历</strong>序列</td></tr><tr><td><strong>A1099</strong> <strong>Build A Binary Search Tree</strong></td><td><strong>静态写法</strong>表示树，解题方法和 A1064 基本一致</td></tr></tbody></table><hr><h3 id="8-5-平衡二叉树"><a href="#8-5-平衡二叉树" class="headerlink" title="8.5 平衡二叉树"></a>8.5 平衡二叉树</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1066</strong> <strong>Root of AVL Tree</strong></td><td>即写出<strong>平衡二叉树的代码模板</strong><br>1. <strong>新建结点的初始高度为1</strong><br>2. 获取树高时，注意<strong>递归到空结点</strong>时，<strong>返回0</strong><br>3. 插入结点，递归过程中从<strong>系统栈出栈后</strong>：<br>        1) 平衡因子为2时，<strong>树型可能为LR型或LL型</strong>，LR型需要先对当前结点的<strong>左子树</strong>进行<strong>右旋</strong>；之后，LR型和LL型<strong>都需要对当前结点进行右旋</strong><br>        2) 平衡因子为-2时，<strong>树型可能为RL型或RR型</strong>，RL型需要先对当前结点的<strong>右子树</strong>进行<strong>左旋</strong>；之后，RL型和RR型<strong>都需要对当前结点进行左旋</strong><br>4. 左旋和右旋过程中要<strong>及时更新树高</strong></td></tr></tbody></table><hr><h3 id="8-6-并查集"><a href="#8-6-并查集" class="headerlink" title="8.6 并查集"></a>8.6 并查集</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1107</strong> <strong>Social Clusters</strong></td><td>1. <strong>根据共同(包括潜在的→有共同爱好的人另外的爱好)爱好</strong>来确定潜在<strong>朋友的集合</strong>，利用<code>hobby[1001]</code><strong>记录 任意一个 拥有对应爱好的结点</strong>，<strong>便于合并操作</strong><br>2. 遍历各用户，<strong>根据根结点统计各集合的人数</strong><br>3. 将集合<strong>按包含人数降序</strong>排序，再<strong>遍历</strong>即可<strong>筛选统计出集合个数</strong><br>4. 路径压缩<strong>可选</strong></td></tr></tbody></table><hr><h3 id="8-7-堆"><a href="#8-7-堆" class="headerlink" title="8.7 堆"></a>8.7 堆</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1098</strong> <strong>Insertion or Heap Sort</strong></td><td>1. 用于<strong>表示树的数组</strong>，注意下标<strong>从 0或1 开始，孩子结点表示的区别</strong><br>2. 插入排序：<strong>未排序部分和初始序列一定相同</strong><br>3. 堆排序：<strong>后面的元素有序，前面无规律</strong><br>4. <strong>插入排序 更容易判断，将其作为判断排序类型的切入点</strong><br>4. <strong>插入排序</strong>的<strong>实际操作可由排序函数<code>sort</code></strong>实现<br><br>5. 要用堆排序得到<strong>递增序列</strong>，则需要建立<strong>大根堆</strong><br>6. 堆排序<strong>从后往前</strong>找到<strong>第一个 $&lt;$ 堆顶</strong>的元素，与堆顶元素交换，再<strong>对整个堆向下调整</strong></td></tr></tbody></table><hr><h3 id="8-8-哈夫曼树"><a href="#8-8-哈夫曼树" class="headerlink" title="8.8 哈夫曼树"></a>8.8 哈夫曼树</h3><hr><h2 id="9-图算法专题"><a href="#9-图算法专题" class="headerlink" title="9. 图算法专题"></a>9. 图算法专题</h2><h3 id="9-1-图的定义和相关术语"><a href="#9-1-图的定义和相关术语" class="headerlink" title="9.1 图的定义和相关术语"></a>9.1 图的定义和相关术语</h3><h3 id="9-2-图的存储"><a href="#9-2-图的存储" class="headerlink" title="9.2 图的存储"></a>9.2 图的存储</h3><h3 id="9-3-图的遍历"><a href="#9-3-图的遍历" class="headerlink" title="9.3 图的遍历"></a>9.3 图的遍历</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1013</strong> <strong>Battle Over Cities</strong></td><td>1. 问题等价于求 一个无向图<strong>去掉一个结点后，连通分量的数量</strong>，这种问题一般有两种方法：<strong>图的遍历</strong>和<strong>并查集</strong><br>2. <strong><code>cin</code>会超时，需要改为<code>scanf</code></strong>，邻接矩阵和邻接表都可存储图<br>3. <strong>每次输入被占领的城市之前，要重置城市的访问状态为未访问</strong><br>4. 将<strong>失去的城市标记为已访问</strong>，即可<strong>达到失去的效果(没有公路可以到达)</strong></td></tr><tr><td>A1021</td><td></td></tr><tr><td><strong>A1034</strong> <strong>Head of a Gang</strong></td><td>1. 相同人员之间可能<strong>多次通话</strong><br>2. <code>map&lt;type1, type2&gt;</code><strong>自动按<code>type1</code>从小到大输出</strong>，使用<code>map&lt;string, int&gt;</code>建立头目姓名与成员数量的关系，便于输出结果<br>3. 图中可能<strong>有环</strong>，为了<strong>边权不被漏加</strong>，需要<strong>先累加边权再递归</strong>；同时<strong>为了防止边权被重复计算</strong>，累加后<strong>删除这条边，以免走回头路、重复计算边权</strong></td></tr><tr><td><strong>A1076</strong> <strong>Forwards on Weibo</strong></td><td>1. 转发是<strong>粉丝转发博主</strong>的信息，因此要<strong>根据用户的关注情况</strong>建立<strong>从博主到粉丝(即反向)</strong>的<strong>有向图</strong><br>2. <strong>DFS</strong>记录访问过的结点数量<strong>比较麻烦</strong>，BFS比较方便<br>3. 可能形成环 ，必须控制<strong>每个用户只能转发一次</strong>(<strong>遍历时只能访问一次</strong>)</td></tr></tbody></table><hr><h3 id="9-4-最短路径"><a href="#9-4-最短路径" class="headerlink" title="9.4 最短路径"></a>9.4 最短路径</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1003</strong> <strong>Emergency</strong></td><td></td></tr><tr><td>A1018</td><td></td></tr><tr><td><strong>A1030</strong> <strong>Travel Plan</strong></td><td></td></tr><tr><td>A1072</td><td></td></tr><tr><td>A1087</td></tr></tbody></table><hr><h3 id="9-5-最小生成树"><a href="#9-5-最小生成树" class="headerlink" title="9.5 最小生成树"></a>9.5 最小生成树</h3><h3 id="9-6-拓扑排序"><a href="#9-6-拓扑排序" class="headerlink" title="9.6 拓扑排序"></a>9.6 拓扑排序</h3><h3 id="9-7-关键路径"><a href="#9-7-关键路径" class="headerlink" title="9.7 关键路径"></a>9.7 关键路径</h3><hr><h2 id="10-动态规划专题"><a href="#10-动态规划专题" class="headerlink" title="10. 动态规划专题"></a>10. 动态规划专题</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑盒测试</title>
      <link href="/2020/02/03/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/02/03/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对黑盒测试来说，<strong>所有输入数据都放在一个文件里</strong>。</p></blockquote><hr><h2 id="单点测试"><a href="#单点测试" class="headerlink" title="单点测试"></a>单点测试</h2><p>PAT试题基本为<strong>单点测试</strong>（即<strong>一次运行一组数据，一组数据通过测试则获得这组数据的分值</strong>）。</p><hr><h2 id="多点测试"><a href="#多点测试" class="headerlink" title="多点测试"></a>多点测试</h2><p>多点测试要求程序<strong>一次运行所有数据，并要求输出结果都正确，只要存在错误，即不得分</strong>。<br><strong>大部分 在线判题系统(Online Judge)  都采用了多点测试</strong>。<br>由于要求程序能运行所有数据，因此<strong>必须保证程序能反复执行代码的核心部分</strong>，这<strong>就要用到循环</strong>。</p><h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>题目一般有3中输入的格式，需要采用不同输入方式。</p><ol><li><strong><code>while··· EOF</code>型</strong></li></ol><p>题目<strong>没有给定输入的结束条件</strong>，则<strong>默认读取到文件末尾</strong>。</p><blockquote><p>EOF（End Of File)</p><p>可以通过<code>printf(&quot;%d&quot;, EOF);</code>读取EOF的数值，一般的设备上值是-1。<br>EOF操作：</p><ul><li>windows：<code>Ctrl + Z</code></li><li>unix：<code>Ctrl + D</code></li></ul></blockquote><p><code>scanf</code> 若成功读入一个值，返回1；若成功读入2个值，返回2；若<strong>读入失败，返回 -1</strong>，C/C++中，<code>EOF</code>即为 -1。</p><p>正常情况下，控制台中的输入不会失败，只有读取文件时<strong>到达文件末尾，导致无法读取时，才会产生读入失败</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取数字、字符、字符串</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串</span></span><br><span class="line"><span class="keyword">while</span> (gets(str) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="2"><li><strong><code>while··· break</code>型</strong></li></ol><p>题目要求，<strong>当输入的数据满足某个条件时，停止输入</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更简洁的写法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), a || b) &#123;<span class="comment">// scanf()恒不为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="3"><li><strong><code>while (T--)</code>型</strong></li></ol><p>题目给出测试数据的组数，然后才给出相应数量数组的输入数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ol><li><p>正常输出</p></li><li><p>每组数据输出之后，额外加一个空行</p></li><li><p><strong>两组输出数据之间有一个空行，最后一组数据后面没有空行</strong></p><p>一般在第三种输入类型<code>while (T--)</code>情况下出现，只需通过判断T是否为0选择是否输出额外的换行。</p></li></ol><hr><h3 id="重置变量"><a href="#重置变量" class="headerlink" title="重置变量"></a>重置变量</h3><p>在多点测试中，<strong>每一次循环都要重置变量和数组</strong>，否则在下一组数据来临时，变量和数组不是初始状态，将出错。<strong>重置数组一般使用<code>memset</code>函数或<code>fill</code>函数</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> OJ </tag>
            
            <tag> 在线判题系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++解题干货</title>
      <link href="/2020/02/01/C_C++%E8%A7%A3%E9%A2%98%E5%B9%B2%E8%B4%A7/"/>
      <url>/2020/02/01/C_C++%E8%A7%A3%E9%A2%98%E5%B9%B2%E8%B4%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h2><ol><li><p><strong>整型int</strong>取值范围：$-2^{31} \sim +(2^{31}-1)$，题目要求<strong>绝对值在$10^9$以内 或 32位整数</strong>，则<strong>用int型表示</strong></p></li><li><p><strong>长整型long long</strong>取值范围：$-2^{63} \sim +(2^{63}-1)$，题目要求<strong>绝对值在$10^{18}$以内 或 64位整数</strong>，则<strong>用long long型表示</strong></p><p>注：如果 long long 型赋 $&gt; 2^{31}-1$的初值，需要在初值后加上LL，否则编译错误。如<code>long long num = 123456789012345LL;</code></p></li><li><p>浮点型数据<strong>一律用double存储</strong>，而不用float(精度低，6~7位)</p></li><li><p>字符常量使用<strong>ASCII码(范围0~127)</strong>统一编码。</p><ul><li>0~9 的ASCII码值：48~57</li><li>A~Z 的ASCII码值：65~90</li><li>a~z 的ASCII码值：97~122 (<strong>比大写字母的ASCII码值大32</strong>)</li></ul></li><li><p>强制类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">12.56</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)r); <span class="comment">//输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, (<span class="keyword">double</span>)a / (<span class="keyword">double</span>)b);<span class="comment">//输出0.6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td>#include &lt;cstdio><br><strong>scanf函数<br>printf函数</strong></td><td>#include &lt;iostream> <br>using std::cin;<br>using std::cout;<br>cin<br>cout</td><td>cin 和 cout <strong>无需指定输入输出格式</strong>，<br>但<strong>消耗的时间</strong>比 scanf 和 printf <strong>多得多</strong>。<br>故<strong>推荐使用C语言的 scanf 和 printf</strong>，<br>只有在十分必要的时候使用 cin 和 cout</td></tr></tbody></table><h3 id="输入和输出格式"><a href="#输入和输出格式" class="headerlink" title="输入和输出格式"></a>输入和输出格式</h3><table><thead><tr><th>类型</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>long long</td><td><code>scanf(&quot;%lld&quot;, &amp;n);</code></td><td><code>printf(&quot;%lld&quot;, n);</code></td></tr><tr><td>double</td><td><code>scanf(&quot;%lf&quot;, &amp;db);</code></td><td><code>printf(&quot;%f&quot;, db);</code></td></tr><tr><td>字符串</td><td><code>scanf(&quot;%s&quot;, str);</code><br>(<strong>无需 取地址符&amp;</strong>)<br></td><td><code>printf(&quot;%s&quot;, str);</code></td></tr><tr><td>char</td><td><code>c1 = getchar();</code><br><strong>能读入换行符<code>\n</code></strong></td><td><code>putchar(c1);</code></td></tr></tbody></table><h3 id="实用的输出格式"><a href="#实用的输出格式" class="headerlink" title="实用的输出格式"></a>实用的输出格式</h3><ol><li><p><code>%md</code></p><p>使不足m位的int型变量以m位进行<strong>右对齐</strong>输出，高位<strong>用空格补齐</strong>；若变量本身超过m位，则保持原样。</p></li><li><p><code>%0md</code></p><p>使不足m位的int型变量以m位进行<strong>右对齐</strong>输出，高位<strong>用0补齐</strong>；若变量本身超过m位，则保持原样。</p></li><li><p><code>%.mf</code></p><p>让浮点数保留m位小数(<strong>四舍六入五成双</strong>)输出。如果要<strong>四舍五入</strong>，需要用到<strong>round函数</strong>。</p><blockquote><p>四舍六入五成双：</p><ul><li>5后有数时：舍5入1</li><li>5后无数时：<ul><li>5前为奇数，舍5入1</li><li>5前为偶数，舍5不进（0是偶数）</li></ul></li></ul></blockquote></li></ol><hr><h2 id="C-标准库头文件"><a href="#C-标准库头文件" class="headerlink" title="C++标准库头文件"></a>C++标准库头文件</h2><table><thead><tr><th>C++标准库</th><th>包含内容</th></tr></thead><tbody><tr><td>&lt;iostream></td><td>C++标准输入和输出函数 的函数原型</td></tr><tr><td>&lt;cstdio></td><td>C风格标准输入和输出函数 的函数原型</td></tr><tr><td>&lt;iomanip></td><td><strong>格式化数据流</strong>的流操纵符 的函数原型</td></tr><tr><td>&lt;cmath></td><td><strong>数学库</strong>函数 的函数原型</td></tr><tr><td>&lt;ctime></td><td>处理时间和日期的函数 的函数原型</td></tr><tr><td>&lt;cstdlib></td><td><strong>数与文本的转换、内存分配、随机数</strong>及其他各种<strong>工具函数</strong> 的函数原型</td></tr><tr><td>&lt;random></td><td>产生<strong>非确定性的随机数</strong> 的功能库</td></tr><tr><td>&lt;cctype></td><td><strong>测试 字符</strong>特定属性(如是否为数字、标点符号等)函数 的函数原型<br><strong>转换 大小写字母</strong>的函数 的函数原型</td></tr><tr><td>&lt;iterator></td><td><strong>访问 C++标准库容器中数据</strong> 的类</td></tr><tr><td>&lt;algorithm></td><td><strong>操作 C++标准库容器中数据</strong> 的函数</td></tr><tr><td>&lt;string></td><td>C++标准库的 <code>string</code>类 的定义</td></tr><tr><td>&lt;cstring></td><td>C风格<strong>字符串处理</strong>函数 的函数原型</td></tr></tbody></table><hr><h3 id="lt-cmath"><a href="#lt-cmath" class="headerlink" title="&lt;cmath>"></a>&lt;cmath></h3><ol><li><p><strong><code>double fabs(double x)</code></strong></p><p><strong>浮点型取绝对值</strong></p></li><li><p><strong><code>double floor(double x)</code>和<code>ceil(double x)</code></strong></p><p><strong>向下取整</strong>和<strong>向上取整</strong></p></li><li><p><strong><code>double round(double x)</code></strong><br><strong>针对小数点后一位四舍五入</strong></p><p>另，<strong>不使用函数进行四舍五入的方法</strong>：</p><p><code>num = num + 0.5</code> </p></li><li><p><strong><code>double pow(double r, double p)</code></strong></p><p>求 r 的 p次方</p><p><strong>$10^n$还有另外的表示方法，如</strong></p><ul><li>$10^3$ 可写成 <code>1e3</code></li><li>$2\times10^6$可写成<code>2e6</code></li><li>$3\times10^{-6}$可写成<code>3e-6</code></li></ul></li><li><p><strong><code>double sqrt(double x)</code></strong></p><p>求 x 的算术平方根</p></li><li><p><strong><code>double log(double x)</code></strong>和<strong><code>double log10(double x)</code></strong></p><p>求 x <strong>以 $e$ 为底</strong>的对数 和 <strong>以10为底</strong>的对数</p><p>针对<strong>任意底数求对数的函数</strong>，必须用<strong>换底公式</strong>，即$\log_ab = \ln b/\ln a$</p></li><li><p><strong><code>double exp(double x)</code></strong></p><p>指数函数$e^x$</p></li><li><p>三角函数</p><p><strong>x为弧度</strong></p><ul><li><code>sin(double x)</code></li><li><code>cos(double x)</code></li><li><code>tan(double x)</code></li></ul></li></ol><hr><h3 id="lt-ctime"><a href="#lt-ctime" class="headerlink" title="&lt;ctime>"></a>&lt;ctime></h3><ol><li><p><code>time_t time(time_t *seconds)</code></p><p>返回<strong>自 格林尼治标准时间的1970年1月1日0时 起 到现在</strong>的<strong>秒数</strong>。如果<code>seconds</code>不为空，<strong>返回值也存储在<code>seconds</code>中</strong>。</p></li></ol><hr><h3 id="lt-cstdlib"><a href="#lt-cstdlib" class="headerlink" title="&lt;cstdlib>"></a>&lt;cstdlib></h3><ol><li><p><code>int rand()</code></p><p><code>rand</code>函数生成 [0, RAND_MAX] 之间的一个<strong>整数</strong></p><p>直接由<code>rand</code>函数生成的数的范围<strong>常常不能满足具体需要</strong>，可以通过<strong>比例缩放(scaling)</strong>方法得到所需的随机数。例如<strong>模拟投掷六面骰子，结果可以用<code>rand() % 6 + 1</code>表示</strong>。其中数字6称为<strong>比例缩放因子</strong>。</p></li><li><p><code>void srand(unsigned int seed)</code></p><p><code>rand</code>函数<strong>实际上生成的是 伪随机数</strong>。程序每次执行时产生的序列都是重复的，将其调整为每次执行时都产生不同的随机数序列的过程称为<strong>随机化</strong>，可以<strong>通过<code>srand</code>函数实现</strong>。<code>srand</code>函数接收一个<code>unsigned int</code>值，<strong>为</strong> <code>rand</code>函数使用的<strong>随机数发生器 “播种”</strong>，从而产生不同的随机数序列。为了<strong>在随机化时不用每次都输入“种子”</strong>，可以使用如下语句：</p><p><code>srand(static_cast&lt;unsigned int&gt;(time(NULL) ) );</code></p></li></ol><hr><h3 id="lt-cctype"><a href="#lt-cctype" class="headerlink" title="&lt;cctype>"></a>&lt;cctype></h3><ol><li><p><code>int isalnum(int c)</code></p><p>字符是否为<strong>数字或字母</strong></p></li><li><p><code>int isalpha(int c)</code></p><p>字符是否是<strong>字母</strong></p></li><li><p><code>int isdigit(int c)</code></p><p>字符是否是十进制<strong>数字</strong></p></li><li><p><code>int islower(int c)</code></p><p>是否是<strong>小写字母</strong></p></li><li><p><code>int isupper(int c)</code></p><p>是否是<strong>大写字母</strong></p></li><li><p><code>int tolower(int c)</code></p><p>把大写字母 <strong>转换为 小写字母</strong></p><p><strong>不会改变非字母字符的值</strong></p></li><li><p><code>int toupper(int c)</code></p><p>把小写字母 <strong>转换为 大写字母</strong></p><p><strong>不会改变非字母字符的值</strong></p></li></ol><hr><h3 id="lt-algorithm"><a href="#lt-algorithm" class="headerlink" title="&lt;algorithm>"></a>&lt;algorithm></h3><ol><li><p><code>max(x, y)</code>和<code>min(x, y)</code></p></li><li><p><code>abs(x)</code>：<code>x</code>必须是<strong>整数</strong>，因此更推荐使用<code>&lt;cmath&gt;</code>下的<code>fabs(x)</code></p></li><li><p><code>swap(x, y)</code></p></li><li><p><code>reverse(it1, it2)</code></p><p><strong>可以将 数组指针在[it1, it2)之间的元素 或 容器的迭代器在[it1, it2)之间的元素 进行反转</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">reverse(a, a + <span class="number">4</span>); <span class="comment">//将 a[0] ~ a[3]反转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//输出结果：13 12 11 10 14 15</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"abcdefghi"</span>;</span><br><span class="line">reverse(str.begin() + <span class="number">2</span>, str.begin() + <span class="number">6</span>); <span class="comment">//对str[2] ~ str[5]反转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：abfedcghi</span></span><br></pre></td></tr></table></figure></li><li><p><code>next_permutation</code>函数</p><p>给出一个序列在<strong>全排列中的下一个序列</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span>(next_permutation(a, a + <span class="number">3</span>)); <span class="comment">//a[0]~a[2]之间的序列求解下一个序列</span></span><br></pre></td></tr></table></figure></li><li><p><code>fill</code>函数</p><p>对数组或容器中某一段区间元素<strong>赋相同的值</strong>。和<code>&lt;cstring&gt;</code>的<code>memset</code>不同(基本只用于赋<strong>0或-1</strong>)，可以赋<strong>数组类型对应范围中的任意值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fill(a, a + <span class="number">5</span>, <span class="number">233</span>); <span class="comment">//a[0] ~ a[4] 均赋值为 233</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//输出结果：233 233 233 233 233</span></span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p><code>sort</code>函数</p><p>C语言的<code>qsort</code>函数的使用需要运用指针，且写法上没有C++的<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p><p><code>sort(首元素地址, 尾元素地址的下一个地址, 比较函数cmp(非必填))</code></p><p>如果<strong>不写比较函数cmp</strong>，则<strong>默认升序</strong>排序。如果想要<strong>降序</strong>排序，需要编写比较函数cmp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//返回值为true时，a被排在b之前</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">//降序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在STL标准容器中，<strong>只有<code>vector</code>、<code>string</code>、<code>deque</code>可以使用<code>sort</code>，因为像<code>set</code>、<code>map</code>这种容器是用红黑树实现的，元素本身有序，故不允许使用<code>sort</code>排序</strong>。</p></li><li><p><code>lower_bound</code>和<code>upper_bound</code></p><p><code>lower_bound(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>第一个值$\geq$<code>val</code>的元素的位置</strong>。</p><p><code>upper_bound(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>第一个值&gt;<code>val</code>的元素的位置</strong>。</p><p><strong>如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。如果没有找到相应元素，则返回可以插入该元素的位置的指针或迭代器</strong>。</p></li><li><p><code>max_element</code>和<code>min_element</code></p><p><code>max_element(first, last)</code>用来寻找在数组或容器中的[first, last)范围内<strong>最大元素的位置</strong>。</p><p><code>min_element(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>最小元素的位置</strong>。</p><p><strong>如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器</strong>。</p></li></ol><hr><h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><h4 id="lt-vector"><a href="#lt-vector" class="headerlink" title="&lt;vector>"></a>&lt;vector></h4><p><strong>向量</strong>(“<strong>变长数组</strong>”的叫法更容易理解)，<strong>长度可以根据需要进行变化，比较节省空间</strong>。试题中，有时会碰到<strong>只用普通数组会超内存的情况，使用<code>vector</code>会让问题的解决便捷许多</strong>；另外，<code>vector</code>还可以用来<strong>以邻接表的方式存储图</strong>。</p><ol><li><p><code>vector</code>的定义</p><p><code>vector&lt;typename&gt; name</code></p><p>如果<code>typename</code>也是一个STL(Standard Template Library)容器，<strong>在C++11之前，定义的时候，在符号<code>&gt;&gt;</code>之间要加上空格</strong>。如：<code>vector&lt;vector&lt;int&gt; &gt; name;</code>，可以理解为<strong>两个维都可变长的二维数组</strong>。</p><p>而vector数组的定义，如：<code>vector&lt;typename&gt; Arrayname[arraySize];</code>，<strong>一维长度已固定，注意两者的区别</strong>。</p></li><li><p><code>vector</code>常用函数</p><ol><li><p><code>push_back(typename x)</code>：在 vector <strong>末尾添加</strong>一个元素 x</p></li><li><p><code>pop_back()</code>：<strong>删除</strong> vector 的<strong>末尾元素</strong></p></li><li><p><code>begin()</code>：取 vector 的<strong>首元素地址</strong></p></li><li><p><code>end()</code>：取 vector 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p></li><li><p><code>size()</code>：获取 vector 中的<strong>元素个数</strong></p></li><li><p><code>clear()</code>：<strong>清空</strong> vector 中所有元素</p></li><li><p><code>insert(vector&lt;typename&gt;::iterator it, typename x)</code>：向vector的 <strong>任意迭代器 it 处</strong> 插入一个元素 x</p><p>如<code>vi.insert(vi.begin() + 2, -1); //将 -1 插入vi[2]</code></p></li><li><p><code>erase()</code></p><ul><li>删除迭代器为 it 处的元素：<code>erase(it);</code></li><li>删除 [firstIt, lastIt) 内所有元素：<code>erase(firstIt, lastIt);</code></li></ul></li></ol></li><li><p><code>vector</code>容器内元素的访问</p><ol><li><p>通过<strong>下标</strong>访问</p></li><li><p>通过<strong>迭代器iterator</strong>访问</p><p><code>vector&lt;typename&gt;::iterator it;</code>，这样就得到了迭代器<code>it</code>，可以通过<strong><code>*it</code>来访问<code>vector</code>里的元素</strong>。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">        vi.push_back(i); <span class="comment">//在 vi 的 末尾 添加元素 i</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin(); <span class="comment">//vi.begin() 为取 vi 的首元素地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *(it + i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>vi[i]</code>和<code>vi.begin() + i</code><strong>等价</strong>。在常用的STL容器中，<strong>只有<code>vector</code>和<code>string</code>中，才允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong>。</p><p>迭代器还实现了自增和自减的操作，于是还有一种遍历<code>vector</code>中元素的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector 的迭代器不支持 it &lt; vi.end() 写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin(); it != vi.end(); it++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h4 id="lt-set"><a href="#lt-set" class="headerlink" title="&lt;set>"></a>&lt;set></h4><p><strong>集合</strong>，是一个<strong>内部自动递增排序 且 不含重复元素</strong>的容器。试题中，可能出现需要<strong>去掉重复元素</strong>的情况，而且<strong>有可能因为这些元素 比较大 或者 类型不是<code>int</code>型 而不能直接开散列表</strong>，这种情况下就可以用<code>set</code>来保留元素本身而不考虑个数。虽然上述情况<strong>也可以通过再开一个数组进行下标和元素对应来解决</strong>，但<code>set</code>提供了<strong>更为直观</strong>的接口，并且可以实现<strong>自动排序</strong>，可以在做某些题时<strong>减少思维量</strong>。</p><ol><li><p><code>set</code>的定义</p><p><code>set&lt;typename&gt; name;</code></p><p>和<code>vector</code>相同，如果<code>typename</code>也是一个STL容器，<strong>在C++11之前，定义的时候，在符号<code>&gt;&gt;</code>之间要加上空格</strong>。如：<code>set&lt;vector&lt;int&gt; &gt; name;</code>，可以理解为<strong>两个维都可变长的二维数组</strong>。</p></li><li><p><code>set</code>常用函数</p><ol><li><p><code>begin()</code>：取 set 的<strong>首元素地址</strong></p></li><li><p><code>end()</code>：取 set 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p></li><li><p><code>size()</code>：获取 set 中的<strong>元素个数</strong></p></li><li><p><code>clear()</code>：<strong>清空</strong> set 中所有元素</p></li><li><p><code>insert(typename x)</code>：将 x 插入 set 容器中，并自动递增排序和去重，时间复杂度为$O(logN)$</p></li><li><p><code>find(typename value)</code>：返回 set 中<strong>对应值为 value 的迭代器</strong></p><p>如：<code>set&lt;int&gt;::iterator it = st.find(2);</code> //在 set 中查找2，返回其迭代器</p></li><li><p><code>erase()</code></p><ul><li><p>删除单个元素</p><ul><li><p>删除迭代器为 it 处的元素：<code>erase(it);</code></p><p>可以结合<code>find</code>函数使用，如：<code>st.erase(st.find(100))</code></p></li><li><p>删除值为 value 的元素：<code>erase(value);</code></p></li></ul></li><li><p>删除 [firstIt, lastIt) 内所有元素：<code>erase(firstIt, lastIt)</code></p></li></ul></li></ol></li><li><p><code>set</code>容器内元素的访问</p><p><code>set</code><strong>只能通过 迭代器iterator 访问</strong>，因为<strong>只有<code>vector</code>和<code>string</code>中，才允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong>，因此只能按如下方式枚举：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">st.insert(<span class="number">3</span>);</span><br><span class="line">    st.insert(<span class="number">5</span>);</span><br><span class="line">    st.insert(<span class="number">2</span>);</span><br><span class="line">    st.insert(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//set 的迭代器不支持 it &lt; vi.end() 写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.begin(); it != st.end(); it++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：<code>2 3 5</code>，可以发现，<code>set</code>内的元素自动<strong>递增</strong>排序，且自动去除了重复元素。</p></li><li><p>延伸</p><p><code>set</code>中元素是唯一的，如果<strong>处理元素不唯一的情况，需要使用<code>multiset</code></strong>。C++11 标准中还增加了<code>unordered_set</code>，<strong>以散列代替<code>set</code>内部的红黑树(一种自平衡二叉查找树)实现</strong>，使其可以用来<strong>去重但不排序</strong>的需求，速度比set快得多。</p></li></ol><hr><h4 id="lt-string"><a href="#lt-string" class="headerlink" title="&lt;string>"></a>&lt;string></h4><ol><li><p><code>string</code>中内容的访问</p><ol><li><p>通过下标访问</p><p>一般来说，<strong>可以直接像字符数组那样去 访问</strong><code>string</code>，如果要读入和输出<strong>整个字符串</strong>，则<strong>只能用<code>cin</code>和<code>cout</code></strong>。那么有办法用<code>printf</code>输出<code>string</code>吗？</p><p>用<code>string</code>的函数<code>c_str()</code>可以将<code>string</code>类型<strong>转换为字符数组</strong>进行输出。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.c_str());</span><br></pre></td></tr></table></figure></li><li><p>通过迭代器访问</p><p>有些函数比如<code>insert()</code>与<code>erase()</code>要求以迭代器为参数进行访问。由于<code>string</code>不像其他STL容器那样需要参数，因此可以直接如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = str.begin(); it != str.end(); i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it;</span><br></pre></td></tr></table></figure><p><strong><code>string</code>和<code>vector</code>一样，允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong></p></li></ol></li><li><p><code>string</code>常用函数</p><ol><li><p><code>operator+=</code></p><p><code>string</code>的加法，可以将两个<code>string</code><strong>直接拼接</strong>。</p></li><li><p><code>compare operator</code></p><p>两个<code>string</code>类型可以<strong>直接使用 比较符 比较大小</strong>，比较规则是<strong>按字典序</strong>。</p></li><li><p><code>begin()</code>：取 string 的<strong>首元素地址</strong></p></li><li><p><code>end()</code>：取 string 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p></li><li><p><code>size()/length()</code>：返回 string 的长度</p></li><li><p><code>clear()</code>：清空 string 中的数据</p></li><li><p><code>insert</code></p><ul><li><p>在 pos 位置插入字符串：<code>insert(int pos, string str)</code>，<strong>原来位置的字符串顺延</strong>。</p></li><li><p>在 迭代器it 位置插入字符串：</p><p><code>insert(it, firstIt, lastIt)</code>，<code>firstIt</code>和<code>lastIt</code>为<strong>待插字符串的首尾迭代器</strong>，用来表示串 [firstIt, lastIt) 将被插在 it 位置上</p></li></ul></li><li><p><code>string::npos</code>：是一个<strong>常数</strong>，本身值为<strong>-1</strong>，但由于是<code>unsigned_int</code>类型，因此实际上<strong>可以认为是最大值</strong>。用于作为<code>find</code>函数失配时的返回值。</p></li><li><p><code>find()</code></p><ul><li><code>str.find(string str1)</code>：当 str1 是子串时，返回在 str 中<strong>第一次出现的位置</strong>；如果不是字串，则返回<code>string::npos</code></li><li><code>str.find(string str1, int pos)</code>：从 pos 位置开始匹配 str1</li></ul></li><li><p><code>erase()</code></p><ul><li>删除单个元素：<code>erase(it)</code>，目标字符<strong>之后的字符字串 前移</strong>。</li><li>删除一个区间内的所有元素，目标区间<strong>之后的字符字串 前移</strong>。<ul><li><code>erase(firstIt, lastIt)</code>，删除 [firstIt, lastIt) 间的所有字符</li><li><code>erase(int pos, int length)</code>，pos 是删除的起始位置</li></ul></li></ul></li><li><p><code>substr(int pos, int length)</code>：<strong>返回</strong>从 pos 位置开始，长度为 length 的<strong>字串</strong>。</p></li><li><p><code>replace()</code></p><ul><li><code>str.replace(int pos, int lenth, str1)</code>：把 str 从 pos 位置开始，长度为 length 的字串替换为 str1，<strong>替换位置之后的字符串不变</strong>。</li><li><code>str.replace(it1, it2, str1)</code>：把 str 的迭代器 [it1, it2) 范围的字串替换为 str1，<strong>替换位置之后的字符串不变</strong>。</li></ul></li></ol></li></ol><hr><h4 id="lt-map"><a href="#lt-map" class="headerlink" title="&lt;map>"></a>&lt;map></h4><p><strong>映射</strong>，<code>map</code><strong>可以将 任何基本类型(包括STL容器) 映射到 任何基本类型(包括STL容器)</strong>。</p><p>来看一个情况：判定给的一些数字在某个文件中是否出现过。如果数字很大，那么就不便建立散列的数组。这时，<strong>可以通过<code>map</code>，将这些数字当成字符串，建立<code>string</code>至<code>int</code>的映射</strong>。</p><ol><li><p><code>map</code>的定义</p><p><code>map&lt;typename1, typename2&gt; mp;</code>：<code>&lt; &gt;</code>内第一个是 键(key) 的类型，第二个是 值(value) 的类型。<strong>map 会以 键 从小到大的顺序自动排序(因为 map 内部是使用红黑树实现的，set也是如此)</strong>。<strong>map 的一个键只能对应一个值</strong>。如果是 int 型映射到 int 型，就相当于普通的 int 型数组。</p><p>如果是<strong>字符串到整型的映射，必须使用 string 而不能使用 char数组</strong>：<code>map&lt;string, int&gt; mp;</code>，因为<strong>数组不能作为键值</strong>。</p></li><li><p><code>map</code>常用函数</p><ol><li><p><code>begin()</code>：取 map 的<strong>首元素地址</strong></p></li><li><p><code>end()</code>：取 map 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p></li><li><p><code>find(key)</code>：返回 键key的对应映射值 的迭代器</p><p><code>map&lt;char int&gt;::iterator it = mp.find(&#39;b&#39;);</code></p></li><li><p><code>erase()</code></p><ul><li>删除单个元素：<ul><li><code>erase(it)</code>：it 为待删除映射的迭代器</li><li><code>erase(key)</code>：key 为待删除映射的键</li></ul></li><li>删除一个区间内的所有映射：<code>erase(firstIt, lastIt)</code></li></ul></li><li><p><code>size()</code>：获取映射的对数</p></li><li><p><code>clear()</code>：清空 map 中的所有映射</p></li></ol></li><li><p><code>map</code>容器内元素的访问</p><ol><li><p>通过下标访问</p><p>例如定义为<code>map&lt;char, int&gt; mp</code>的map来说，可以直接使用<code>mp[&#39;c&#39;]</code>的方式来访问对应的整数。</p></li><li><p>通过迭代器访问</p><p><code>map&lt;typename1, typename2&gt;::iterator it;</code>，因为 map 的每一对映射都有两个 typename，这决定了必须<strong>能通过一个 it 来同时访问键和值</strong>。事实上，<code>map</code>可以使用<code>it-&gt;first</code>来访问键，<code>it-&gt;second</code>来访问值。</p></li></ol></li><li><p>延伸</p><p>map 的 键和值是唯一的(一对一)，而<strong>如果需要一个键对应多个值(一对多)，就只能用<code>multimap</code></strong>。C++11 标准中还增加了<code>unordered_map</code>，以散列代替 map 内部的红黑树实现，使其可以只处理映射而不按key值排序，速度比 map 快得多。</p></li></ol><hr><h4 id="lt-queue"><a href="#lt-queue" class="headerlink" title="&lt;queue>"></a>&lt;queue></h4><p>队列，先进先出。</p><ol><li><p><code>queue</code>的定义</p><p><code>queue&lt;typename&gt; name;</code></p></li><li><p><code>queue</code>常用函数</p><ol><li><code>push(x)</code>：将 x 进<strong>行入 队尾</strong></li><li><code>front()</code>、<code>back()</code>：分别获得队首和队尾元素</li><li><code>pop()</code>：令<strong>队首</strong>元素<strong>出队</strong></li><li><code>empty()</code>：<strong>检测 queue 是否为空</strong></li><li><code>size()</code>：返回队列内元素个数</li></ol></li><li><p><code>queue</code>容器内元素的访问</p><p>由于队列是一种先进先出的限制性数据结构，因此<strong>只能通过<code>front()</code>来访问队首元素，<code>back()</code>访问队尾元素</strong>。</p></li><li><p><code>queue</code>的常见用途</p><p>当需要实现<strong>广度优先搜索(BFS)</strong>时，可以不用手动实现一个队列，以提高程序的准确性。需要注意的时是，<strong>使用<code>front()</code>和<code>pop()</code>函数之前，必须用<code>empty()</code>判断队列是否为空</strong>，否则可能因为队空而出现错误。</p><p>延伸：STL的容器中还有两种跟队列有关：</p><ul><li><p><strong>双端队列<code>deque</code></strong>：<strong>首尾皆可插入和删除</strong>的队列。</p><ul><li><strong>优先队列<code>priority_queue</code></strong>：使用<strong>堆</strong>实现的<strong>默认当前队列 最大元素置于队首</strong>的容器。</li></ul></li></ul></li></ol><h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><code>priority_queue</code></h5><ol><li><p><code>priority_queue</code>的定义</p><p><code>priority_queue&lt;typename&gt; name;</code></p></li><li><p><code>priority_queue</code>常用函数</p><ol><li><code>push(x)</code>：将 x入队，时间复杂度为O(<strong>logN</strong>)</li><li><code>top()</code>：获得队首(即堆顶)元素</li><li><code>pop()</code>：令队首元素(即堆顶)元素出队，时间复杂度为O(<strong>logN</strong>)</li><li><code>empty()</code>：检测优先队列是否为空</li><li><code>size()</code>：返回优先队列内元素个数</li></ol></li><li><p><code>priority_queue</code>容器内元素的访问</p><p><strong>只能通过<code>top()</code>函数访问队首元素(优先级最高的元素)</strong>。</p></li><li><p><code>priority_queue</code>内<strong>元素优先级的设置</strong></p><ol><li><p>基本数据类型的优先级设置</p><p>下列两种优先队列的定义是等价的(以<code>int</code>型为例)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure><ul><li><code>vector&lt;int&gt;</code>：用来<strong>承载底层数据结构—堆</strong>的容器</li><li><code>less&lt;int&gt;</code>：表示<strong>数字大的优先级越大</strong>(<strong>默认优先级</strong>)；<code>greater&lt;int&gt;</code>即为<strong>数字小的优先级越大</strong>。</li></ul><p>因此，如果想让最小的元素放在队首，需要如下定义：</p><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code></p></li><li><p>结构体的优先级设置</p><p>比如定义水果的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在希望<strong>按水果价格高的为优先级高</strong>，就需要<strong>重载小于号<code>&lt;</code></strong>：</p><ul><li><p>方式一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price; <span class="comment">//水果价格高的为优先级高</span></span><br><span class="line">        <span class="comment">// return f1.price &gt; f2.price; //水果价格低的为优先级高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>friend</code>为<strong>友元</strong>。<code>bool operator &lt; (fruit f1, fruit f2)</code><strong>对<code>&lt;</code>进行了重载</strong>。此时就可以直接定义<code>fruit</code>类型的优先队列，其内部就是以<strong>水果价格高的为优先级高</strong>：<code>priority_queue&lt;fruit&gt; q;</code></p></li><li><p>方式二：<strong>将重载的函数写在结构体外</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1, fruit f2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit, <span class="built_in">vector</span>&lt;fruit&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure></li></ul><p>即便是<strong>基本数据类型或者其他STL容器(如 set)</strong>，<strong>也可以通过同样的方式来定义优先级</strong>。如果结构体内的数据较为庞大，<strong>建议使用引用来提高效率</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> operate &lt; (<span class="keyword">const</span> fruit &amp;f1, <span class="keyword">const</span> fruit &amp;f2) &#123;</span><br><span class="line">    reutrn f1.price &gt; f2.price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或如下</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> fruit &amp;f1, <span class="keyword">const</span> fruit &amp;f2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>priority_queue</code>的常见用途</p><p>可以解决一些<strong>贪心问题</strong>，也可以<strong>对 Dijkstra 算法进行优化</strong>(因为优先队列的本质是堆)。需要注意的时是，<strong>使用<code>top()</code>函数之前，必须用<code>empty()</code>判断队列是否为空</strong>，否则可能因为队空而出现错误。</p></li></ol><hr><h4 id="lt-stack"><a href="#lt-stack" class="headerlink" title="&lt;stack>"></a>&lt;stack></h4><p>栈</p><ol><li><p><code>stack</code>的定义</p><p><code>stack&lt;typename&gt; name;</code></p></li><li><p><code>stack</code>常用函数</p><ol><li><code>push(x)</code>：将 x 压入栈</li><li><code>top()</code>：获得栈顶元素</li><li><code>pop()</code>：弹出栈顶元素</li><li><code>empty()</code>：检测 stack 是否为空</li><li><code>size()</code>：返回 stack 内元素的个数</li></ol></li><li><p><code>stack</code>容器内元素的访问</p><p><strong>只能通过<code>top()</code>函数访问栈顶元素</strong>。</p></li><li><p><code>stack</code>的常见用途</p><p>stack 用来<strong>模拟实现一些 递归</strong>，防止程序<strong>对栈内存的限制</strong>而导致程序运行出错。对有些题目来说，<strong>如果用普通的函数进行递归，一旦递归层数过深，则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题</strong>。</p></li></ol><hr><h4 id="lt-utility"><a href="#lt-utility" class="headerlink" title="&lt;utility>"></a>&lt;utility></h4><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a><code>pair</code></h5><p>当想要<strong>将两个元素绑在一起作为一个合成元素</strong>，又<strong>不想因此定义结构体</strong>时，使用<code>pair</code>可以很方便地作为一个替代品，即 pair 可以<strong>看作 内部有两个元素 的结构体</strong>。</p><ol><li><p><code>pair</code>的定义</p><p>注意：因为 映射map 的内部实现中涉及 pair，因此<strong>添加 map头文件 时会自动添加 utility头文件</strong>，因此，<strong>记不住 utility头文件，则可以用 map头文件 来代替</strong>。</p><p>pair 有两个参数：<code>pair&lt;typeName1, typeName2&gt; name;</code></p><ul><li><p>如果想<strong>在定义 pair 时进行初始化</strong>，只需要跟上一个小括号，填写两个初始化元素即可：</p><p><code>pair &lt;string, int&gt; p(&quot;haha&quot;, 5);</code></p></li><li><p>如果想<strong>临时构建一个 pair</strong>：</p><ul><li><code>pair&lt;string, int&gt;(&quot;haha&quot;, 5)</code></li><li>使用自带的<code>make_pair</code>函数：<code>make_pair(&quot;haha&quot;, 5)</code></li></ul></li></ul></li><li><p><code>pair</code>中元素的访问</p><p>pair 中<strong>只有两个元素，分别是<code>first</code>和<code>second</code></strong>，只需要<strong>按 正常结构体的方式 访问</strong>即可。</p></li><li><p><code>pair</code>常用函数</p><p><strong>比较操作数</strong>：</p><p>两个 pair 类型数据可以<strong>直接使用比较符比较大小</strong>，比较规则是<strong>先以<code>first</code>的大小作为标准，<code>first</code>相等时去比较<code>second</code>的大小</strong>。</p></li><li><p><code>pair</code>的常见用途</p><ul><li><p>代替二元结构体及其构造函数，节省编码时间</p></li><li><p>作为<code>map</code>的<strong>键值对</strong>来进行插入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">mp.insert(make_pair(<span class="string">"heihei"</span>, <span class="number">5</span>));</span><br><span class="line">mp.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"haha"</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p><strong>一维数组初始化</strong></p><p><strong>如果数组没有初始化，数组中每个元素为随机数</strong>。一维数组的初始化，<strong>未被赋初始值</strong>的元素将<strong>默认初始化为0</strong>，因此，如果想要给整个数组初始化为0，只需第一个元素初始化为0即可。<code>int a[10] = {0};</code>(<strong>不适用C语言</strong>)</p></li><li><p><strong>二维数组初始化</strong></p><p>二维数组初始化需要<strong>按第一维的顺序</strong>，依次<strong>用大括号</strong>给出<strong>第二维初始化</strong>的情况，<strong>未被赋初始值</strong>的元素将<strong>默认初始化为0</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">3</span>&#125;, &#123;&#125;, &#123;<span class="number">8</span>, <span class="number">4</span>&#125;&#125;; <span class="comment">//第二行使用大括号跳过</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">数组初始化为：</span></span><br><span class="line"><span class="comment">3 0</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">8 4</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果数组大小较大(大概$10^6$级别)，需要定义在主函数外(即全局变量)</strong></p><p>否则程序会异常退出（局部变量来自系统栈，允许申请空间较小；全局变量来自静态存储区，允许申请的空间较大）</p></li><li><p><strong>对数组中每一个元素赋相同的值</strong></p><p><strong>需要<code>#include &lt;cstring&gt;</code></strong></p><p><code>void* memset(数组名, 值, sizeof(数组名));</code></p><p>memset <strong>按字节赋值</strong>，即对每个字节赋同样的值，<strong>组成int型的4个字节就会被赋成相同的值</strong>。故建议<strong>只用于赋 0或 -1</strong>(0的二进制补码为全0，-1的二进制补码为全1)，不易出错。</p><p><strong>如果要对数组赋其他数字(如 1)，则使用 fill函数（执行速度比 memset 慢）</strong>。</p></li></ol><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ul><li><p>输入</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>scanf(&quot;%s&quot;, str);</code> 识别<strong>空格或换行</strong>作为输入结束，且<strong>空格或回车符会留在缓冲区</strong></p></li><li><p><code>char c = getchar();</code> 能够读入<strong>空格和换行符</strong></p></li><li><p><code>gets(char* str);</code> 识别<strong>换行</strong>作为输入结束，且<strong>回车符会被舍弃，不在缓冲区</strong></p><p>因此，<strong>scanf一个输入后，如果要使用gets，需要先用 getchar 接收scanf后的空格或换行符</strong>。</p><p>另外，<strong>PAT使用C++提交时</strong>，使用<code>gets()</code>函数会出现<strong>编译错误</strong>，建议使用C++函数。</p></li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>cin &gt;&gt;</code></p></li><li><p><code>cin.getline(数组名称, 数组大小)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指定最多读入 9 个字符，超出即报错</span></span><br><span class="line"><span class="comment">（实际数组最多能存放99个字符，空字符\0 占用一个字符位）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>输出</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>printf(str);</code> </li><li><code>putchar(char c);</code></li><li><code>puts(char* str);</code> 输出数组内容后，<strong>紧跟一个换行</strong></li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br></pre></td></tr></table></figure><ul><li><code>cout &lt;&lt;</code></li></ul></li></ul></li><li><p>字符数组的存放方式</p><p>字符数组的<strong>末尾都有一个 空字符<code>\0</code>(即NULL)，表示存放的字符串的结尾</strong>。空字符<code>\0</code> 在<strong>gets</strong>和<strong>scanf</strong>输入字符串时，会<strong>自动添加在输入的字符串后面</strong>，并<strong>占用一个字符位</strong>。<strong>puts</strong>和<strong>printf</strong>就是<strong>通过识别<code>\0</code>作为字符串的结尾进行输出</strong>。</p><ul><li>空字符<code>\0</code><strong>占用一个字符位</strong>，因此<strong>字符数组的长度一定要比实际存储字符串的长度 至少多1</strong>。</li><li>如果<strong>使用<code>getchar()</code>输入字符串</strong>，一定要在<strong>每个字符串后加入<code>\0</code>，否则printf和puts输出字符串会因无法识别字符串末尾而输出一大堆乱码</strong>。</li></ul></li></ul><hr><h3 id="C-的标准库类-string"><a href="#C-的标准库类-string" class="headerlink" title="C++ 的标准库类 string"></a>C++ 的标准库类 string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>若引用了<code>&lt;iostream&gt;</code>头文件，创建string对象时，无须引用<code>&lt;string&gt;</code>，因为<code>&lt;iostream&gt;</code>有对<code>std::string</code>的间接引用。但时要对string对象运用相关的函数操作，仍须引用<code>&lt;string&gt;</code>。</p><ul><li><p>输入一整行</p><p><code>getline(cin, str)</code></p></li><li><p>比较字符串大小</p><ul><li><p><code>str1.compare(str2)</code></p><p><strong>按字典顺序(顺序越靠后，越大)</strong>，返回两个字符串大小的比较</p></li></ul></li></ul><hr><h3 id="lt-cstring"><a href="#lt-cstring" class="headerlink" title="&lt;cstring>"></a>&lt;cstring></h3><ol><li><p><code>strlen(str)</code></p><p>得到字符数组中<strong>第一个<code>\0</code>前 的字符个数</strong></p></li><li><p><code>strcmp(str1, str2)</code></p><p><strong>按字典顺序(顺序越靠后，越大)</strong>，返回两个字符串大小的比较结果：</p><ul><li><code>str1 &lt; str2</code>，返回一个<strong>负整数</strong>(不同编译器处理不同，<strong>不一定是 -1</strong>)</li><li><code>str1 == str2</code>，返回一个0</li><li><code>str1 &gt; str2</code>，返回一个<strong>正整数</strong>(不同编译器处理不同，<strong>不一定是 +1</strong>)</li></ul></li><li><p><code>strcpy(str1, str2)</code></p><p>把 str2 复制给 str1，<strong>包括结束符<code>\0</code></strong></p></li><li><p><code>strcat(str1, str2)</code></p><p>把 str2 <strong>拼接</strong>到 str1 后面</p></li></ol><hr><h3 id="字符串与数字的相互转换"><a href="#字符串与数字的相互转换" class="headerlink" title="字符串与数字的相互转换"></a>字符串与数字的相互转换</h3><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br></pre></td></tr></table></figure><p>字符串 <strong>转为 数字</strong></p><ul><li><code>atoi(str)</code>：将字符串转为 int型</li><li><code>atol(str)</code>：将字符串转为 long long型</li><li><code>atof(str)</code>：将字符串转为 double型</li></ul><hr><h5 id="方法二：-sscanf-与-sprintf"><a href="#方法二：-sscanf-与-sprintf" class="headerlink" title="方法二： sscanf 与 sprintf"></a>方法二： sscanf 与 sprintf</h5><p>如果想从屏幕输入 int型变量n 并将 n 输出到屏幕：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n);</span><br><span class="line"><span class="comment">//其实可以表示成如下</span></span><br><span class="line"><span class="built_in">scanf</span>(screen, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(screen, <span class="string">"%d"</span>, n);</span><br></pre></td></tr></table></figure><p><code>sscanf</code>与<code>sprintf</code>的格式如出一辙，只是把screen换成了字符数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n); <span class="comment">//将字符数组str中的内容以"%d"格式写到n中</span></span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d"</span>, n); <span class="comment">//把n以"%d"的格式写到str数组中</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">"2048:3.14,hello"</span>, str2[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从字符串读取格式化输入</span></span><br><span class="line"><span class="comment">    使得 n = 2048, db = 3.14, str2 = hello</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">"%d:%lf,%s"</span>, &amp;n, &amp;db, str2);</span><br><span class="line">    n = <span class="number">12</span>;</span><br><span class="line">    db = <span class="number">3.1415</span>;</span><br><span class="line">    str2[<span class="number">100</span>] = <span class="string">"good"</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    发送格式化输出到字符串</span></span><br><span class="line"><span class="comment">    使得 str = "12:3.14,good"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">"%d:%.2f,%s"</span>, n, db, str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="C-："><a href="#C-：" class="headerlink" title="C++："></a>C++：</h4><p>数字 <strong>转为 字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = to_string(num);</span><br><span class="line">len = str.length();</span><br></pre></td></tr></table></figure><hr><h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><ul><li>参数中数组的<strong>第一维不需要填写长度</strong>(如果是二维数组，<strong>第二维需要填写长度</strong>)</li><li><strong>在函数中对数组元素的修改 等同于 对原数组元素的修改</strong>(与普通局部变量不同)</li></ul><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[][<span class="number">5</span>])</span> </span>&#123;<span class="comment">//参数数组 第一维不需要填写长度，第二维需要填写长度</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    b[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//不适用C语言</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">5</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//不适用C语言</span></span><br><span class="line">    change(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出结果为：</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组不允许作为返回类型出现，<strong>想要返回数组，只能通过参数返回</strong></li></ul><hr><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li><p>C语言习惯于把<code>*</code>放在变量名之前：<code>int *p;</code>(声明多个指针时，<strong>易统一</strong>)</p></li><li><p>C++习惯把<code>*</code>放在数据类型之后：<code>int* p;</code></p></li><li><p><strong>地址赋给<code>p</code>而不是<code>*p</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = &amp;a; <span class="comment">//等价于 int* p = &amp;a;</span></span><br></pre></td></tr></table></figure></li><li><p>指针的加减法</p><ul><li>两个指针相减，得到两个地址的距离</li><li><code>p + 1</code>指 p所指的int型变量 的<strong>下一个int型变量地址</strong></li><li>指针<strong>支持自增和自减操作</strong></li></ul></li></ul><hr><h3 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h3><p>例子：<strong>交换两个数</strong></p><p><strong>只有在获取地址的情况下对元素进行操作，才能真正修改变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a, *p2 = &amp;b;</span><br><span class="line">    swap(p1, p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误写法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* tmp;</span><br><span class="line">    *tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *tmp;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tmp未初始化，存放的地址很大概率指向系统工作区间，不能修改，故后续报错</span></span><br><span class="line"><span class="comment">初始化tmp即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span>* tmp = &amp;x;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="引用的含义"><a href="#引用的含义" class="headerlink" title="引用的含义"></a>引用的含义</h4><p>引用是C++的语法，在编程时极为实用。如果要<strong>修改传入函数的参数，且不使用指针</strong>，可以通过<strong>C++的引用</strong>。引用<strong>不产生副本</strong>，只是<strong>给原变量起个别名</strong>。</p><p>引用的方法：在函数的<strong>参数变量名前加个<code>&amp;</code>即可</strong>。要将<strong>引用<code>&amp;</code></strong>与<strong>取地址运算符<code>&amp;</code></strong>区分开来，<strong>引用并不是取地址的意思</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    change(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x); <span class="comment">//输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h4><p>例子：<strong>交换两个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* tmp = a;</span><br><span class="line">    a = b; <span class="comment">//交换的地址 是 值传递，不会修改原指针的地址</span></span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过引用实现交换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* &amp;a, <span class="keyword">int</span>* &amp;b)</span> </span>&#123; <span class="comment">//通过引用实现交换</span></span><br><span class="line">    <span class="keyword">int</span>* tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a, *p2 = &amp;b;</span><br><span class="line">    swap(p1, p2); <span class="comment">//不能写成 swap(&amp;a, &amp;b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用是产生<strong>变量的别名，常量不可使用引用</strong>。故上述</p><blockquote><p><code>swap(p1, p2); //不能写成 swap(&amp;a, &amp;b);</code></p></blockquote><hr><h2 id="结构体（struct）的使用"><a href="#结构体（struct）的使用" class="headerlink" title="结构体（struct）的使用"></a>结构体（struct）的使用</h2><h3 id="访问结构体内的元素"><a href="#访问结构体内的元素" class="headerlink" title="访问结构体内的元素"></a>访问结构体内的元素</h3><p>假设<code>p</code>是一个指向结构的指针，可以用<strong><code>p-&gt;结构成员</code>的形式（等价于<code>(*p).结构成员</code>）</strong>，引用相应的结构成员。</p><hr><h2 id="申请动态内存空间"><a href="#申请动态内存空间" class="headerlink" title="申请动态内存空间"></a>申请动态内存空间</h2><p>如需要定义链表的结点时。</p><p>C语言有<code>malloc</code>和<code>free</code>函数用于内存的申请和释放，C++有<code>new</code>和<code>delete</code>运算符用于内存的申请和释放。<strong>推荐使用C++进行内存的申请和释放(用法更简洁)</strong>。</p><ul><li><p>申请内存空间 — <code>new</code>运算符：</p><p>使用<strong>new + 类型名</strong>即可分配一块该类型的内存空间，<strong>返回申请的同变量类型的指针</strong>：<code>typename* p = new typename;</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">node* p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure><p>通常情况下，内存空间的申请不会失败。失败一般发生在使用<code>new</code><strong>申请了较大的动态数组</strong>，如：<code>int* p = new int[1000000];</code>。<strong>申请失败会发生异常</strong>。</p></li><li><p>释放内存 — <code>delete</code>运算符：</p><p>以<strong>需要释放的内存空间的指针变量</strong>为参数：<code>delete(p);</code>，执行之后，<strong>指针变量<code>p</code>没有消失，只是指向了空地址<code>NULL</code></strong>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言和C++的比较</title>
      <link href="/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td><strong>scanf函数<br>printf函数</strong></td><td>cin<br>cout</td><td>cin 和 cout <strong>无需指定输入输出格式</strong>，<br>但<strong>消耗的时间</strong>比 scanf 和 printf <strong>多得多</strong></td></tr></tbody></table><hr><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><table><thead><tr><th>内容</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>输入输出库</td><td>#include &lt;stdio.h&gt;</td><td><strong>#include &lt;cstdio></strong><br><strong>#include &lt;iostream></strong></td></tr><tr><td>数学函数</td><td>#include &lt;math.h&gt;</td><td><strong>#include &lt;cmath></strong></td></tr><tr><td>字符串有关函数</td><td>#include &lt;string.h&gt;</td><td><strong>#include &lt;cstring></strong></td></tr></tbody></table><hr><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="布尔型变量"><a href="#布尔型变量" class="headerlink" title="布尔型变量"></a>布尔型变量</h3><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td>#include &lt;stdbool.h&gt;</td><td><strong>可直接使用</strong></td><td>true(存储时为1)<br>false(存储时为0)</td></tr></tbody></table><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><table><thead><tr><th>内容</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>表示方法</td><td>通过 字符数组 表示</td><td>通过 string类 表示</td></tr><tr><td>字符串长度的表示</td><td>#include &lt;string.h&gt;<br>strlen(str)</td><td>#include &lt;string><br>str.length()</td></tr><tr><td>字符串拼接</td><td>#include &lt;string.h&gt;<br>strcat(str1, str2); //把str2拼接到str1之后</td><td>str1 += str2;</td></tr></tbody></table><hr><h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><ul><li>C语言 — qsort</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b; <span class="comment">//升序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(排序数组, 元素数量, 每个元素的大小(可用<span class="keyword">sizeof</span>获得), 比较函数cmp);</span><br></pre></td></tr></table></figure><ul><li>C++ — sort</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">//降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(首元素地址, 尾元素地址的下一个地址, 比较函数cmp(非必填));</span><br></pre></td></tr></table></figure><table><thead><tr><th>cmp函数的区别</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>返回值类型</td><td>int</td><td>bool</td></tr><tr><td>排序的判断</td><td>返回值 &gt; 0, a 将被排在b后面;<br>返回值 &lt; 0, a 将被排在b前面;</td><td><strong>默认升序</strong><br>返回值为<strong>true</strong>时，a将被排在b<strong>前面</strong></td></tr><tr><td>比较方式</td><td>元素<strong>相减</strong><br>不能用$&gt;$、$&lt;$比较符（<strong>返回无负值</strong>）</td><td>$&gt;$、$&lt;$比较符</td></tr></tbody></table><p><code>qsort</code>函数的使用需要运用指针，且写法上没有<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p><hr><h2 id="申请动态内存空间"><a href="#申请动态内存空间" class="headerlink" title="申请动态内存空间"></a>申请动态内存空间</h2><p><strong>内存泄露</strong>是指申请到的内存空间在<strong>使用过后没有释放</strong>，导致一些程序<strong>内存消耗过快，最后无内存可分配</strong>的情况。一般考试中，分配的内存空间在程序结束时即被释放，因此即便不是放空间，也不会产生什么影响，并且内存大小一般也足够一道题的使用。但是<strong>从编程习惯上，需要养成即时释放空间的习惯</strong>。</p><ul><li><p>C语言</p><p><code>&lt;stdlib.h&gt;</code></p><ul><li><p>申请内存空间 — <code>malloc</code>函数：</p><p>以<strong>需要申请的内存空间</strong>为参数，返回<strong>指向这块空间的指针</strong>，因为<strong>返回的指针是<code>void*</code>型，因此需要强制转换为对应类型</strong>：<code>typename* p = (typename*)malloc(sizeof(typename));</code></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">node* p = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br></pre></td></tr></table></figure><p>通常情况下，内存空间的申请不会失败。失败一般发生在使用<code>malloc</code><strong>申请了较大的动态数组</strong>，如：<code>int* p = (int*)malloc(1000000 * sizeof(int));</code>。<strong>申请失败会返回空指针<code>NULL</code></strong>。</p></li><li><p>释放内存 — <code>free</code>函数：</p><p>以<strong>需要释放的内存空间的指针变量</strong>为参数：<code>free(p);</code>，执行之后，<strong>指针变量<code>p</code>没有消失，只是指向了空地址<code>NULL</code></strong>。</p></li></ul></li><li><p>C++</p><ul><li><p>申请内存空间 — <code>new</code>运算符：</p><p>使用<strong>new + 类型名</strong>即可分配一块该类型的内存空间，<strong>返回申请的同变量类型的指针</strong>：<code>typename* p = new typename;</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">node* p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure><p>通常情况下，内存空间的申请不会失败。失败一般发生在使用<code>new</code><strong>申请了较大的动态数组</strong>，如：<code>int* p = new int[1000000];</code>。<strong>申请失败会发生异常</strong>。</p></li><li><p>释放内存 — <code>delete</code>运算符：</p><p>以<strong>需要释放的内存空间的指针变量</strong>为参数：<code>delete(p);</code>，执行之后，<strong>指针变量<code>p</code>没有消失，只是指向了空地址<code>NULL</code></strong>。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启动U盘安装Ubuntu(单系统)</title>
      <link href="/2020/01/17/%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>/2020/01/17/%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>由于<strong>PE方式只适用于安装windows</strong>，因此选择常规的<strong>制作启动U盘</strong>进行Ubuntu的安装。</p><h3 id="操作系统镜像下载（桌面版，文件名后缀-iso-torrent）"><a href="#操作系统镜像下载（桌面版，文件名后缀-iso-torrent）" class="headerlink" title="操作系统镜像下载（桌面版，文件名后缀 .iso.torrent）"></a>操作系统镜像下载（桌面版，文件名后缀 .iso.torrent）</h3><ul><li>方式一：<a href="https://ubuntu.com/#download" target="_blank" rel="noopener">Ubuntu官网直接下载镜像</a></li><li>方式二：<a href="http://releases.ubuntu.com/18.04/" target="_blank" rel="noopener">Ubuntu官网下载镜像种子</a> + 迅雷下载镜像 （速度快，<strong>推荐</strong>）</li></ul><h3 id="3G及以上空间的U盘-移动硬盘-用于装载系统镜像"><a href="#3G及以上空间的U盘-移动硬盘-用于装载系统镜像" class="headerlink" title="3G及以上空间的U盘/移动硬盘(用于装载系统镜像)"></a><strong>3G及以上空间</strong>的U盘/移动硬盘(用于装载系统镜像)</h3><h3 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h3><ul><li><p>方式一：<strong>Windows 10 可以直接打开 iso镜像文件，不用下载任何工具</strong></p><ol><li><p>格式化U盘</p></li><li><p>双击ISO文件，然后选中打开的所有文件，复制到U盘即可</p></li></ol></li><li><p>方式二：<a href="http://rufus.ie/" target="_blank" rel="noopener">下载U盘制作制作工具Rufus</a>(<strong>无需安装，可直接运行</strong>)</p><ol><li><p>选择设备(需要被制作的U盘/移动硬盘)</p><ul><li>只有一个外接设备时会自动读取</li><li>如果<strong>外接设备是移动硬盘</strong>，需要<strong>显示高级设备选项 — 显示USB外置硬盘</strong></li></ul></li><li><p>选择操作系统镜像</p></li><li><p><strong>分区类型</strong>（<strong>理论上</strong>（联想Y480不知道为什么无法通过UEFI成功安装））</p><p><a href="https://www.bilibili.com/video/av45677113" target="_blank" rel="noopener">硬盘格式与引导方式、MBR与GPT、UEFI 与LEGACY bios的区别</a></p><ul><li><p>若选择GPT，之后系统安装时选择<strong>UEFI启动</strong>（<strong>推荐</strong>）</p></li><li><p>若选择MBR，之后系统安装时<strong>选择BIOS启动，否则报错</strong>（该模式一定能够安装成功）</p></li></ul></li><li><p>其余选项默认，点击<strong>开始</strong>，即可制作启动U盘</p></li></ol><p><img src="https://i.loli.net/2020/01/17/9KOmaTAQcIqdkpo.png" alt="Rufus制作启动U盘" style="zoom:80%;"></p></li></ul><hr><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol><li><p>重启电脑，进入<strong>选择启动方式界面</strong>（联想笔记本：F12；惠普笔记本：F9）</p></li><li><p>选择启动U盘</p><ul><li>想要安装系统的硬盘的格式为<strong>GPT</strong>，选择<strong>UEFI启动，即 EFI USB Device</strong></li><li>启动U盘分区类型为<strong>MBR</strong>，选择<strong>BIOS启动，即 选择对应的U盘</strong></li></ul></li><li><p>欢迎 — 中文 — 安装Ubuntu</p></li><li><p>键盘布局 — 汉语</p></li><li><p>无线 — 不连接</p></li><li><p>更新和其他软件 — <strong>最小安装</strong></p></li><li><p>安装类型 — 其他选项 — 进行分区</p><p>硬盘大小110GB</p><ul><li><p><strong>UEFI</strong>启动：</p><p>| 空间大小                    | 主分区/逻辑分区 | 类型                     |<br>| ————————— | ————— | ———————— |<br>| 200MB                       | <strong>逻辑分区</strong>    | <strong>EFI</strong>                  |<br>| 8GB<br>（和内存大小一致） | 主分区          | swap(交换)               |<br>| 40GB                        | 逻辑分区        | ext4<br>挂载至 “/”     |<br>| 剩余空间                    | 逻辑分区        | ext4<br>挂载至 “/home” |</p></li><li><p><strong>BIOS</strong>启动：</p><p>| 空间大小               | 主分区/逻辑分区 | 类型                |<br>| ———————- | ————— | ——————- |<br>| 200MB                  | <strong>主分区</strong>      | <strong>biosxx</strong>          |<br>| 8GB （和内存大小一致） | 主分区          | swap(交换)          |<br>| 40GB                   | 逻辑分区        | ext4 挂载至 “/”     |<br>| 剩余空间               | 逻辑分区        | ext4 挂载至 “/home” |</p></li></ul></li><li><p>完成安装，根据提示重启即可(可拔去启动U盘/硬盘，避免再次从启动U盘启动)</p></li></ol><hr><h2 id="将-从主服务器下载-更换为-国内镜像站点下载"><a href="#将-从主服务器下载-更换为-国内镜像站点下载" class="headerlink" title="将 从主服务器下载 更换为 国内镜像站点下载"></a>将 从主服务器下载 更换为 国内镜像站点下载</h2><p>​    显示应用程序 - 软件和更新 - Ubuntu软件 - 下载自 - 其他站点 - 选择最佳服务器（自动选择最合适的站点）</p><hr><h2 id="更新系统文件"><a href="#更新系统文件" class="headerlink" title="更新系统文件"></a>更新系统文件</h2><p><strong>打开终端</strong>的快捷键：<code>Ctrl</code>+<code>Alt</code>+<code>T</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><hr><h2 id="获得各种开发工具"><a href="#获得各种开发工具" class="headerlink" title="获得各种开发工具"></a>获得各种开发工具</h2><p><code>sudo apt-get install build-essential</code></p><ul><li><p>安装<strong>文字编辑器vim</strong>和<strong>浏览器chromium</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br><span class="line">sudo apt-get install chromium-browser</span><br></pre></td></tr></table></figure></li><li><p>树视图</p><p><code>sudo apt-get install tree</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmder</title>
      <link href="/2019/04/16/Cmder/"/>
      <url>/2019/04/16/Cmder/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载Cmder（压缩包，解压即用），有两种不同的版本可供选择：</p><ul><li>Mini</li><li>Full（附带msysgit工具）</li></ul><p>可根据设备是否已安装git自行选择</p><hr><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="添加系统环境变量"><a href="#添加系统环境变量" class="headerlink" title="添加系统环境变量"></a>添加系统环境变量</h3><p>我的电脑 - 右键属性 - 高级系统设置 - 环境变量 - 系统变量，在<code>Path</code>中添加Cmder路径</p><p><img src="https://i.loli.net/2019/04/16/5cb5a739330de.png" alt></p><hr><h3 id="添加Cmder到右键菜单"><a href="#添加Cmder到右键菜单" class="headerlink" title="添加Cmder到右键菜单"></a>添加Cmder到右键菜单</h3><ol><li><code>Win + R</code> - 输入<code>Cmder</code>，确认，打开Cmder</li><li>点击右下方的<code>Create new console</code></li><li>Startup command or {Task} name - {bash::bash}</li><li>Run as administrator</li><li>Start，即打开一个管理员权限的控制台 <img src="https://i.loli.net/2019/04/17/5cb6b470b7f0f.png" alt></li><li>输入 <code>Cmder.exe /REGISTER ALL</code>，回车。即可在每个文件夹中鼠标右键右键 - <code>Cmder here</code>，打开Cmder</li></ol><hr><h2 id="默认开启设置"><a href="#默认开启设置" class="headerlink" title="默认开启设置"></a>默认开启设置</h2><p>Cmder窗口右下角右键<code>Show system menu</code> - General - Choose your startup task or even a shell with arguments: - {bash::bash} - Save settings</p><p><img src="https://i.loli.net/2019/04/17/5cb6bbe028a30.png" alt></p><hr><h2 id="关闭Tab不提示"><a href="#关闭Tab不提示" class="headerlink" title="关闭Tab不提示"></a>关闭Tab不提示</h2><p>Cmder窗口右下角右键<code>Show system menu</code> - General - Confirm - Close confirmations下的复选框全不勾选 - Save settings</p><p><img src="https://i.loli.net/2019/04/17/5cb6bd25b23b6.png" alt></p><hr><p>参考：<a href="http://weikeqin.cn/2017/04/28/cmder-notes/" target="_blank" rel="noopener">Cmder 使用 笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dev-C++</title>
      <link href="/2019/04/16/Dev-Cpp/"/>
      <url>/2019/04/16/Dev-Cpp/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dev-C++是一个SourceForge的项目，<strong>早已停止更新</strong>。</p><p>缺点：</p><ul><li>分辨率低，脱节于屏幕素质的提升，使用感官不佳</li><li>中文注释容易乱码，且没有明显的选项用来修改编码格式</li></ul><hr><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>安装过程中的语言没有中文选项，选择English即可，按照默认选项安装。首次运行时，选择<strong>使用软件时的语言</strong>为简体中文即可，按照默认选项完成初运行配置。</p><hr><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul><li>菜单栏 - 工具 - 编辑器选项 - 语法 - 预设 - Obsidian 黑曜石主题</li></ul><p><img src="https://i.loli.net/2019/04/16/5cb598b4cba28.png" alt="工具 - 编辑器选项"></p><p><img src="https://i.loli.net/2019/04/16/5cb599bfef712.png" alt="语法 - 预设 - Obsidian 黑曜石主题"></p><ul><li><p>菜单栏 - 工具 - 编辑器选项 - 基本</p><ul><li style="list-style: none"><input type="checkbox" checked> 显示编辑器提示</li><li style="list-style: none"><input type="checkbox" checked> 显示函数提示</li><li>高亮显示当前行 - 色彩 - Black</li></ul><p><img src="https://i.loli.net/2019/04/16/5cb59bb680afc.png" alt></p></li></ul><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>菜单栏 - 工具 - 编辑器选项 - 显示 - 字体 - YaHei Consolas Hybrid</p><p>字体下载： <a href="https://pan.baidu.com/s/1kldCHl7A5SIZaCLJniLzwQ" target="_blank" rel="noopener"><a href="https://pan.baidu.com/s/1kldCHl7A5SIZaCLJniLzwQ" target="_blank" rel="noopener">Consolas和微软雅黑混合字体</a></a></p><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>自动整理代码</td><td>Ctrl + Shift + A</td></tr><tr><td>代码补全</td><td>Ctrl + Space(<strong>和输入法切换快捷键冲突</strong>)</td></tr></tbody></table><p>自定义快捷键：工具 - 快捷键选项 - 菜单项的底部 - Show Code Completion(代码补全)，自定义即可。</p><hr><h2 id="添加-C99-C-11-标准"><a href="#添加-C99-C-11-标准" class="headerlink" title="添加 C99/C++11 标准"></a>添加 C99/C++11 标准</h2><p>工具 - 编译选项 - 编译时加入以下命令 - <code>-std=c99</code>或<code>-std=C++11</code></p><p><img src="https://i.loli.net/2019/04/16/5cb59e4d63a98.png" alt></p><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”"><a href="#初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”" class="headerlink" title="初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”"></a>初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”</h3><p>菜单栏 - 工具 - 编译选项 - 代码生成/优化 - 连接器 - 产生调试信息 - Yes</p><p><img src="https://i.loli.net/2019/04/17/5cb6d8b4f11b0.png" alt></p><h3 id="调试窗口查看变量的实时数据"><a href="#调试窗口查看变量的实时数据" class="headerlink" title="调试窗口查看变量的实时数据"></a>调试窗口查看变量的实时数据</h3><p>开启调试后，有三种方式可以查看变量的实时数据：</p><ol><li>左侧调试窗口 - 空白处鼠标右键 - 添加查看</li><li>下侧调试窗口 - 添加查看</li><li>代码界面鼠标在变量名处停留，会显示当前变量值</li></ol><p><img src="https://i.loli.net/2019/04/17/5cb6dc99352a7.png" alt></p><hr><p>参考：</p><ul><li><del><a href="https://ice1000.org/2016/10/28/DevCpp/" target="_blank" rel="noopener">如何正确使用 DEV C++</a></del></li><li><a href="https://blog.csdn.net/MonkeyWang98/article/details/80202024" target="_blank" rel="noopener">DEV-C++调试时出现“项目没有调试信息，你想打开调试选项并重新生成吗”</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dev-C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>香港两日半 | 不妨长作岭南人</title>
      <link href="/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/"/>
      <url>/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="情之所起"><a href="#情之所起" class="headerlink" title="情之所起"></a>情之所起</h2><p>说起香港，脑海中闪过的第一个念头就是《重庆森林》——重庆大厦里奔走的林青霞、趴在半山扶梯上窥看编号633住处的王菲和她哼唱的《California Dreamin’》。终于要去见识这个憧憬太久的目的地了啊。</p><p>准备用完整的两天时间游览香港，从杭州出发，在三种方案中做选择： </p><ol><li>飞机直飞香港 （香港机场，位置较偏，根据实时价格、抵达时间综合考虑）</li><li>高铁直达香港（西九龙高铁站，高价、抵达时间深夜）</li><li>火车到<strong>深圳站</strong>，无缝衔接<strong>罗湖关口</strong>（硬卧￥360+ ~ ￥400，当天下午出发，隔天早上6点多或8点多抵达深圳站）</li></ol><p>由于勤(shi)俭(ge)节(qiong)约(bi)，同时为了能最大化利用在港时间，选择了方案3，买了03月19日的15:17杭州东站出发的T101次硬卧中铺，03月20日08:15抵达深圳站。03月22日16:00深圳站返程。</p><p>以及如下准备：  </p><ul><li style="list-style: none"><input type="checkbox" checked> 带上身份证去办港澳通行证（￥80）+ 香港团队旅游签注（￥15，<strong>现在团签可自助过关，与个签没有分别</strong>；7个工作日出证）  </li><li style="list-style: none"><input type="checkbox" checked> 去中国银行兑换1000港币  </li><li style="list-style: none"><input type="checkbox" checked> 买好路上的干粮</li><li style="list-style: none"><input type="checkbox" checked> 备好北纬22°所需衣物</li><li style="list-style: none"><input type="checkbox" checked> 预订酒店（一般酒店都备有转换插头，无需自带）</li><li style="list-style: none"><input type="checkbox" checked> 根据个人需求：淘宝买香港的x日电话卡；或在手机自带的全球上网一类app上购买流量包</li></ul><p><strong>冲冲冲！</strong></p><hr><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p>一夜的火车，从北纬30°到北纬22°，20+℃的气温暗示着夏天的气息。换上短袖，跟着指示牌前往关口。</p><p><img src="https://i.loli.net/2019/03/27/5c9b65af74dc6.jpeg" alt="标识牌"></p><p><img src="https://i.loli.net/2019/03/29/5c9db75b6307e.jpeg" alt="标识牌"></p><p>自助过关，机器读取港澳通行证，人脸+指纹识别后出内地关口，再经香港的检查人员核实身份后，即可入关。</p><p><img src="https://i.loli.net/2019/03/29/5c9db7a38f91a.jpeg" alt="自助查验标识"></p><p><img src="https://i.loli.net/2019/03/29/5c9db7cb6463a.jpeg" alt></p><p><img src="https://i.loli.net/2019/03/29/5c9db7e0dd89f.jpeg" alt></p><p>过关之后，先去柜台办了一张八达通，把1000港币破开。接着跟着标识牌去羅湖站坐港铁MTR。上了地铁以后，一看手机果然没有信号了，启用购买的流量包，在墙外的Internet上尽情呼吸。</p><h3 id="第一站-大學"><a href="#第一站-大學" class="headerlink" title="第一站 大學"></a>第一站 大學</h3><p><img src="http://p1-q.mafengwo.net/s13/M00/D4/7C/wKgEaVybmLqAcKOZAAj0436BHXM79.jpeg" alt="大學站"></p><p>大學站所指的大學是<strong>香港中文大學</strong>，一出地铁站就可以出现在校园之内。在香港中文大學可以初窥香港的地形，依山而建、高低错落，似极了重庆，对重庆曾经的小香港别称有了一丝恍然。来香港中文大學主要是为了打卡景点<strong>天人合一</strong>，顺便感受一下高等学府的环境与氛围。</p><p>校内有免费大巴可以乘坐，坐上可到<strong>新亚学院</strong>的车次，天人合一便只有几步之遥。</p><p>我以为能拍到的天人合一 和 我实际上拍到的天人合一……</p><p><img src="http://p2-q.mafengwo.net/s13/M00/15/90/wKgEaVybrXWAEF5lAA2DIiXf-E829.jpeg" alt="天人合一"></p><p>校园角落：</p><p><img src="http://p3-q.mafengwo.net/s13/M00/DA/16/wKgEaVybm9-AOh6xABCfboRpnSc44.jpeg" alt></p><p><img src="http://n3-q.mafengwo.net/s13/M00/DA/1C/wKgEaVybm-KAckzIAA5ElX33Oes68.jpeg" alt></p><p><img src="http://n4-q.mafengwo.net/s13/M00/DA/22/wKgEaVybm-WAPVXZABLFqn7fKRA87.jpeg" alt="头脑特工队"></p><p><img src="http://n1-q.mafengwo.net/s13/M00/DA/2A/wKgEaVybm-mAenGvABy4pAOS__I08.jpeg" alt="巴士站点的宝可梦装饰"></p><p><img src="https://i.loli.net/2019/03/29/5c9dba427e1d0.jpeg" alt="校园里很容易发现的宝可梦元素"></p><p><img src="http://p3-q.mafengwo.net/s13/M00/D5/6A/wKgEaVybmUaAOfqXAB-iQlRulA098.jpeg" alt></p><p>香港的车道上总会印着慢駛，斑马线上总会印着望左或望右，当我们在说城市的人文关怀的时候，我们在说什么：</p><p><img src="https://i.loli.net/2019/03/29/5c9dbd1e0f31c.jpeg" alt></p><p><img src="http://b1-q.mafengwo.net/s13/M00/D5/51/wKgEaVybmT2AWbyIAB88o5XJexk61.jpeg" alt="img"></p><hr><h3 id="第二站-彩虹"><a href="#第二站-彩虹" class="headerlink" title="第二站 彩虹"></a>第二站 彩虹</h3><p><img src="http://b4-q.mafengwo.net/s13/M00/DA/EC/wKgEaVybnGiATIJBABrUlqkj9j080.jpeg" alt="彩虹站"></p><p>逛完香港中文大學之后，继续坐上开往紅磡方向的東鐡綫，经由九龍塘换乘开往調景嶺方向的觀塘綫，在彩虹站下车，C3/C4口出站，<del>跟着感觉走就到了打卡点</del>跟着导航找到一个三层的<strong>停车楼</strong>，走上楼就到了彩虹邨的天台球场打卡点。</p><p><img src="http://n4-q.mafengwo.net/s13/M00/21/3A/wKgEaVyYpPWASCoxABbKpJXZH7g06.jpeg" alt></p><p>坪石邨就在彩虹邨附近，一并打卡。</p><p><img src="http://p2-q.mafengwo.net/s13/M00/21/47/wKgEaVyYpQKAX3IQABkI976-WGg74.jpeg" alt></p><hr><h3 id="第三站-旺角"><a href="#第三站-旺角" class="headerlink" title="第三站 旺角"></a>第三站 旺角</h3><p><img src="http://p1-q.mafengwo.net/s13/M00/DD/68/wKgEaVybnhWAfe3tAA8QRIHaSp453.jpeg" alt></p><p>预订的酒店在旺角站附近的新興大厦，12点多到酒店登记，接待的前台一口甜软的台湾腔，仿佛服务上升了一个台阶，因为两点之后房间才能清理好，把行李暂存到前台之后出门觅食。</p><p>奥海城有一家轮胎一星的添好運点心专门店，有点路，但也可以顺便熟悉一下市区，就慢慢摇过去。香港的红绿灯还有喇叭播放的摇铃提醒，通过不同的节奏来提供听觉上的交通信号。当我们在说城市设计的时候，我们在说什么。这家添好運不在商场内部，而是外围的街边店，用普通话取了号，但店员在叫号的时候只用粤语，结果就过号了Orz…最终跟另外一家口拼了一桌，得以入座。点了酥皮叉烧包、虾饺、牛肉肠粉，满足。</p><p>吃完之后，去逛香港特色的“二楼书店”。寸土寸金的香港，小众的个体书店隐匿于窄小楼梯通往的上层楼层，西洋菜街分布着多家二楼书店，这个时候导航显得十分无力<del>，果然还是要跟着感觉走</del>。有一定年头的旧式电梯和陈旧的楼道已经相辅相成，一迈进逼仄的楼道，隔着喧闹的街市，年代感迎面而来。</p><p>走在街道上，正巧看到宣扬法轮功和抵制邪教的横幅只有一布之隔，各自发声。下意识感慨神奇，心生羡慕。</p><p>最终在商务印书馆找到了想买的书，外面世界的书真不便宜。如果国内能出版的话，最多￥30+应该就能买到，不过可以理解成出版自由的附加值来抚慰自己，以及感谢支付宝的境外推广活动。</p><h3 id="第四站-尖沙咀"><a href="#第四站-尖沙咀" class="headerlink" title="第四站 尖沙咀"></a>第四站 尖沙咀</h3><p>逛完书店，回到住处入住了房间。躺下来补充一下体力之后，出门地铁前往尖沙咀。因为一心想趁着天还亮着，去拍香港文化中心，没有注意就在尖沙咀站附近的重庆大厦。走了一段距离，就走到了香港文化中心。</p><p>维港一瞥：</p><p>然后由西到东走了一遍星光大道，走马观花了一遍著名港星的手印和简介。麦兜作为出现在星光大道上的唯一卡通形象，“木有鱼丸，木有粗面”的麦兜在香港的地位可见一斑，虽然是在愚人节之前来香港，但猪年看到出乎意料的麦兜也算应景。</p><p>逛完了星光大道，想着走回尖沙咀站打卡重庆大厦。走进重庆大厦，一股闷热感和走动的印度面孔让人感慨电影中的重庆大厦的相关画面，但如今与当初相比，治安和清洁方面该是好了很多，其中实在逛无可逛。看了下地图，发现恰好有一家蘭芳園在重庆大厦负一层。但是不能被重庆大厦的入口所迷惑，因为走进重庆大厦的正门却没有走到负一层的路。只需在街道上往北走上几步路，就能看到地下入口。</p><p>点了丝袜奶茶和猪扒包</p><p>一起拼桌的两位，一位是港人、一位是白人，两人用粤语无障碍交流着，在个别词汇无法表达时，会夹杂着些许英语。在香港这样一个文化如此多元的地域，你很难不被多元的语言交流所感染。正吃着饭，一位内地游客看着我们这桌有一张空着的凳子，便用普通话问白人小哥：“这个位置有人坐吗？”白人小哥停下交流，回头一瞥，同样用普通话回答道：“呃…没有。”不禁感叹白人小哥真的有、东西。吃完晚饭，准备起身结账时，不小心撞了一下桌子，把拼桌两位的饮料洒了一些出来，脑海中瞬间闪过一个念头：“我该说sorry还是对唔住还是唔好意思？”结果怂怂地用普通话说了两句：“不好意思”…</p><p>吃完饭出来天色已暗，不逛诚品，不足以谈人生？诚品书店名声在外，听了太多年，正好海港城有分店，就去逛了逛。逛过之后，才明白逛诚品书店为什么能消磨时间，想来算是个商场中的商场。</p><h3 id="第五站-跑馬地赛马场"><a href="#第五站-跑馬地赛马场" class="headerlink" title="第五站 跑馬地赛马场"></a>第五站 跑馬地赛马场</h3><p>逛完诚品，走向天星碼头，坐天星小轮到对岸，再去跑馬地馬场看每周三的赛马。原本想坐到湾仔碼头（莫名想吃水饺…），一不留神坐上了去往中环碼头的轮渡。</p><p>在天星小轮上一赏维港夜景：</p><p>到达对岸之后，前往公交站，坐上去跑馬地馬场的巴士。到站后发现，票价港币$10的<strong>公众入口只有G口</strong>，还需要往南走上一段路。刷八达通即可入场感受人声鼎沸、灯火通明的香港赌马文化。其中酒水餐饮一应俱全，不得不感叹赛马的魅力。</p><h3 id="第六站-廟街"><a href="#第六站-廟街" class="headerlink" title="第六站 廟街"></a>第六站 廟街</h3><p>看完一场赛马之后，准备坐巴士去廟街。巴士的站点正好在一座印度廟前，正好遇到当天仪式的印度人一家又一家地从中走出，再次感叹文化的多元。廟街不如想象中的热闹，想到极限挑战好想在这里取过景。一家家街角的大排档确实有让人想一尝的想法，但是单人旅途确实和大排档不合适。笔直的廟街中间是搭起棚子的贩卖各色饰品、服装、玩具纪念品的小摊贩，两侧的商铺则有形形色色的食铺、覆上帘子的成人影片店铺，还能看到几位穿着暴露的性服务者… 最后，找到了拍廟街远景的停车楼，我想象中能拍到的廟街 和 我实际上拍到的廟街：</p><p>在麥文記麺家吃了一碗云吞面作宵夜，好像就是running man去吃过的那家。</p><p>走了3万步的一天终于结束了…</p><hr><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h2><h3 id="第七站-翠园金華冰厅"><a href="#第七站-翠园金華冰厅" class="headerlink" title="第七站 翠园金華冰厅"></a>第七站 <del>翠园</del>金華冰厅</h3><p>原本想去翠园（旺角新世纪广场店）吃早茶，在路上找到一片涂鸦墙，真好啊。</p><p>10点多找到店铺后，排号的人已不少，感觉不一定能在11：30前的早茶时间吃完，遂作罢。正好发现金華冰厅就在附近，<del>屁颠屁颠</del>走到店里，点了菠萝油和冻奶茶，菠萝油也太好吃了8？！</p><h3 id="第八站-香港大學"><a href="#第八站-香港大學" class="headerlink" title="第八站 香港大學"></a>第八站 香港大學</h3><p>Pillar of Shame</p><h3 id="第九站-半山扶梯"><a href="#第九站-半山扶梯" class="headerlink" title="第九站 半山扶梯"></a>第九站 半山扶梯</h3><p>原本应该从香港大學出发去卢吉道，但是Google地图用不惯……高德的导航没有给出一个合适的路线，只好曲线救国，先去打卡半山扶梯。</p><p>太平山街周边的涂鸦</p><p>拍了皇后大道、皇后大道西、皇后大道中，最后没有去打卡一下皇后大道东，<del>算了反正都没有皇宫</del>。</p><p>想不起来是先去吃的翠華餐廰还是先逛的半山扶梯。去翠華吃了咖喱牛腩饭和冻鸳鸯。</p><p>半山扶梯</p><h3 id="第十站-太平山顶"><a href="#第十站-太平山顶" class="headerlink" title="第十站 太平山顶"></a>第十站 太平山顶</h3><p><del>智障级徒步曲线爬坡，无数次感慨这就是重庆地形</del>登上凌霄阁观景台，真真正正的一滴都没有了。走了一段卢吉道，回想李尚敏坐红眼航班登卢吉道看香港日出的片段之后，排队缆车下山。</p><h3 id="第十一站-幻彩咏香江"><a href="#第十一站-幻彩咏香江" class="headerlink" title="第十一站 幻彩咏香江"></a>第十一站 <del>幻彩咏香江</del></h3><p>坐巴士去再興燒臘飯店，点了叉烧饭和鱼蛋菜汤。鱼蛋菜汤加了猪油，味道香浓。最后光盘行动…得到了老板娘“好靓仔”的夸奖…</p><p>拖着一滴都没有了的残躯，想去湾仔碼头的观景台看夜景。在8点过几分之后到达，发现是幻彩咏香江的盲区…香港岛这一侧的灯光是主体部分，在湾仔碼头却完美地被建筑遮挡，无法看到。后来发现就在碼头左侧的金紫荆广场应该是香港岛这一侧的优质观景位置。金紫荆广场上有着许多的香港动漫人物的塑像，如步惊云、陈浩南及许多卡通式人物，和对岸的星光大道有遥相呼应的味道。</p><p>从湾仔站打道回府，结束因徒步太平山而被掏空的一天…</p><hr><h2 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h2><h3 id="第十二站-翠园早茶"><a href="#第十二站-翠园早茶" class="headerlink" title="第十二站 翠园早茶"></a>第十二站 翠园早茶</h3><p>稍微比昨天早一点到了翠园，取号之后马上被叫到了号，如愿以偿吃上早茶。龙井+凤爪+豉汁蒸排骨+瑶柱灌汤饺。我对茶餐厅真的没有抵抗力啊…</p><h3 id="第十三站-买买买"><a href="#第十三站-买买买" class="headerlink" title="第十三站 买买买"></a>第十三站 买买买</h3><p>找了一家卖美国保健品的店铺，其中一个店员只会粤语和英语，结账时，为脑子里能出现checkout而感到欣慰… 赶在12点的退房时间前整理好行李退房 。屈臣氏、万宁、莎莎、卓悦等等不表…</p><h3 id="第十四站-重回香港中文大學"><a href="#第十四站-重回香港中文大學" class="headerlink" title="第十四站 重回香港中文大學"></a>第十四站 重回香港中文大學</h3><p>买好必需品后，乘上返程的地铁，想着适合解决午饭的地点。于是又回到开始的地方，轻车熟路去了众志堂食堂，自助点餐冻柠茶+烧味双拼饭后，八达通付款，吃完了在香港的最后一顿，Happy Ending。</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>过关安检、15:00进深圳站。返程的火车上，一群上海老年旅游团好不闹热，其乐融融的气氛能很好地感染他人。</p><p>遇到一个在义乌做生意的60岁韩国大叔。用我蹩脚的韩语+英语表达了我对running man、无限挑战、2天1夜的喜爱之情，尝了他分享的海苔。大叔说自己在中国吃面只吃打着新疆招牌的面和温州海鲜面哈哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优雅使用Windows 10</title>
      <link href="/2019/03/18/%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8Windows-10/"/>
      <url>/2019/03/18/%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8Windows-10/</url>
      
        <content type="html"><![CDATA[<h2 id="桌面效果图"><a href="#桌面效果图" class="headerlink" title="桌面效果图"></a>桌面效果图</h2><p><img src="https://i.loli.net/2019/03/28/5c9c986753d63.png" alt="Win 10桌面"></p><hr><h2 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h2><ul><li>PDF阅读器： <a href="https://www.gaaiho.com/index.php/zh-cn/products/reader/pdf-reader-pc/overview" target="_blank" rel="noopener">文电通PDF阅读器</a></li><li>视频播放器：<a href="https://daumpotplayer.com/download/" target="_blank" rel="noopener">PotPlayer</a></li><li>广告拦截：<a href="http://www.admflt.com/" target="_blank" rel="noopener">阿呆喵</a></li><li>解压缩软件：<a href="https://cn.bandisoft.com/bandizip/" target="_blank" rel="noopener">Bandizip</a></li><li>百度网盘全速下载：<a href="https://pandownload.com/" target="_blank" rel="noopener">PanDownload</a></li><li>UWP：DailyPic(Bing的每日壁纸，可选择性下载中意的壁纸作为桌面背景)</li></ul><hr><h2 id="系统速度优化"><a href="#系统速度优化" class="headerlink" title="系统速度优化"></a>系统速度优化</h2><p><code>Ctrl + alt + Esc</code>打开任务管理器 - 启动 - 选择需要禁用的开机启动项</p><hr><h2 id="任务栏透明化"><a href="#任务栏透明化" class="headerlink" title="任务栏透明化"></a>任务栏透明化</h2><p>Microsoft Store下载<strong>TranslucentTB</strong>，启动。</p><ul><li><strong>Open at boot</strong>(开机启动)</li><li><strong>Regular - Clear</strong>（常规 - 透明）</li></ul><hr><h2 id="滑动关机"><a href="#滑动关机" class="headerlink" title="滑动关机"></a>滑动关机</h2><ol><li><code>Win + S</code>唤出Cortana，搜索<code>SlideToShutdown</code>，选择打开文件位置</li><li>右键 - 发送到 - 桌面快捷方式</li><li>右键 - 属性 - 快捷键，自定义滑动关机快捷键，如<code>Ctrl + Alt + 1</code></li><li>如果想将滑动关机固定到任务栏，见<a href="#Win-10-风格图标">Win 10 风格图标</a></li></ol><hr><h2 id="Win-10-风格图标"><a href="#Win-10-风格图标" class="headerlink" title="Win 10 风格图标"></a>Win 10 风格图标</h2><p>注：仅适用于PC端软件，UWP应用不可用。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>图标素材网站：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>；<a href="https://www.easyicon.net/" target="_blank" rel="noopener">easyicon</a></li><li>PNG格式图标在线转为ico格式图标网站：<a href="https://www.easyicon.net/covert/" target="_blank" rel="noopener">iconvert</a></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>找到需要转换图标的软件快捷方式（如果不是快捷方式，右键 - 发送到 - 桌面快捷方式，统一进行转换）</li><li>在素材网站筛选合适的图标，选择下载<strong>白色</strong>的PNG格式图标</li><li>将图标转为ico格式，下载统一存放（便于管理）</li><li>右键软件快捷方式 - 属性 - 更改图标 - 浏览 - 在ico图标存放地址选择相应图标 - 确定</li><li>右键软件快捷方式 - 固定到任务栏</li><li>删除桌面上的软件快捷方式</li></ol><hr><h2 id="任务栏图标居中"><a href="#任务栏图标居中" class="headerlink" title="任务栏图标居中"></a>任务栏图标居中</h2><ol><li>桌面新建文件夹</li><li>右键任务栏空白处 - <strong>取消勾选</strong>锁定任务栏</li><li>右键任务栏空白处 - 工具栏 - 新建工具栏 - 选择桌面新建的文件夹</li><li>向左拖动新建的工具栏，将应用程序栏挤到右侧</li><li>右键新建的工具栏 - <strong>取消勾选</strong> 显示文本 和 显示标题</li><li>将应用程序栏拖拽到合适的位置后，锁定任务栏</li></ol><hr><h2 id="桌面的系统相关图标隐藏"><a href="#桌面的系统相关图标隐藏" class="headerlink" title="桌面的系统相关图标隐藏"></a>桌面的系统相关图标隐藏</h2><p><code>Win + i</code>打开设置 - 个性化 - 主题 - 相关的设置 - 桌面图标设置 - 取消勾选相应图标即可隐藏</p><hr><h2 id="资源管理器像浏览器一样使用Tab标签页"><a href="#资源管理器像浏览器一样使用Tab标签页" class="headerlink" title="资源管理器像浏览器一样使用Tab标签页"></a>资源管理器像浏览器一样使用Tab标签页</h2><ol><li>下载安装<a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener">QTTabBar</a></li><li><code>Win + E</code>打开资源管理器，查看 - 选项 - 勾选GTTabBar(注：选项按钮上方的默认图形只是选项的其中一项，<strong>需点击选项文字</strong>)，此时资源管理器就多出了标签栏</li><li>右键标签栏空白处 - QTTabBar Options - General - Download language file - 选择更新日期较近的简体中文（注：<strong>下载语言文件需要科学上网</strong>，附<a href="https://pan.baidu.com/s/1mc2Ubnh5JfEoELu5EnIKTg" target="_blank" rel="noopener">百度网盘资源</a>）- apply即可汉化</li><li>标签栏的”+”按钮默认为<strong>浏览文件夹并打开新标签</strong>，比较麻烦。右键标签栏空白处 - QTTabBar 选项 - 鼠标事件 - 标签和标签栏 - 点击标签栏的”+”按钮 - 用户命令 - 创建一个新命令 - 命令的类型 - 文件和文件夹 - 路径（根据个人喜好选择默认打开路径）</li><li>按照个人喜好调整功能</li></ol><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">Win + 数字</td><td style="text-align:left">对应任务栏从左到右固定的程序</td></tr><tr><td style="text-align:left">Win + A</td><td style="text-align:left">通知中心</td></tr><tr><td style="text-align:left">Win + L</td><td style="text-align:left">锁屏</td></tr><tr><td style="text-align:left">Win + D</td><td style="text-align:left">回到桌面/当前界面</td></tr><tr><td style="text-align:left">Win + R</td><td style="text-align:left">打开运行窗口：<br>1. cmder：命令行<br>2. regedit：注册表<br>3. services.msc：服务</td></tr><tr><td style="text-align:left">Win + W</td><td style="text-align:left">WINDOWS INK 工作区</td></tr><tr><td style="text-align:left">Win + - ( + )</td><td style="text-align:left">放大镜</td></tr><tr><td style="text-align:left">Win + Q/S</td><td style="text-align:left">Cortana</td></tr><tr><td style="text-align:left">Win + E</td><td style="text-align:left">文件资源管理器</td></tr><tr><td style="text-align:left">Win + I</td><td style="text-align:left">Windows 设置</td></tr><tr><td style="text-align:left">Win + K</td><td style="text-align:left">蓝牙</td></tr><tr><td style="text-align:left">Ctrl + Alt + Esc</td><td style="text-align:left">任务管理器</td></tr><tr><td style="text-align:left">Win + Ctrl + ⬅/➡</td><td style="text-align:left">切换至相邻的虚拟桌面</td></tr><tr><td style="text-align:left">Win + Shift + S</td><td style="text-align:left">可框选截图</td></tr><tr><td style="text-align:left">Win + Printscreen</td><td style="text-align:left">全屏截图</td></tr><tr><td style="text-align:left">Win + Pause Break</td><td style="text-align:left">系统</td></tr></tbody></table><hr><h2 id="触摸板手势"><a href="#触摸板手势" class="headerlink" title="触摸板手势"></a>触摸板手势</h2><table><thead><tr><th>手势</th><th>功能</th></tr></thead><tbody><tr><td>单指点击两次 + 拖动</td><td>多选</td></tr><tr><td>两指拖动</td><td>滚动页面</td></tr><tr><td>两指捏合</td><td>缩放</td></tr><tr><td>三指上滑</td><td>多任务视图</td></tr><tr><td>三指下滑</td><td>显示桌面</td></tr><tr><td>三指左右滑动</td><td>切换应用</td></tr><tr><td>三指单击</td><td>唤出Cortana</td></tr><tr><td>四指单击</td><td>通知中心</td></tr><tr><td>四指左右滑动</td><td>切换虚拟桌面</td></tr></tbody></table><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/yourng/article/details/83013726" target="_blank" rel="noopener">QTTabBar 简单配置</a></li><li><a href="https://sspai.com/post/45594" target="_blank" rel="noopener">Windows 虚拟桌面的高效启动技巧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新笔记本电脑验机</title>
      <link href="/2019/03/18/%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E9%AA%8C%E6%9C%BA/"/>
      <url>/2019/03/18/%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E9%AA%8C%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>准备：下载<strong>卡硬工具箱免安装版</strong>至U盘或其他移动设备。</p><p><strong>以下任何一步有问题，退货。</strong></p><ol><li>检查笔记本外壳是否有<strong>指纹、裂痕、凹陷</strong>，机身是否有<strong>变形</strong>，屏幕是否<strong>完好</strong>。</li><li>USB接口是否有抽插痕迹。</li><li><strong>不插电源，直接按电源键</strong>，若<strong>能开机，则很可能是二手</strong>。</li><li>插上电源，按电源键开机。</li><li>进入系统，系统初始化设置（<strong>若没有设置界面，直接进入了系统，二手</strong>）。</li><li><strong>不连接网络</strong>，防止后续检查有问题无法退货。</li><li>进入桌面后，插上有卡硬工具箱的U盘。<ol><li>显示器工具 - 检测屏幕坏点。</li><li>硬盘工具 - Diskinfo - 检查通电次数和通电时间（<strong>一般通电时间在24小时内，通电次数在150次以内，可以判定为新机硬盘</strong>）。</li></ol></li></ol><p><strong>上述步骤没有出现问题后，依然不要联网，在无理由退货时间内使用电脑，以便后续使用不满意时方便退货。</strong></p><hr><p>参考：<a href="https://zhuanlan.zhihu.com/p/40181275" target="_blank" rel="noopener">笔记本电脑验机指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 验机与续命 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 验机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联想Y480拆机清灰</title>
      <link href="/2019/03/18/%E8%81%94%E6%83%B3Y480%E6%8B%86%E6%9C%BA%E6%B8%85%E7%81%B0/"/>
      <url>/2019/03/18/%E8%81%94%E6%83%B3Y480%E6%8B%86%E6%9C%BA%E6%B8%85%E7%81%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="彻底拆机清灰（涂硅脂、更换）"><a href="#彻底拆机清灰（涂硅脂、更换）" class="headerlink" title="彻底拆机清灰（涂硅脂、更换）"></a><a href="http://ideapad.it168.com/thread-5334703-1-1.html" target="_blank" rel="noopener">彻底拆机清灰</a>（涂硅脂、更换）</h2><h2 id="清理键盘"><a href="#清理键盘" class="headerlink" title="清理键盘"></a>清理键盘</h2><ol><li>键盘在D面有<strong>两个螺丝固定</strong>，先卸下D面挡板，再卸下键盘螺丝、固定光驱的螺丝。</li><li>按照彻底拆机的拆卸键盘方法即可取下键盘。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 验机与续命 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拆机 </tag>
            
            <tag> 清灰 </tag>
            
            <tag> 保养 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑屏幕色差矫正</title>
      <link href="/2019/03/18/%E7%94%B5%E8%84%91%E5%B1%8F%E5%B9%95%E8%89%B2%E5%B7%AE%E7%9F%AB%E6%AD%A3/"/>
      <url>/2019/03/18/%E7%94%B5%E8%84%91%E5%B1%8F%E5%B9%95%E8%89%B2%E5%B7%AE%E7%9F%AB%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<ul><li>电脑屏幕色彩管理软件：LUT Manager</li><li>MAC自带的颜色配置文件：MAC.icc</li><li>适用系统：Windows  </li></ul><hr><ol><li>下载<a href="https://pan.baidu.com/s/1p1jvs2lUirS_KbFI7T7w4g" target="_blank" rel="noopener">LUT Manager和MAC.icc</a></li><li>将MAC.icc放到<code>系统盘/windows/system32/spool/drivers/color/</code>目录下</li><li>打开控制面板（查看方式-图标）- 颜色管理 - 高级 - 更改系统默认值 - 高级 - 使用Windows显示器校准 - 关闭</li><li>设备 - 显示器 - 使用我对此设备的设置 - 添加 - 选择MAC.icc - 设置为默认配置文件 - 关闭</li></ol><hr><p>参考：<a href="https://www.mooyuu.com/school/985/#downs" target="_blank" rel="noopener">矫正色差的软件</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 屏幕色差 </tag>
            
            <tag> LUT Manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE方式安装Windows 10</title>
      <link href="/2019/03/18/PE%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Windows-10/"/>
      <url>/2019/03/18/PE%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Windows-10/</url>
      
        <content type="html"><![CDATA[<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>可以更改硬盘格式与引导方式</li><li>可以备份原有系统的数据</li><li>自带修复软件，可以在不重装系统的情况下修复系统</li></ol><hr><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>PE安装工具下载：<a href="http://www.wepe.com.cn/download.html" target="_blank" rel="noopener">微PE工具箱</a></li><li>操作系统镜像下载：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN</a></li><li><strong>8G及以上空间</strong>的U盘/移动硬盘(主要用于存放系统镜像)</li></ul><hr><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol><li><p>安装PE到U盘/移动硬盘</p></li><li><p>将操作系统镜像放到U盘（或移动硬盘对应的存储分区）</p></li><li><p>重启电脑，进入<strong>选择启动方式界面</strong>（联想笔记本：F12；惠普笔记本：F9）</p></li><li><p>选择PE所在设备，即启动PE</p></li><li><p>启动桌面上的<strong>Windows安装器</strong>：</p><ul><li><p>第一行：选择操作系统镜像文件</p></li><li><p>第二行（选择引导驱动器）：想要安装系统的硬盘的格式（<a href="https://www.bilibili.com/video/av45677113" target="_blank" rel="noopener">硬盘格式与引导方式、MBR与GPT、UEFI 与LEGACY bios的区别</a>）不同，需要选择的盘区也不同。</p><ol><li>GPT格式：选择ESP分区（大约90~250MB大小的一个隐藏盘区）</li><li>MBR格式：选择要装系统的盘区即可</li></ol><p><strong>两种方式都需要右边的三个指示灯不为红色（黄绿两色OK）</strong></p></li><li><p>第三行（安装磁盘的位置）：选择系统将要安装的盘区即可。</p></li><li><p>第四行：选择安装的Win 10版本。</p></li></ul><p>完成以上四行内容即可点击开始安装。</p><p>​    注：用 DiskGenius 格式化硬盘/转换硬盘格式 时记得勾选<strong>对齐分区到此扇区数的整数倍</strong>（即4K对齐，无需修改具体参数）。</p></li><li><p>重启系统，进行Win 10的初始化设置，<strong>建议进入桌面后再联网</strong>，操作过程会快一些。</p></li></ol><hr><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><p>去官网下载驱动安装，或者下载<strong>驱动精灵免安装版</strong>安装驱动（另外，Windows自身的更新会下载部分相关驱动）。</p><p>注：部分<strong>旧机型</strong>官网没有Windows10版本的相关驱动，不建议官网下载相关旧驱动，很可能不兼容。直接使用驱动精灵无脑安装基本驱动即可。</p><p>注注：博主的老机子联想Y480的触摸板在驱动精灵中没有相关的驱动，无法使用Win10的触摸板手势，但是<strong>鲁大师的驱动检测功能下可以看到触摸板驱动，选择升级即可使用手势</strong>。博主猜测此方法同样适用于部分老机型，不得不赞美一下娱乐大师。</p><p>注注注：Elitebook 830 G5的固态硬盘是三星的PM961，需要加上Turbo驱动提速，官网没有直接的链接，可以通过驱动精灵安装。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/av45170351" target="_blank" rel="noopener">Win 10全面官方装系统教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的基本概念</title>
      <link href="/2018/07/18/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/07/18/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>传统的C语言用法中，变量名使用小写字母，符号常量名使用大写字母</p><hr><h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符signed与unsigned可以用于<strong>限定char类型或任何整型</strong>。</p><ul><li><code>signed</code> （默认）<br>如char类型 <code>signed char</code>，取值范围为-128~127</li><li><code>unsigned</code> （<strong>无符号类型</strong>）<br>总是正值或0，例如char类型，<code>unsigned char</code> 取值范围为0~255</li></ul><hr><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><ul><li><p><strong>方法一： const 数据类型 变量名 = 常量；</strong>（<strong>推荐</strong>）</p><p>例： <code>const int AMOUNT=100;</code></p><p><code>const</code>也能配合<strong>数组参数</strong>使用，表明函数不能修改数组元素的值。</p></li><li><p><strong>方法二：#define 标识符 常量</strong><br><strong>末尾没有分号</strong><br>例：<code>#define LOWER 0</code></p></li></ul><hr><h2 id="定义布尔类型"><a href="#定义布尔类型" class="headerlink" title="定义布尔类型"></a>定义布尔类型</h2><ul><li>需要在开头写如下代码：<code>#include &lt;stdbool.h&gt;</code></li></ul><p>布尔类型为<code>bool</code> (Java中为Boolean)</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>例：<code>int number[100];</code> (Java中为 int[] number = new int[100];)</p><p>（C99开始，<strong>可以用变量定义数组大小</strong>）</p><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><ul><li><p><strong>列数必须给出</strong>，行数可以交给编译器来数</p></li><li><p>每行一个<code>{}</code>，用逗号分隔<code>,</code></p></li><li><p>最后的<code>,</code>可以存在，有古老的传统</p></li><li><p>如果内容省略，表示补0</p></li><li><p>也可以用定位（C99 ONLY）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">3</span>, <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>用<code>[n]</code>在初始化数据中给出定位</li><li>没有定位的数据接在前面的位置后面</li><li>其他位置的值补零</li><li>也可以不给出数组大小，让编译器算</li><li>特别适合初始数据稀疏的数组</li></ul></li></ul><h3 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h3><p><code>sizeof(a)/sizeof(a[0])</code></p><ul><li><code>sizeof</code>给出整个数组所占据的内容的大小，单位是字节</li><li><code>sizeof(a[0])</code>给出数组中单个元素的大小，相除就得到了数组的单元个数</li><li>数组作为函数的参数时 实际是指针（数组的地址）,<strong>需要用另一个参数来传入数组的大小</strong><ul><li>不能在<code>[]</code>中给出数组的大小</li><li>不能再利用<code>sizeof</code>来计算数组的元素个数</li></ul></li></ul><h3 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h3><ul><li>数组变量本身<strong>不能被赋值</strong></li><li>要把一个数组的所有元素交给另一个数组，必须采用遍历</li></ul><hr><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>char是一种整数，也是一种特殊的类型——字符。</p><ul><li><code>&#39;&#39;</code>也是一个字符</li><li><code>printf</code>和<code>scanf</code>里用<code>%c</code>来输入输出字符</li></ul><h3 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h3><table><thead><tr><th>字符</th><th>意义</th></tr></thead><tbody><tr><td><code>\b</code></td><td>回退一格</td></tr><tr><td><code>\t</code></td><td>到下一个表格位</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\\</code></td><td>反斜杠本身</td></tr></tbody></table><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>C语言的编译器自上而下，按顺序分析代码</strong>。</p><p><strong>函数的先后顺序</strong>很重要。</p><p>C语言的函数可以将声明和定义分离，从而顺利通过编译,如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>; <span class="comment">//声明，函数原型， 如果没有参数，括号内最好填写 void，更严谨</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">//main的参数部分也可以写 void</span></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">sum(<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d到%d的和是%d\n"</span>, begin, end, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul><li>调用函数时，<strong>给的值可以与参数类型不完全匹配</strong>，编译器自行转换类型，（Java则对类型转换要求严格）。</li><li>C语言调用函数传参数时，是<strong>值传递</strong>。</li></ul><hr><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><ul><li><p>一元运算符<code>&amp;</code><br>获取变量的地址，它的<strong>操作数必须是变量</strong>，没有其他的运算包括其中。<br><code>p = &amp;c;</code> 称p为“指向”c的指针。</p></li><li><p>一元运算符<code>*</code><br>间接寻址运算符。<code>*</code>作用于指针时，将访问指针所指向的变量。</p></li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针就是<strong>保存地址的变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p,q; <span class="comment">//p为指针，值为所指向的地址；*p是int类型变量，为所指向地址上的值；</span></span><br></pre></td></tr></table></figure><h3 id="指针应用场景"><a href="#指针应用场景" class="headerlink" title="指针应用场景"></a>指针应用场景</h3><ol><li><p>交换两个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *pa;</span><br><span class="line">    *pa = *pb;</span><br><span class="line">    *pb = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数需要返回多个值，某些值就只能通过指针返回</p></li></ol><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><ol><li><p>指针是const（<strong>*在const前</strong>）：表示一旦得到了某个变量的地址，不能再指向其他变量；<strong>不影响改变该地址上的值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> q = &amp;i; <span class="comment">//q是const</span></span><br><span class="line">*q = <span class="number">26</span>; <span class="comment">//所指变量的值可以更改</span></span><br><span class="line">q++; <span class="comment">//ERROR!</span></span><br></pre></td></tr></table></figure></li><li><p>所指的类型是const（<strong>*在const后</strong>）：表示不能通过指针去修改那个变量（<strong>不会使那个变量成为const</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i; <span class="comment">// int const *p 作用相同</span></span><br><span class="line">*p = <span class="number">26</span>; <span class="comment">//ERROR! (*p)是const</span></span><br><span class="line">i = <span class="number">26</span>; <span class="comment">//OK</span></span><br><span class="line">p = &amp;j; <span class="comment">//OK</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><p>以下四种函数原型等价</p><ul><li><code>int sum(int *arr, int n);</code></li><li><code>int sum(int *, int);</code></li><li><code>int sum(int arr[], int n);</code></li><li><code>int sum(int [], int)</code></li></ul><p><strong>数组变量是特殊的指针</strong></p><ul><li>数组无需用&amp;取地址</li><li><p>数组的单元表达的是变量，需要用&amp;取地址</p></li><li><p><code>[]</code>运算符可以对数组做，也可以对指针做<br><code>p[0] &lt;==&gt; a[0]</code></p></li><li><p><code>*</code>运算符可以对指针做，也可以对数组做</p></li><li><p>数组变量是const的指针，所以不能被赋值<br><code>int a[] &lt;==&gt; int *const a=...</code></p></li></ul><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C语言的字符串以字符数组的形态存在</p><ul><li>不能用运算符对字符串做运算<ul><li>通过数组的方式可以遍历字符串</li></ul></li></ul><p>以整数0结尾的一串字符为字符串。（0或<code>\0</code>是一样的，但是和<code>&#39;0&#39;</code>不同）</p><ul><li><strong>0标志字符串的结束，但不是字符串的一部分</strong></li><li>字符串以数组的形式存在，以数组或<strong>指针(主)的形式访问</strong></li><li><code>string.h</code>里有很多处理字符串的函数</li></ul><h3 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> word[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> line[<span class="number">10</span>] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>例如：<code>Hello</code>，字符串会被编译器变成一个字符数组放在某处，这个数组的<strong>长度是5+1</strong>，结尾还有<strong>表示结束的0</strong></p><p>例：<code>char* s = &quot;Hello, world!&quot;;</code></p><ul><li>s是一个指针，初始化为指向一个字符串常量<ul><li>由于这个常量存储的地方，实际上s为<code>const char* s</code>。(历史原因，编译器接受不带const的写法)</li><li>试图对s所指的字符串做写入会导致严重的后果</li></ul></li><li>如果需要修改字符串，应该用数组：<code>char s[] = &quot;Hello, world!&quot;;</code></li></ul><p><strong>选择指针还是数组形式处理字符串？</strong></p><ul><li><p>数组（字符串就存放在当前位置，<strong>如果要构造一个字符串</strong>）</p><ul><li>作为本地变量，空间被自动回收</li></ul></li><li><p>指针（不知道字符串的存储位置，<strong>如果要处理一个字符串</strong>）</p><ul><li>处理参数</li><li>动态分配空间</li></ul></li></ul><hr><h2 id="读入、输出数据"><a href="#读入、输出数据" class="headerlink" title="读入、输出数据"></a>读入、输出数据</h2><ul><li>需要在开头写如下代码：<code>#include &lt;stdio.h&gt;</code></li></ul><p>读取数据，需要在变量名前加上<code>&amp;</code>，从而赋值给变量。</p><h3 id="EOF（End-Of-File"><a href="#EOF（End-Of-File" class="headerlink" title="EOF（End Of File)"></a>EOF（End Of File)</h3><p>可以通过<code>printf(&quot;%d&quot;, EOF);</code>读取EOF的数值，一般的设备上值是-1。<br>EOF操作：</p><ul><li>windows：<code>Ctrl + Z</code></li><li>unix：<code>Ctrl + D</code></li></ul><h3 id="浮点数的输入输出"><a href="#浮点数的输入输出" class="headerlink" title="浮点数的输入输出"></a>浮点数的输入输出</h3><ul><li>输入：<code>scanf(&quot;%lf&quot;, ...);</code></li><li>输出：<ul><li><code>printf(&quot;%f&quot;, ...);</code> //float和double类型，printf函数都使用%f进行说明</li><li><code>printf(&quot;%ld&quot;, ...);</code> //对应long整型的参数</li></ul></li></ul><h3 id="字符的输入-输出"><a href="#字符的输入-输出" class="headerlink" title="字符的输入/输出"></a>字符的输入/输出</h3><ul><li>输入 <code>getchar()</code><br>从文本流中读入下一个输入字符，并将其作为结果值返回。</li><li>输出 <code>putchar(c)</code><br>打印一个字符</li></ul><h3 id="字符串的输入输出"><a href="#字符串的输入输出" class="headerlink" title="字符串的输入输出"></a>字符串的输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p>scanf读入一个单词（到空格、tab或回车为止）</p><hr><ul><li><code>program &lt;infile</code><br>从输入文件<code>infile</code>中读取字符。</li><li><code>otherprogram | program</code><br>将程序<code>otherprogram</code>的标准输出 通过管道，重定向到程序program的标准输入上。 </li></ul><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul><li><code>&amp;</code> 与</li><li><code>|</code> 或</li><li><code>^</code> 异或</li><li><code>~</code> 求反码</li><li><code>&gt;&gt;</code> 右移（高位出现的空位，原来高位是什么，就用什么补该空位；<code>&gt;&gt;&gt;</code>无符号右移，<strong>高位的空位用0补</strong>）</li></ul><hr><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li><p>外部</p><ul><li>用<code>static</code>声明限定外部变量与函数，可以将对象的<strong>作用域限定为被编译源文件的剩余部分</strong>。</li><li>通过<code>static</code>限定外部对象，可以达到隐藏外部对象的目的。</li><li>如果把函数名声明为static类型，则该函数名除了对该函数的声明所在的文件可见外，其他文件都无法访问。</li></ul></li><li><p>内部</p><ul><li><code>static</code>类型的内部变量，不管其所在函数是否被调用，都会存在。（一直占据存储空间；自动变量：随着函数的 调用/退出 而 存在/消失）</li></ul></li></ul><h2 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h2><p><code>register</code>声明告诉编译器，它所声明的变量在程序中使用频率较高</p><hr><h2 id="结构（和java中的类-概念类似-只有变量没有函数）"><a href="#结构（和java中的类-概念类似-只有变量没有函数）" class="headerlink" title="结构（和java中的类 概念类似,只有变量没有函数）"></a>结构（和java中的类 概念类似,只有变量没有函数）</h2><p>关键字<code>struct</code>引入结构声明。</p><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>关键字<code>struct</code>后面的名字是可选的，称为<strong>结构标记</strong>。</p><ul><li><p>有结构标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt</span> = &#123;</span><span class="number">320</span>, <span class="number">200</span>&#125;; <span class="comment">//定义了一个struct point类型的变量pt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt2</span> = &#123;</span>.y = <span class="number">200</span>, .x = <span class="number">320</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>无结构标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; p1, p2; <span class="comment">//p1、p2都是无标记结构，里面有x和y</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>结构的合法操作只有几种：<strong>作为一个整体赋值和赋值（包括向函数传递参数以及从函数返回值）</strong>，通过<code>&amp;</code>运算符取地址，访问其成员。</p><p>例：函数<code>makepoint</code>，带有两个整型参数，并返回一个point类型的结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct point <span class="title">makepoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">temp</span>;</span></span><br><span class="line">temp.x = x;</span><br><span class="line">temp.y = y;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结构指针</strong>的使用频度非常高，为了使用方便，C语言提供了另一种简写方式。假设<code>p</code>是一个指向结构的指针，可以用<code>p-&gt;结构成员</code>的形式（等价于<code>(*p).结构成员</code>），引用相应的结构成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct point* <span class="title">getStruct</span><span class="params">(struct point *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, p-&gt;x, p-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言提供一个编译时的一元运算符sizeof，可以用来<strong>计算任一对象的长度</strong>。</p><p><code>sizeof 对象</code>和<code>sizeof(类型名)</code>会返回一个整型值，等于指定对象或类型<strong>占用的存储空间字节数</strong>。</p><h3 id="类型定义-typedef"><a href="#类型定义-typedef" class="headerlink" title="类型定义 (typedef)"></a>类型定义 (typedef)</h3><p><code>typedef</code>用来<strong>建立新的 数据类型名</strong>。<br>例如，声明<code>typedef int Length;</code><br>将Length定义为与int具有同等意义的名字，Length与类型int完全相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span> &#123;</span><span class="comment">//ADate同样可以略去</span></span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125; Date; <span class="comment">//简化了复杂的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可正常构造结构后，按如下方式定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span> <span class="title">Date</span>;</span></span><br></pre></td></tr></table></figure><hr><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>C99之前无法用变量作为数组定义的大小，当时如何解决该问题？</p><p><code>malloc</code>函数：在需要时，向操作系统申请存储空间，需要<code>#include &lt;stdlib.h&gt;</code>。</p><p><code>void* malloc(size_t size);</code></p><ul><li>向malloc申请的空间的大小以字节为单位</li><li>返回的结果是<code>void*</code>，需要类型转换为需要的类型。例如<code>int *a = (int*)malloc(n*sizeof(int))</code></li></ul><p>因为程序中的某些地方可能不通过 malloc调用 申请空间，所以，<strong>malloc管理的空间不一定是连续的</strong>。</p><h3 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h3><p><code>free(a);</code><br><strong>malloc得到的空间一定要有free的习惯，只能free申请来的空间的首地址</strong></p><hr><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a><code>gets()</code></h3><p>gets()函数包含于stdio.h头文件，会一直读取用户输入，直至换行为止；而scanf一直读至空格键</p><hr><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul><li><p><code>strlen</code> 字符串长度<br><code>size_t strlen (const char *s);</code> 返回s的字符串长度，不包括结尾的0</p></li><li><p><code>strcmp</code> 比较字符串<br><code>int strcmp (const char *s1, char *s2);</code> 比较字符串的大小，返回两者 第一个不同的字符的差值</p></li><li><p><code>strncmp</code> 比较字符串</p><p><code>int strncmp (const char *s1, const char *s2, size_t n)</code> 比较字符串，<code>n</code>为比较的字符数量，若前n个字符相同，返回0 </p></li><li><p><code>strcpy</code> 复制<br><code>char* strcpy(char *restrict dst, const char *restrict src);</code> 把src的字符串复制给dst<br><strong><code>restrict</code>表明src和dst不重叠</strong>，返回dst</p><p>复制字符串的操作示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(dst,src);</span><br></pre></td></tr></table></figure><p><code>memcpy</code>复制</p><p><code>void* memcpy (void*dest, const void *src, size_t n);</code></p><p><strong>与<code>strcpy</code>相比，<code>memcpy</code>并不是遇到’\0’就结束，而是一定会拷贝完n个字节。</strong></p></li><li><p>字符串中找字符<br><code>char* strchr(const char *s, int c);</code><br><code>char* strrchr(const char *s, int c);</code><br>返回NULL表示没有找到</p></li><li><p>字符串中找字符串<br><code>char* strstr(const char *s1, const char *s2);</code><br><code>char* strcasestr(const char *s1, const char *s2); //忽略大小写 查找字符串</code> </p></li><li><p>连接字符串</p><p><code>char *strcat(char *dest, const char *restrict src);</code>将参数 src 字符串复制到参数 dest 所指的字符串尾部</p></li></ul><hr><h3 id="标准库函数-qsort排序"><a href="#标准库函数-qsort排序" class="headerlink" title="标准库函数 qsort排序"></a>标准库函数 qsort排序</h3><p>C语言有<code>qsort()</code>；C++有<code>sort()</code>；Java有<code>Arrays</code>类</p><p><code>qsort()</code>声明在stdlib.h文件中。<br><code>void qsort(void *base,size_t nelem,size_t width,int (*cmp)(const void *,const void *));</code></p><ul><li><p>base:<br>要排序的数组</p></li><li><p>nmemb:<br>数组中的元素数目</p></li><li><p>size:<br>每个数组元素占用内存空间，可使用sizeof获得</p></li><li><p>cmp:<br>比较两个数组元素的比较函数，返回值是<strong>int类型</strong>。比较函数的第一个参数值a与参数b，<strong>此函数需要自定义</strong></p><ul><li>返回值 &gt; 0, a 将被排在b后面;</li><li>返回值 &lt; 0, a 将被排在b前面;</li><li>示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123; <span class="comment">//升序</span></span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">long</span> <span class="keyword">int</span> *)b; <span class="comment">//不能用'&gt;'、'&lt;'比较符(返回无负值)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="转换字符大小写"><a href="#转换字符大小写" class="headerlink" title="转换字符大小写"></a>转换字符大小写</h3><p>函数声明在&lt;ctype.h&gt;文件中：</p><p><code>int tolower(int c)</code></p><p><code>int toupper(int c)</code></p><hr><h2 id="枚举-enumeration"><a href="#枚举-enumeration" class="headerlink" title="枚举(enumeration)"></a>枚举(enumeration)</h2><ul><li><p>枚举是用关键字<code>enum</code>来声明的一种自定义的数据类型：</p><p><code>enum 枚举类型名字 {标识符0, 标识符1, ..., 标识符n};</code></p></li><li><p>枚举类型名字<strong>第一个字母最好大写</strong>，花括号中的标识符是<strong>常量符号，只使用大写字母，类型是int，值依次从0到n</strong>。</p><p>如<code>enum Color {RED, YELLOW, GREEN};</code></p></li><li><p><strong>主要应用：当需要一些可以排列起来的常量值时，定义枚举就是为了给这些常量值名字</strong></p></li><li><p>枚举类型可以跟上<code>enum</code>作为类型：<code>void f(enum Color c);</code>；<code>Color t = RED;</code></p></li><li><p>声明枚举量的时候可以指定值：<code>enum Color {RED = 1, YELLOW, GREEN = 5, BLUE};</code></p><p><code>YELLOW</code>的值为2，<code>BLUE</code>的值为6。</p></li><li><p>不同的枚举常量可以取相同的整数值，但最好采用唯一值，有助于预防难以发现的逻辑错误。</p></li></ul><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="构造结点"><a href="#构造结点" class="headerlink" title="构造结点"></a>构造结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><h3 id="构造链表"><a href="#构造链表" class="headerlink" title="构造链表"></a>构造链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node *head;</span><br><span class="line">&#125; List;</span><br></pre></td></tr></table></figure><hr><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="全局变量初始化"><a href="#全局变量初始化" class="headerlink" title="全局变量初始化"></a>全局变量初始化</h3><ul><li><strong>没有做初始化的全局变量会得到0值</strong><ul><li>指针会得到NULL值</li></ul></li><li>只能用编译时刻已知的值来初始化全局变量</li><li>它们的初始化发生在main函数之前</li></ul><p><strong>如果函数内部存在与全局变量同名的变量，则全局变量被隐藏</strong></p><h3 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a>静态本地变量</h3><ul><li>在本地变量定义时加上<code>static</code>修饰符就成为静态本地变量，<strong>没有做初始化的静态变量会得到0值</strong></li><li><strong>当函数离开的时候，静态本地变量会继续存在并保持其值</strong></li><li>静态本地变量的初始化只在第一次进入该函数时，以后进入函数会保持上次离开的值</li></ul><p><strong>静态本地变量是特殊的全局变量</strong></p><hr><h2 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h2><ul><li><code>#</code>开头的是编译预处理指令</li></ul><h3 id="define-用来定义宏"><a href="#define-用来定义宏" class="headerlink" title="#define 用来定义宏"></a>#define 用来定义宏</h3><ul><li><code>#define &lt;名字&gt; &lt;值&gt;</code>（结尾没有分号，不是C语句）</li><li>名字必须是一个单词，值可以是各种东西</li><li>在C语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字换成值（文本替换）</li></ul><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>如果一个宏的<strong>值中有其他宏的名字</strong>，也会被替换</li><li>如果宏的值超过一行，最后一行之前的行末需要加<code>\</code></li><li>宏的值后边的注释不会被当作宏的值的一部分</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRT printf(<span class="meta-string">"%f "</span>, PI); \</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, PI2)</span><br></pre></td></tr></table></figure><h3 id="预定义的宏"><a href="#预定义的宏" class="headerlink" title="预定义的宏"></a>预定义的宏</h3><ul><li>_LINE_ ：当前行号</li><li>_FILE_ ：文件路径</li><li>_DATE_ ：日期</li><li>_TIME_ ：时间</li></ul><h3 id="带参数的宏的原则"><a href="#带参数的宏的原则" class="headerlink" title="带参数的宏的原则"></a>带参数的宏的原则</h3><ul><li><p>一切都要括号</p><ul><li>整个值要括号</li><li>参数出现的每个地方都要括号</li></ul><p>例：<code>#define RADTODEG(x) ((x)*57.29578)</code></p></li><li><p>可以带多个参数</p><p><code>#define MIN(a,b) ((a)&gt;(b)?(b):(a))</code></p></li><li><p>也可以组合（嵌套）使用其他宏</p></li></ul><h3 id="include-头文件"><a href="#include-头文件" class="headerlink" title="#include 头文件"></a>#include 头文件</h3><p>将included的文件的全部内容原封不动d地插入到所在位置，因此也不一定要在.c文件最前面<code>#include</code></p><ul><li><code>#include &quot;xxx.h&quot;</code> （要求编译器首先在当前目录寻找该文件，如果没有，到编译器指定目录去找）</li><li><code>#include &lt;xxx.h&gt;</code> （让编译器只在指定目录寻找）</li></ul><p>把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中<code>#include</code>这个头文件，就能让编译器在编译的时候知道函数的原型。<code>#include</code>和宏一样在是编译预处理指令。</p><p><strong><code>#include</code>不是用来引入库的</strong>，<code>stdio.h</code>中只有printf等函数的原型，用来保证调用时给出的参数值是正确的类型。printf的代码在另外的地方，某个.lib（Windows）或.a（Unix）中。现在的C语言编译器默认会引入所有的标准库。</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul><li>在使用和定义这个函数的地方都应该<code>#include</code>这个头文件</li><li>一般的做法是任何.c文件都有对应同名的.h文件，把所有对外公开的函数原型和全局变量的声明放进去</li></ul><h3 id="不对外公开的函数"><a href="#不对外公开的函数" class="headerlink" title="不对外公开的函数"></a>不对外公开的函数</h3><ul><li>在函数前加上<code>static</code>使其成为只能在<strong>所在编译单元中</strong>被使用的函数</li><li>在全局变量前面加上<code>static</code>使其成为只能在<strong>所在编译单元中</strong>被使用的全局变量</li></ul><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><ul><li><code>int i;</code>是变量的定义（产生代码）</li><li><code>extern int i;</code>是变量的声明（不产生代码）</li></ul><h3 id="标准头文件结构"><a href="#标准头文件结构" class="headerlink" title="标准头文件结构"></a>标准头文件结构</h3><ul><li><p>运用条件编译和宏，保证这个头文件在一个编译单元中只会被<code>#include</code>一次</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LIST_HEAD__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIST_HEAD__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"node.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span> &#123;</span></span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p><code>%[flags][width][.prec][hlL]type</code></p><ul><li>Flag</li></ul><table><thead><tr><th>Flag</th><th>含义</th></tr></thead><tbody><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>强制显示符号（正数会显示+）</td></tr><tr><td>(space)</td><td>正数留空</td></tr><tr><td>0</td><td>0填充</td></tr></tbody></table><ul><li>width</li></ul><table><thead><tr><th>width或prec</th><th>含义</th></tr></thead><tbody><tr><td>number</td><td>最小字符数（总长，包括小数点后的位数）</td></tr><tr><td>*</td><td>下一个参数是字符数，例：<code>printf(&quot;%*d, 6, 123&quot;);</code></td></tr><tr><td>.number</td><td>小数点后的位数</td></tr><tr><td>.*</td><td>下一个参数是小数点后的位数</td></tr></tbody></table><ul><li>hlL</li></ul><table><thead><tr><th>hlL（类型修饰）</th><th>含义</th></tr></thead><tbody><tr><td>hh</td><td>单个字节</td></tr><tr><td>h</td><td>short</td></tr><tr><td>l</td><td>long</td></tr><tr><td>ll</td><td>long long</td></tr><tr><td>L</td><td>long double</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th>type</th><th>用于</th></tr></thead><tbody><tr><td>i 或 d</td><td>int</td></tr><tr><td>u</td><td>unsigned int</td></tr><tr><td>o</td><td>八进制</td></tr><tr><td>x</td><td>十六进制</td></tr><tr><td>X</td><td>字母大写的十六进制</td></tr><tr><td>f 或 F</td><td>float</td></tr><tr><td>e 或 E</td><td>指数</td></tr><tr><td>g</td><td>float</td></tr><tr><td>G</td><td>float</td></tr><tr><td>a 或 A</td><td>十六进制浮点数</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>n</td><td>读入/写出的个数</td></tr></tbody></table><h3 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h3><p><code>%[flag]type</code></p><ul><li>flag</li></ul><table><thead><tr><th>flag</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>跳过</td></tr><tr><td>数字</td><td>最大字符数</td></tr><tr><td>hh</td><td>char</td></tr><tr><td>h</td><td>short</td></tr><tr><td>l</td><td>long, double</td></tr><tr><td>ll</td><td>long long</td></tr><tr><td>L</td><td>long double</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>int</td></tr><tr><td>i</td><td>整数，也可以是16进制、8进制</td></tr><tr><td>u</td><td>unsigned int</td></tr><tr><td>o</td><td>8进制</td></tr><tr><td>x</td><td>16进制</td></tr><tr><td>a, e, f, g</td><td>float</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>[…]</td><td>允许的字符（例：<code>*[^,]</code>是到<code>,</code>之前的所有字符都跳过）</td></tr><tr><td>p</td><td>指针</td></tr></tbody></table><hr><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h3><ul><li><p><code>&amp;</code> 与</p><p>相同位上都为1，结果为1；否则结果为0</p></li><li><p><code>|</code> 或</p><p>相同位上至少一个是1，结果为1；否则结果为0</p></li><li><p><code>~</code> 取反</p><p>把1位变0，0位变1</p></li><li><p><code>^</code> 异或</p><p>如果两个位相等，结果为0；两个位不相等，结果为1。</p><p>对一个变量用同一个值异或两次，变量不变（可用于加密）</p></li></ul><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul><li><p><code>&lt;&lt;</code> 左移</p><ul><li><p><code>i &lt;&lt; j</code>：i中所有的位向左移动j个位置，<strong>右边填入0</strong></p></li><li><p><code>x &lt;&lt;= n</code> 等价于x *= $2^n$</p></li></ul></li><li><p><code>&gt;&gt;</code> 右移</p><ul><li><code>i &gt;&gt; j</code>：i中所有的位向右移j个位置。unsigned类型，左边填入0；signed类型，左边填入原来的最高位</li><li><code>x &gt;&gt;= n</code> 等价于x /= $2^n$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下的一些终端操作</title>
      <link href="/2018/06/27/Ubuntu%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/27/Ubuntu%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="终端界面的说明"><a href="#终端界面的说明" class="headerlink" title="终端界面的说明"></a>终端界面的说明</h2><p>示例：<br><code>hunter@Hunter-PC:~$</code></p><ul><li>最左侧的<code>hunter</code>是<strong>目前用户的账号</strong></li><li>@之后的<code>Hunter-PC</code>是<strong>主机名</strong></li><li><code>~</code>是<strong>目前所在目录</strong>；<code>~</code>为<strong>当前用户的home目录</strong></li><li><code>$</code>是<strong>提示字符</strong>；root的提示符为<code>#</code>，普通用户为<code>$</code></li></ul><p>登录后取得的程序被称为<code>Shell</code>(壳，因为该程序负责最外面跟使用者沟通，被戏称称为壳程序）</p><p>在Linux下平常<strong>最好使用一般账号来登录</strong>，需要动用到系统功能修订时，再使用root。</p><hr><h2 id="操作说明及技巧"><a href="#操作说明及技巧" class="headerlink" title="操作说明及技巧"></a>操作说明及技巧</h2><p><strong>Linux严格区分大小写</strong>。</p><p>在指令列模式里面下达指令时，会有两种主要的情况：</p><ul><li>直接显示结果，然后回到命令提示字符，等待下一个指令的输入</li><li>进入到该指令的环境，直到结束该指令，回到命令提示字符的环境</li></ul><hr><ul><li>指令太长的时候，可以使用<code>\</code>使指令连续到下一行。<code>\</code>后需要立刻接<br><strong>回车</strong>，才能跳脱！</li></ul><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + Alt + T</td><td>打开终端</td></tr><tr><td>Shift + Ctrl + C/V</td><td>复制/粘贴</td></tr></tbody></table><hr><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><p><strong>Linux命令中，参数一般是无序的，特殊情况除外</strong>。</p><h3 id="更新系统文件"><a href="#更新系统文件" class="headerlink" title="更新系统文件"></a>更新系统文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p><code>sudo apt-get install xxx（程序名）</code></p><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><ul><li><p><code>sudo apt-get remove -purge xxx(程序名)</code></p></li><li><p><code>sudo apt autoremove</code></p></li></ul><h3 id="磁盘管理命令"><a href="#磁盘管理命令" class="headerlink" title="磁盘管理命令"></a>磁盘管理命令</h3><ul><li><p>注销Linux：<code>exit</code>(Linux本身还在运行，只是退出了登录的操作)</p></li><li><p>语系</p><ul><li>显示目前支持的语系：<br>  <code>locale</code></li><li><p>修改语系：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.utf8</span><br><span class="line">export LC_ALL=en_US.utf8</span><br></pre></td></tr></table></figure><p>LANG只与<strong>输出讯息</strong>有关，若需要更改其他不同的信息，要同步更新<code>LC_ALL</code>。</p></li></ul></li><li><p>显示日期：<code>date</code></p></li><li><p>计算器：<code>bc</code>(win10的ubuntu子系统需要先安装)<br>  事实上，该操作是<strong>进入到<code>bc</code>这个软件的工作环境</strong>。<br>  　　<code>bc</code>预设仅<strong>输出整数</strong>，如果要输出小数，需要先执行<code>scale=number</code>，<code>number</code>是小数点位数</p><ul><li>要离开<code>bc</code>，需要输入<code>quit</code>命令</li></ul></li><li><p>转换成root用户：<code>sudo su</code></p></li><li><p>展示文件和目录：<code>ls</code></p><ul><li><code>-a/--all</code> 展示当前目录下<strong>所有文件和目录</strong>（隐藏文件和特殊目录以<code>.</code>开头）</li><li><code>-l</code> 查询详细列表(可以组合使用<code>-al</code>)</li><li><code>-h</code> 友好展示信息<br><code>ls -l</code>可以简写为<code>ll</code></li></ul></li><li><p>切换目录：<code>cd</code></p><ul><li><code>~</code> 当前用户的家目录</li><li><code>/</code> 根目录</li><li><code>-</code> 切换到上次访问的目录</li></ul></li><li><p>显示当前所在目录：<code>pwd</code>(print working directory)</p></li><li><p>创建目录：<code>mkdir</code></p><ul><li><code>-p</code>(parents) 父目录不存在的情况下，生成父目录</li><li><code>-v</code> 显示命令执行过程中的详细信息</li></ul></li><li><p>删除<strong>空</strong>目录：<code>rmdir</code></p></li></ul><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><ul><li><p>快捷查看当前文件的内容：<code>cat</code>，<strong>适合查看少量信息的文件</strong></p></li><li><p>分页显示内容，标注每行的行号：<code>less -mN</code>(<strong>适用于大量数据的查看</strong>)</p><ul><li><code>回车</code> 向下n行（需要定义，默认为1行）</li><li><code>空格</code> 向下一页</li><li><code>b</code> 向上一页</li><li><code>q</code> 退出</li></ul></li><li><p>快速查看文件后n行的内容：<code>tail -n</code>(<strong>查看日志</strong>)</p></li><li><p>复制文件/目录：<code>cp 需要复制的文件 复制的位置</code></p><ul><li><code>-r/--recursive</code> 递归处理，将指定目录下的子目录一并处理<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求：把/root/Demo.java 文件复制到 /root/t1 目录中，改名为d.java</span><br><span class="line">位置：root</span><br><span class="line">命令：cp Demo.java t1/d.java</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>文件移动：<code>mv 需要移动的文件 移动的位置</code></p><ul><li><code>-f</code> 强制性覆盖</li><li><strong>文件/目录重命名操作</strong>：<code>mv 原文件 新文件名</code>（原文件名即转换为新文件名）</li></ul></li><li><p>文件/目录删除：</p><ul><li><code>rm 文件名</code><ul><li><code>-f/--force</code> 强制删除</li><li><code>-r/--recursive</code> 递归处理，将指定目录下的子目录一并处理</li></ul></li><li><code>rm -rf 目录</code></li></ul></li><li><p>查找文件或目录：<code>find [目录名] -name &#39;需要查找的字符串&#39;</code>（不填写目录名则在当前目录下查找）</p></li><li><p>压缩、解压命令：<code>tar</code></p><ul><li><code>-c</code> 建立一个压缩文件(create)</li><li><code>-x</code> 解开一个压缩文件(extract)</li><li><code>-z</code> 用gzip压缩</li><li><code>-v</code> 压缩过程中显示文件(verbose)</li><li><code>-f</code> 使用档名，在f之后要接档名(file)</li></ul></li></ul><p>Linux的压缩包格式：<code>*.tar</code>(打包不压缩)、<code>*.tar.gz</code>(打包并压缩文件大小)</p><pre><code>- 压缩：`tar -zcvf 压缩包名.tar.gz 需要压缩的内容`例如`tar -zcvf test.tar.gz *`(将当前目录下内容进行打包压缩)- 解压：`tar -zxvf 需要解压的压缩包名.tar.gz [-C 指定解压路径]`</code></pre><h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><ul><li><p>查看系统进程：<code>ps -ef</code>(Process Status) 同时会显示执行ps命令的进程信息<br>示例：<code>ps -ef | grep -i vim</code> 查看vim相关的进程</p></li><li><p>强制结束进程：<code>kill -9 pid号</code></p></li><li><p>显示网络设备：<code>ifconfig</code></p></li><li>测试和目标的连通性：<code>ping ip地址</code></li></ul><h3 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h3><ul><li>权限更改：<code>chmod 权限设置 需要更改权限的文件</code><ul><li><code>-R/--recursive</code> 递归处理<br>示例：</li><li>更改所属用户(user)的权限：<code>chmod u=rwx test.txt</code></li><li>更改所属组(group)的权限：<code>chmod g=rx test.txt</code></li><li>更改其他用户(other)的权限：<code>chmod o=rx test.txt</code></li><li>更改所有用户(all)的权限：<code>chmod a=r test.txt</code></li></ul></li></ul><hr><h2 id="几个重要的热键"><a href="#几个重要的热键" class="headerlink" title="几个重要的热键"></a>几个重要的热键</h2><ul><li><p><code>Tab</code><br><code>Tab</code>具有<strong>命令补全</strong>和<strong>文件补齐</strong>的功能，<strong>可以避免打错指令或文件名</strong>。</p><ul><li><code>Tab</code>接在一串指令的第一个字的后面，则为<strong>命令补全</strong></li><li><code>Tab</code>接在一串指令的第二个字以后时，则为<strong>文件补齐</strong></li></ul></li><li><p><code>Ctrl + c</code>：中断目前程序</p></li><li><p><code>Ctrl + d</code>: 键盘输入结束；也可以用来取代<code>exit</code>的输入</p></li><li><p><code>Ctrl + PgUp/PgDown</code>：翻页（指令执行后，显示的内容很长时可以用到）</p></li></ul><hr><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><h3 id="指令名后加上-help"><a href="#指令名后加上-help" class="headerlink" title="指令名后加上--help"></a>指令名后加上<code>--help</code></h3><p>即可查看指令的用法，如<code>cal --help</code>。</p><h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>　　<code>man</code>是<code>manual</code>(操作说明)的简写，通过<code>man 指令名</code>进入的画面，就是<code>man page</code>。</p><p><strong>man page下</strong>能使用的相关操作：  </p><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PgDn</td><td>向下翻一页</td></tr><tr><td>PgUp</td><td>向上翻一页</td></tr><tr><td>Home</td><td>去到第一页</td></tr><tr><td>End</td><td>去到最后一页</td></tr><tr><td><code>/string</code></td><td>向<strong>下</strong>搜寻string这个字符串，如果要搜寻vbird 的话，就输入/vbird</td></tr><tr><td><code>?string</code></td><td>向<strong>上</strong>搜寻string 这个字符串</td></tr><tr><td><code>n, N</code></td><td>利用<code>/</code>或<code>?</code>来查找字符串时，可以用<code>n</code>来继续下一个查找，利用<code>N</code>来进</td></tr></tbody></table><p>行<strong>反向查找</strong> |<br>| q | 结束这次的man page |</p><hr><p>示例（<code>man date</code>）:<br><img src="https://i.loli.net/2019/03/28/5c9c99ef62fbb.png" alt="man date操作之后的页面"></p><p>在页面第一行，可以看到<code>DATE(1)</code>，<code>DATE</code>是指令名称，<code>(1)</code>代表<strong>一般用户可使用的指令</strong>。</p><table><thead><tr><th style="text-align:right">代号</th><th>代表内容</th></tr></thead><tbody><tr><td style="text-align:right">1</td><td>用户在shell 环境中可以操作的指令或可执行文件</td></tr><tr><td style="text-align:right">2</td><td>系统核心可呼叫的函数与工具等</td></tr><tr><td style="text-align:right">3</td><td>一些常用的函数(function)与函式库(library)，大部分为C 的函式库(libc)</td></tr><tr><td style="text-align:right">4</td><td>装置文件的说明，通常在/dev 下的文件</td></tr><tr><td style="text-align:right">5</td><td>配置文件或者是某些文件的格式</td></tr><tr><td style="text-align:right">6</td><td>游戏(games)</td></tr><tr><td style="text-align:right">7</td><td>惯例与协议等，例如Linux 文件系统、网络协议、ASCII code 等等的说明</td></tr><tr><td style="text-align:right">8</td><td>系统管理员可用的管理指令</td></tr><tr><td style="text-align:right">9</td><td>跟kernel 有关的文件</td></tr></tbody></table><hr><p><code>man page</code>大致分成以下几个部分：</p><table><thead><tr><th>代号</th><th>内容说明</th></tr></thead><tbody><tr><td>NAME</td><td>简短的指令、数据名称说明</td></tr><tr><td>SYNOPSIS</td><td>简短的指令下达语法(syntax)简介</td></tr><tr><td>DESCRIPTION</td><td>较为完整的说明，这部分最好仔细看看！</td></tr><tr><td>OPTIONS</td><td>针对SYNOPSIS 部分中，有列举的所有可用的选项说明</td></tr><tr><td>COMMANDS</td><td>当这个程序(软件)在执行的时候，可以在此程序(软件)中下达的指令</td></tr><tr><td>FILES</td><td>这个程序或数据所使用或参考或连结到的某些文件</td></tr><tr><td>SEE ALSO</td><td>可以参考的，跟这个指令或数据有相关的其他说明！</td></tr><tr><td>EXAMPLE</td><td>一些可以参考的范例</td></tr></tbody></table><p>在查询某个数据时可以这样来查阅：</p><ol><li>先察看NAME的项目，看一下这个资料的意思</li><li>再详看一下DESCRIPTION，这个部分会提到很多相关的资料与使用时机，从这个地方可以学到很多小细节</li><li>如果这个指令已经很熟悉了，主要就是查询关于OPTIONS的部分，可以知道每个选项的意义，可以下达比较细部的指令内容</li><li>最后再看一下，跟这个资料有关的还有哪些东西可以使用。举例来说，date的<code>SEE ALSO</code>就告知我们还可以利用<code>info coreutils date</code>来进一步查阅数据；</li><li>某些说明内容还会列举有关的文件(FILES部分)来提供我们参考！这些都是很有帮助的！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据请求的具体扩展名、请求头不同，返回不同格式的相同内容</title>
      <link href="/2018/06/14/%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A9%E5%B1%95%E5%90%8D%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E5%86%85%E5%AE%B9/"/>
      <url>/2018/06/14/%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A9%E5%B1%95%E5%90%8D%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="内容协商多视图"><a href="#内容协商多视图" class="headerlink" title="内容协商多视图"></a>内容协商多视图</h2><p><a href="https://blog.csdn.net/yu412346928/article/details/20637439" target="_blank" rel="noopener">SpringMVC配置多视图-内容协商原理</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><a href="https://junq.io/spring-mvc%E5%AE%9E%E7%8E%B0http%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86-content-negotiation.html" target="_blank" rel="noopener">Spring MVC三种方式实现HTTP内容协商(Content Negotiation)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
          <category> Spring MVC </category>
          
          <category> 视图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视图 </tag>
            
            <tag> ContentNegotiatingViewResolver </tag>
            
            <tag> contentNegotiationManager </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
