<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法题目分类</title>
      <link href="/2020/02/16/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/"/>
      <url>/2020/02/16/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>根据《算法笔记》一书，对PAT甲级、乙级真题和<a href="http://codeup.cn/contest.php" target="_blank" rel="noopener">codeup</a>部分试题进行分类。</p><h2 id="1-C-C-快速入门"><a href="#1-C-C-快速入门" class="headerlink" title="1. C/C++快速入门"></a>1. C/C++快速入门</h2><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104146906" target="_blank" rel="noopener">codeup 杨辉三角</a></li></ul><hr><h3 id="1-2-指针"><a href="#1-2-指针" class="headerlink" title="1.2 指针"></a>1.2 指针</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104151149" target="_blank" rel="noopener">codeup C语言10.16</a></li></ul><hr><h3 id="1-3-结构体的使用"><a href="#1-3-结构体的使用" class="headerlink" title="1.3 结构体的使用"></a>1.3 结构体的使用</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104156997" target="_blank" rel="noopener">codeup C语言11.1</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104158080" target="_blank" rel="noopener">codeup C语言11.2</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104158719" target="_blank" rel="noopener">codeup C语言11.4</a></li></ul><hr><h2 id="2-入门模拟"><a href="#2-入门模拟" class="headerlink" title="2. 入门模拟"></a>2. 入门模拟</h2><h3 id="2-1-简单模拟"><a href="#2-1-简单模拟" class="headerlink" title="2.1 简单模拟"></a>2.1 简单模拟</h3><p><strong>不涉及算法，只是根据题目描述来编写代码，考察代码能力。</strong></p><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/weixin_39345384/article/details/104163314" target="_blank" rel="noopener">codeup 问题 B: A+B</a></td><td>\</td></tr><tr><td><strong>B1001 害死人不偿命的(3n+1)猜想</strong></td><td>\</td></tr><tr><td><strong>B1010 一元多项式求导</strong></td><td>\</td></tr><tr><td><strong>B1011 A+B和C</strong></td><td>\</td></tr><tr><td><strong>B1012 数字分类</strong></td><td>有条不紊地整理</td></tr><tr><td><strong>B1016 部分A+B</strong></td><td>\</td></tr><tr><td><strong>B1018 锤子剪刀布</strong></td><td><strong>注意scanf留在缓冲区的换行符<code>\n</code>的处理</strong></td></tr><tr><td><strong>B1026 程序运行时间</strong></td><td>\</td></tr><tr><td><strong>B1032 挖掘机技术哪家强</strong></td><td>统计各学校总分的方式</td></tr><tr><td><strong>B1046 划拳</strong></td><td>\</td></tr><tr><td><strong>A1002</strong> <strong>A+B for Polynomials</strong></td><td>非零系数项个数的统计</td></tr><tr><td><strong>A1009</strong> <strong>Product of Polynomials</strong></td><td>第二个多项式可边读边处理</td></tr><tr><td><strong>A1042</strong> <strong>Shuffling Machine</strong></td><td><strong>将扑克顺序号转为实际牌号的方式</strong></td></tr><tr><td><strong>A1046 Shortest Distance</strong></td><td>便于计算距离的方式</td></tr><tr><td><strong>A1065</strong> <strong>A+B and C (64bit)</strong></td><td><strong>B1011</strong> <strong>A+B 和 C 进阶版</strong><br><strong>负数相加若溢出，可能得到0</strong></td></tr></tbody></table><hr><h3 id="2-2-查找元素"><a href="#2-2-查找元素" class="headerlink" title="2.2 查找元素"></a>2.2 查找元素</h3><p>查找是学习写代码的一项基本功。</p><ul><li>一般来说，如果需要在一个比较小范围的数据集内内进行查找，<strong>直接遍历</strong>即可。</li><li>如果需要查找的范围较大，可以用<a href="#35-二分">二分查找</a><strong>等算法</strong>进行更快速的查找</li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1004</strong> <strong>成绩排名</strong></td><td>\</td></tr><tr><td><strong>B1028</strong> <strong>人口普查</strong></td><td><strong>1. 不合理年龄的判断方式</strong><br><strong>2. 需要考虑全不合理的情况</strong></td></tr><tr><td><strong>B1032</strong> <strong>挖掘机技术哪家强</strong></td><td>统计各学校总分的方式</td></tr><tr><td><strong>B1041</strong> <strong>考试座位号</strong></td><td>\</td></tr><tr><td><strong>A1011</strong> <strong>World Cup Betting</strong></td><td>\</td></tr><tr><td><strong>A1006</strong> <strong>Sign In and Sign Out</strong></td><td>方法类似 B1028 人口普查</td></tr><tr><td><strong>A1036</strong> <strong>Boys vs Girls</strong></td><td>\</td></tr></tbody></table><hr><h3 id="2-3-图形输出"><a href="#2-3-图形输出" class="headerlink" title="2.3 图形输出"></a>2.3 图形输出</h3><p>做法一般有两种：</p><ul><li>通过规律，直接进行输出</li><li>定义一个二维字符数组，通过规律填充，然后输出整个二维数组</li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1027</strong> <strong>打印沙漏</strong></td><td><strong>沙漏高度和符号数量的关系</strong></td></tr><tr><td><strong>B1036</strong> <strong>跟奥巴马一起编程</strong></td><td>\</td></tr><tr><td><strong>A1031</strong> <strong>Hello World for U</strong></td><td>根据 n1和n3为  $\leq$ n2，且满足 n1+n2+n3 = N+2 的最大值，求出n1，n2，n3</td></tr></tbody></table><hr><h3 id="2-4-日期处理"><a href="#2-4-日期处理" class="headerlink" title="2.4 日期处理"></a>2.4 日期处理</h3><p>需要处理好<strong>平年和闰年、大月和小月</strong>的问题，需要<strong>细心</strong>处理。</p><p>闰年的判断方法：</p><ol><li><p><strong>非整百年</strong>：能<strong>被4整除</strong>为闰年</p></li><li><p><strong>整百年</strong>：能<strong>被400整除</strong>的是闰年（<strong>1900年不是闰年</strong>）</p></li></ol><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104252546" target="_blank" rel="noopener">codeup 问题 A: 日期差值</a></li></ul><hr><h3 id="2-5-进制转换"><a href="#2-5-进制转换" class="headerlink" title="2.5 进制转换"></a>2.5 进制转换</h3><p>对一个<strong>P进制的数</strong>，如果要<strong>转换为Q进制</strong>，需要分两步：</p><ol><li><p>将 P进制数x <strong>转换为 十进制数y</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>, pro = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">    y += (x % <span class="number">10</span>) * pro;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">    pro *= p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将 十进制数y <strong>转换为 Q进制数z</strong></p><p>采用<strong>除基取余法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">40</span>], num = <span class="number">0</span>; <span class="comment">//数组z 存放 Q进制数y 的每一位，num为位数</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    z[num++] = y % Q; <span class="comment">//除基取余</span></span><br><span class="line">    y /= Q;</span><br><span class="line">&#125; <span class="keyword">while</span>(y != <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>do···while</code>语句而不是<code>while</code>的原因是：<strong>如果十进制数y = 0，使用<code>while</code>语句将使循环直接跳出，导致结果出错</strong>。</p></li></ol><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1022</strong> <strong>D进制的A+B</strong></td><td><strong>除基取余法</strong></td></tr><tr><td><strong>B1037</strong> <strong>在霍格沃茨找零钱</strong></td><td>\</td></tr><tr><td><strong>A1019</strong> <strong>General Palindromic Number</strong></td><td>\</td></tr><tr><td><strong>A1027</strong> <strong>Colors in Mars</strong></td><td>\</td></tr><tr><td><strong>A1058</strong> <strong>A+B in Hogwarts</strong></td><td>题型同 乙级1037 在霍格沃茨找零钱<br>单位转换过程可能会超过int范围</td></tr></tbody></table><hr><h3 id="2-6-字符串处理"><a href="#2-6-字符串处理" class="headerlink" title="2.6 字符串处理"></a>2.6 字符串处理</h3><p>考察<strong>代码能力</strong>的题型。一般需要<strong>仔细分析清楚</strong>题目中的<strong>输入和输出格式</strong>才能顺利AC。</p><p>有些题目中，可能<strong>实现逻辑非常麻烦</strong>，有很多<strong>细节</strong>和<strong>边界</strong>情况，此类题目需要<strong>多做多想，积累经验</strong>。</p><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1002</strong> <strong>写出这个数</strong></td><td><strong>数字转为字符串</strong>：<br>C语言：<code>sprintf(str, &quot;%d&quot;, num)</code><br>C++：<code>to_string(num)</code></td></tr><tr><td><strong>B1006</strong> <strong>换个格式输出整数</strong></td><td>\</td></tr><tr><td><strong>B1009</strong> <strong>说反话</strong></td><td><strong>句子颠倒，单词本身不颠倒</strong><br>C++ 待更新</td></tr><tr><td><strong>B1014</strong> <strong>福尔摩斯的约会</strong><br><strong>A1061</strong> <strong>Dating</strong></td><td><strong>正确归纳</strong>解码方式</td></tr><tr><td><strong>B1021</strong> <strong>个位数统计</strong></td><td>\</td></tr><tr><td><strong>B1024</strong> <strong>科学计数法</strong><br><strong>A1073</strong> <strong>Scientific Notation</strong></td><td><strong>1. 利用正则表达式，分开读取 数字部分 和 指数部分</strong><br>2. 指数 &lt; 0：整数部分必然为 0<br>3. 指数 &gt;= 0：<br>     - <strong>仍有小数点，何时输出小数点</strong><br>     - 没有小数点，后续输出0</td></tr><tr><td><strong>B1031</strong> <strong>查验身份证</strong></td><td>\</td></tr><tr><td><strong>B1048</strong> <strong>数字加密</strong></td><td><strong>1. 对齐两个整数</strong> <br>     - 若加密正整数A 比 B 长，B<strong>高位补0</strong>后进行加密 <br>     - 若加密正整数A 比 B 短，B<strong>多余的部分正常输出，等同于A高位补0</strong>后进行加密 <br> 2. 结果从数字高位(<strong>字符串低位</strong>)<strong>开始输出</strong></td></tr><tr><td><strong>A1001</strong> <strong>A+B Format</strong></td><td>从<strong>数字高位(字符串低位)开始</strong>，需要添加<code>,</code>的位置满足<strong><code>(i + 1) % 3 == len % 3</code> 且 不是最后一位</strong></td></tr><tr><td><strong>A1005</strong> <strong>Spell It Right</strong></td><td>\</td></tr><tr><td><strong>A1035</strong> <strong>Password</strong></td><td>(待优化)</td></tr><tr><td><strong>A1077</strong> <strong>Kuchiguse</strong></td><td><strong>1. 通过<code>reverse()</code>反转字符串，将后缀转换为前缀，便于比较</strong><br>2. <code>getline()</code>之前注意<strong>读取换行符</strong>。</td></tr><tr><td><strong>A1082</strong> <strong>Read Number in Chinese</strong></td><td>1. <strong>四位数字分为一节</strong>，单位为个、万、亿<br>2. <strong>一节中数字全为0</strong>，则不输出<strong>节的单位</strong><br>3. 节中<strong>第一个非零数之前有0</strong>，则输出<strong>1个</strong>0</td></tr></tbody></table><hr><h2 id="3-算法初步"><a href="#3-算法初步" class="headerlink" title="3. 算法初步"></a>3. 算法初步</h2><h3 id="3-1-排序"><a href="#3-1-排序" class="headerlink" title="3.1 排序"></a>3.1 排序</h3><h4 id="3-1-1-简单选择排序（-O-n-2-）"><a href="#3-1-1-简单选择排序（-O-n-2-）" class="headerlink" title="3.1.1 简单选择排序（$O(n^2)$）"></a>3.1.1 简单选择排序（$O(n^2)$）</h4><p>简单选择排序是指，对一个序列A中的元素<code>A[0] ~ A[n-1]</code>，令<code>i</code>从 0 到 n-1 枚举，进行 n 趟操作，每一趟从<strong>待排部分</strong>$[i, n-1]$中<strong>选择最小元素（记录下标）</strong>，令其<strong>与待排部分</strong>的<strong>第一个元素A[i]</strong>进行交换，使得$[0, i]$<strong>区间有序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//降序 简单选择排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">//选出最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[i])</span><br><span class="line">                k = j; <span class="comment">//记录更小元素的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = A[i]; <span class="comment">//交换A[k]与A[i]</span></span><br><span class="line">        A[i] = A[j];</span><br><span class="line">        A[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-2-直接插入排序（-O-n-2-）"><a href="#3-1-2-直接插入排序（-O-n-2-）" class="headerlink" title="3.1.2 直接插入排序（$O(n^2)$）"></a>3.1.2 直接插入排序（$O(n^2)$）</h4><p>直接插入排序是指，对序列A的n个元素<code>A[0]~A[n-1]</code>，令 i <strong>从 1 </strong>到 n-1 枚举，进行 n - 1 趟操作。</p><p>某一趟时，序列A的前 i 个元素 <code>A[0]~A[i-1]</code>已经有序，则该趟在范围$[0, i - 1]$中，<strong>从后往前</strong>寻找某个位置j，使得<code>A[i]</code>插入后，范围$[0, i]$有序(<strong><code>A[j]~A[i]</code>后移一位</strong>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//升序 直接插入排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = A[i], j = i;</span><br><span class="line">        <span class="comment">//从后往前遍历，便于编写代码</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; A[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-3-冒泡排序（-O-n-2-）"><a href="#3-1-3-冒泡排序（-O-n-2-）" class="headerlink" title="3.1.3 冒泡排序（$O(n^2)$）"></a>3.1.3 冒泡排序（$O(n^2)$）</h4><p>冒泡排序的本质在于<strong>交换</strong>，即每次通过交换的方式把当前<strong>剩余元素的最大值(升序)</strong>移动到一端，当<strong>剩余元素减少到0</strong>时，排序结束。整个过程执行 <strong>n-1 趟</strong>，每一趟<strong>从左到右依次比较相邻的元素</strong>，如果<strong>大的数在左边，则交换</strong>，该趟结束时，<strong>最大数</strong>被移动到<strong>当前剩余数的最右边</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//升序 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">//进行 n - 1 趟排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-4-排序题与sort函数的应用"><a href="#3-1-4-排序题与sort函数的应用" class="headerlink" title="3.1.4 排序题与sort函数的应用"></a>3.1.4 排序题与sort函数的应用</h4><p>PAT中的排序题，大部分<strong>只需要得到排序的最终结果，而不需要去写排序的完整过程(例如冒泡排序、快速排序等)</strong>，因此推荐直接使用<strong>C语言的库函数<code>qsort</code></strong>或是<strong>C++的<code>sort</code>函数</strong>进行排序。<code>qsort</code>函数的使用需要运用指针，且写法上没有<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p><ul><li><p><strong>结构体数组的排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; ssd[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>如果想先<strong>按x</strong>从大到小排序，<strong>在x相等的情况下</strong>，<strong>按y</strong>从小到大排序(即<strong>二级排序</strong>)，cmp的写法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="comment">//返回值为true时，a排在b之前</span></span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">//降序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y; <span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>排名的实现</strong></p><p>很多排序题要求<strong>在排序之后</strong>计算每个个体的<strong>排名</strong>，规则一般是：<strong>分数相同的排名相同，占用一个排位</strong>。例如有5个学生的分数分别为90、88、88、88、86，其排名分别为1、2、2、2、5。</p><p><strong>方法：</strong></p><p>将第一个个体排名记为1，遍历剩余个体，如果当前分数等于上一个个体的分数，则当前个体排名等于<strong>上一个个体的排名</strong>，否则当前个体的排名等于<strong>数组下标+1</strong></p></li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1015</strong> <strong>德才论</strong><br><strong>A1062</strong> <strong>Talent and Virtue</strong></td><td>设置flag作为考生的分类，便于所有考生<strong>统一排序</strong></td></tr><tr><td><strong>A1012</strong> <strong>The Best Rank</strong></td><td>1. <strong>利用全局变量设计cmp函数</strong><br>2. 通过<strong>记录所有科目的排名</strong>，最后选出最好的排名以及对应科目<br>3. 相同分数者排名相同，<strong>下一不同分数者</strong>排名为<strong>数组下标+1</strong></td></tr><tr><td>A1016</td><td></td></tr><tr><td>A1025</td><td></td></tr><tr><td>A1028</td><td></td></tr><tr><td>A1055</td><td></td></tr><tr><td>A1075</td><td></td></tr><tr><td>A1083</td><td></td></tr><tr><td>A1080</td><td></td></tr><tr><td>A1095</td></tr></tbody></table><hr><h3 id="3-2-散列"><a href="#3-2-散列" class="headerlink" title="3.2 散列"></a>3.2 散列</h3><h4 id="3-2-1-散列的定义与整数散列"><a href="#3-2-1-散列的定义与整数散列" class="headerlink" title="3.2.1 散列的定义与整数散列"></a>3.2.1 散列的定义与整数散列</h4><h4 id="3-2-2-字符串hash初步"><a href="#3-2-2-字符串hash初步" class="headerlink" title="3.2.2 字符串hash初步"></a>3.2.2 字符串hash初步</h4><hr><h3 id="3-3-递归"><a href="#3-3-递归" class="headerlink" title="3.3 递归"></a>3.3 递归</h3><h4 id="3-3-1-分治"><a href="#3-3-1-分治" class="headerlink" title="3.3.1 分治"></a>3.3.1 分治</h4><h4 id="3-3-2-递归"><a href="#3-3-2-递归" class="headerlink" title="3.3.2 递归"></a>3.3.2 递归</h4><hr><h3 id="3-4-贪心"><a href="#3-4-贪心" class="headerlink" title="3.4 贪心"></a>3.4 贪心</h3><h4 id="3-4-1-简单贪心"><a href="#3-4-1-简单贪心" class="headerlink" title="3.4.1 简单贪心"></a>3.4.1 简单贪心</h4><h4 id="3-4-2-区间贪心"><a href="#3-4-2-区间贪心" class="headerlink" title="3.4.2 区间贪心"></a>3.4.2 区间贪心</h4><hr><h3 id="3-5-二分"><a href="#3-5-二分" class="headerlink" title="3.5 二分"></a>3.5 二分</h3><h4 id="3-5-1-二分查找"><a href="#3-5-1-二分查找" class="headerlink" title="3.5.1 二分查找"></a>3.5.1 二分查找</h4><h4 id="3-5-2-二分法拓展"><a href="#3-5-2-二分法拓展" class="headerlink" title="3.5.2 二分法拓展"></a>3.5.2 二分法拓展</h4><h4 id="3-5-3-快速幂"><a href="#3-5-3-快速幂" class="headerlink" title="3.5.3 快速幂"></a>3.5.3 快速幂</h4><hr><h3 id="3-6-tow-pointers"><a href="#3-6-tow-pointers" class="headerlink" title="3.6 tow pointers"></a>3.6 tow pointers</h3><h4 id="3-6-1-什么是two-pointers"><a href="#3-6-1-什么是two-pointers" class="headerlink" title="3.6.1 什么是two pointers"></a>3.6.1 什么是two pointers</h4><h4 id="3-6-2-归并排序"><a href="#3-6-2-归并排序" class="headerlink" title="3.6.2 归并排序"></a>3.6.2 归并排序</h4><h4 id="3-6-3-快速排序"><a href="#3-6-3-快速排序" class="headerlink" title="3.6.3 快速排序"></a>3.6.3 快速排序</h4><hr><h3 id="3-7-其他高效技巧与算法"><a href="#3-7-其他高效技巧与算法" class="headerlink" title="3.7 其他高效技巧与算法"></a>3.7 其他高效技巧与算法</h3><h4 id="3-7-1-打表"><a href="#3-7-1-打表" class="headerlink" title="3.7.1 打表"></a>3.7.1 打表</h4><h4 id="3-7-2-活用递推"><a href="#3-7-2-活用递推" class="headerlink" title="3.7.2 活用递推"></a>3.7.2 活用递推</h4><h4 id="3-7-3-随机选择法"><a href="#3-7-3-随机选择法" class="headerlink" title="3.7.3 随机选择法"></a>3.7.3 随机选择法</h4><hr><h2 id="4-数学问题"><a href="#4-数学问题" class="headerlink" title="4.  数学问题"></a>4.  数学问题</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑盒测试</title>
      <link href="/2020/02/03/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/02/03/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对黑盒测试来说，<strong>所有输入数据都放在一个文件里</strong>。</p></blockquote><hr><h2 id="单点测试"><a href="#单点测试" class="headerlink" title="单点测试"></a>单点测试</h2><p>PAT试题基本为<strong>单点测试</strong>（即<strong>一次运行一组数据，一组数据通过测试则获得这组数据的分值</strong>）。</p><hr><h2 id="多点测试"><a href="#多点测试" class="headerlink" title="多点测试"></a>多点测试</h2><p>多点测试要求程序<strong>一次运行所有数据，并要求输出结果都正确，只要存在错误，即不得分</strong>。<br><strong>大部分 在线判题系统(Online Judge)  都采用了多点测试</strong>。<br>由于要求程序能运行所有数据，因此<strong>必须保证程序能反复执行代码的核心部分</strong>，这<strong>就要用到循环</strong>。</p><h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>题目一般有3中输入的格式，需要采用不同输入方式。</p><ol><li><strong><code>while··· EOF</code>型</strong></li></ol><p>题目<strong>没有给定输入的结束条件</strong>，则<strong>默认读取到文件末尾</strong>。</p><blockquote><p>EOF（End Of File)</p><p>可以通过<code>printf(&quot;%d&quot;, EOF);</code>读取EOF的数值，一般的设备上值是-1。<br>EOF操作：</p><ul><li>windows：<code>Ctrl + Z</code></li><li>unix：<code>Ctrl + D</code></li></ul></blockquote><p><code>scanf</code> 若成功读入一个值，返回1；若成功读入2个值，返回2；若<strong>读入失败，返回 -1</strong>，C/C++中，<code>EOF</code>即为 -1。</p><p>正常情况下，控制台中的输入不会失败，只有读取文件时<strong>到达文件末尾，导致无法读取时，才会产生读入失败</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取数字、字符、字符串</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串</span></span><br><span class="line"><span class="keyword">while</span> (gets(str) !- <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="2"><li>while··· break`型**</li></ol><p>题目要求，<strong>当输入的数据满足某个条件时，停止输入</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更简洁的写法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), a || b) &#123;<span class="comment">// scanf()恒不为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="3"><li>while (T–)`型</li></ol><p>题目给出测试数据的组数，然后才给出相应数量数组的输入数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ol><li><p>正常输出</p></li><li><p>每组数据输出之后，额外加一个空行</p></li><li><p><strong>两组输出数据之间有一个空行，最后一组数据后面没有空行</strong></p><p>一般在第三种输入类型<code>while (T--)</code>情况下出现，只需通过判断T是否为0选择是否输出额外的换行。</p></li></ol><hr><h3 id="重置变量"><a href="#重置变量" class="headerlink" title="重置变量"></a>重置变量</h3><p>在多点测试中，<strong>每一次循环都要重置变量和数组</strong>，否则在下一组数据来临时，变量和数组不是初始状态，将出错。<strong>重置数组一般使用<code>memset</code>函数或<code>fill</code>函数</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> OJ </tag>
            
            <tag> 在线判题系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++解题干货</title>
      <link href="/2020/02/01/C_C++%E8%A7%A3%E9%A2%98%E5%B9%B2%E8%B4%A7/"/>
      <url>/2020/02/01/C_C++%E8%A7%A3%E9%A2%98%E5%B9%B2%E8%B4%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h2><ol><li><p><strong>整型int</strong>取值范围：$-2^{31} \sim +(2^{31}-1)$，题目要求<strong>绝对值在$10^9$以内 或 32位整数</strong>，则<strong>用int型表示</strong></p></li><li><p><strong>长整型long long</strong>取值范围：$-2^{63} \sim +(2^{63}-1)$，题目要求<strong>绝对值在$10^{18}$以内 或 64位整数</strong>，则<strong>用long long型表示</strong></p><p>注：如果 long long 型赋 $&gt; 2^{31}-1$的初值，需要在初值后加上LL，否则编译错误。如<code>long long num = 123456789012345LL;</code></p></li><li><p>浮点型数据<strong>一律用double存储</strong>，而不用float(精度低，6~7位)</p></li><li><p>字符常量使用<strong>ASCII码(范围0~127)</strong>统一编码。</p><ul><li>0~9 的ASCII码值：48~57</li><li>A~Z 的ASCII码值：65~90</li><li>a~z 的ASCII码值：97~122 (<strong>比大写字母的ASCII码值大32</strong>)</li></ul></li><li><p>强制类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">12.56</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)r); <span class="comment">//输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, (<span class="keyword">double</span>)a / (<span class="keyword">double</span>)b);<span class="comment">//输出0.6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td>#include &lt;cstdio><br><strong>scanf函数<br>printf函数</strong></td><td>#include &lt;iostream> <br>using std::cin;<br>using std::cout;<br>cin<br>cout</td><td>cin 和 cout <strong>无需指定输入输出格式</strong>，<br>但<strong>消耗的时间</strong>比 scanf 和 printf <strong>多得多</strong>。<br>故<strong>推荐使用C语言的 scanf 和 printf</strong>，<br>只有在十分必要的时候使用 cin 和 cout</td></tr></tbody></table><h3 id="输入和输出格式"><a href="#输入和输出格式" class="headerlink" title="输入和输出格式"></a>输入和输出格式</h3><table><thead><tr><th>类型</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>long long</td><td><code>scanf(&quot;%lld&quot;, &amp;n);</code></td><td><code>printf(&quot;%lld&quot;, n);</code></td></tr><tr><td>double</td><td><code>scanf(&quot;%lf&quot;, &amp;db);</code></td><td><code>printf(&quot;%f&quot;, db);</code></td></tr><tr><td>字符串</td><td><code>scanf(&quot;%s&quot;, str);</code><br>(<strong>无需 取地址符&amp;</strong>)<br></td><td><code>printf(&quot;%s&quot;, str);</code></td></tr><tr><td>char</td><td><code>c1 = getchar();</code><br><strong>能读入换行符<code>\n</code></strong></td><td><code>putchar(c1);</code></td></tr></tbody></table><h3 id="实用的输出格式"><a href="#实用的输出格式" class="headerlink" title="实用的输出格式"></a>实用的输出格式</h3><ol><li><p><code>%md</code></p><p>使不足m位的int型变量以m位进行<strong>右对齐</strong>输出，高位<strong>用空格补齐</strong>；若变量本身超过m位，则保持原样。</p></li><li><p><code>%0md</code></p><p>使不足m位的int型变量以m位进行<strong>右对齐</strong>输出，高位<strong>用0补齐</strong>；若变量本身超过m位，则保持原样。</p></li><li><p><code>%.mf</code></p><p>让浮点数保留m位小数(<strong>四舍六入五成双</strong>)输出。如果要<strong>四舍五入</strong>，需要用到<strong>round函数</strong>。</p><blockquote><p>四舍六入五成双：</p><ul><li>5后有数时：舍5入1</li><li>5后无数时：<ul><li>5前为奇数，舍5入1</li><li>5前为偶数，舍5不进（0是偶数）</li></ul></li></ul></blockquote></li></ol><hr><h2 id="cmath-头文件"><a href="#cmath-头文件" class="headerlink" title="cmath 头文件"></a>cmath 头文件</h2><ol><li><p><strong><code>double fabs(double x)</code></strong></p><p><strong>取绝对值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> db = <span class="number">-12.56</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, <span class="built_in">fabs</span>(db)); <span class="comment">//输出 12.56</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>double floor(double x)</code>和<code>ceil(double x)</code></strong></p><p><strong>向下取整</strong>和<strong>向上取整</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> db1 = <span class="number">-5.2</span>, db2 = <span class="number">5.2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0f %.0f\n"</span>, <span class="built_in">floor</span>(db1), <span class="built_in">ceil</span>(db1)); <span class="comment">//输出 -6 -5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0f %.0f\n"</span>, <span class="built_in">floor</span>(db2), <span class="built_in">ceil</span>(db2)); <span class="comment">//输出 5 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>double pow(double r, double p)</code></strong></p><p>求 r 的 p次方</p><p><strong>$10^n$还有另外的表示方法，如</strong></p><ul><li>$10^3$ 可写成 <code>1e3</code></li><li>$2\times10^6$可写成<code>2e6</code></li><li>$3\times10^{-6}$可写成<code>3e-6</code></li></ul><p>该表示方法可以用于赋值、判断等，<strong>无法直接输出</strong>。</p></li><li><p><strong><code>double sqrt(double x)</code></strong></p><p>求 x 的算术平方根</p></li><li><p><strong><code>double log(double x)</code></strong>和<strong><code>double log10(double x)</code></strong>：求 x 以 $e$ 为底的对数 和 以10为底的对数</p><p>针对<strong>任意底数求对数的函数</strong>，必须用<strong>换底公式</strong>，即$\log_ab = \ln b/\ln a$</p></li><li><p><strong><code>double round(double x)</code></strong><br><strong>四舍五入</strong>，需要进行取整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> db = round(<span class="number">3.4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)db); <span class="comment">//输出3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   另，<strong>不使用函数进行四舍五入的方法</strong>：</p><p>   <code>num = num + 0.5</code> </p><hr><h2 id="cctype-头文件"><a href="#cctype-头文件" class="headerlink" title="cctype 头文件"></a>cctype 头文件</h2><ol><li><p><code>int isalnum(int c)</code></p><p>字符是否为<strong>数字或字母</strong></p></li><li><p><code>int isalpha(int c)</code></p><p>字符是否是<strong>字母</strong></p></li><li><p><code>int isdigit(int c)</code></p><p>字符是否是十进制<strong>数字</strong></p></li><li><p><code>int islower(int c)</code></p><p>是否是<strong>小写字母</strong></p></li><li><p><code>int isupper(int c)</code></p><p>是否是<strong>大写字母</strong></p></li><li><p><code>int tolower(int c)</code></p><p>把大写字母 <strong>转换为 小写字母</strong></p></li><li><p><code>int toupper(int c)</code></p><p>把小写字母 <strong>转换为 大写字母</strong></p></li></ol><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p><strong>一维数组初始化</strong></p><p><strong>如果数组没有初始化，数组中每个元素为随机数</strong>。一维数组的初始化，<strong>未被赋初始值</strong>的元素将<strong>默认初始化为0</strong>，因此，如果想要给整个数组初始化为0，只需第一个元素初始化为0即可。<code>int a[10] = {0};</code>(<strong>不适用C语言</strong>)</p></li><li><p><strong>二维数组初始化</strong></p><p>二维数组初始化需要<strong>按第一维的顺序</strong>，依次<strong>用大括号</strong>给出<strong>第二维初始化</strong>的情况，<strong>未被赋初始值</strong>的元素将<strong>默认初始化为0</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">3</span>&#125;, &#123;&#125;, &#123;<span class="number">8</span>, <span class="number">4</span>&#125;&#125;; <span class="comment">//第二行使用大括号跳过</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">数组初始化为：</span></span><br><span class="line"><span class="comment">3 0</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">8 4</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果数组大小较大(大概$10^6$级别)，需要定义在主函数外(即全局变量)</strong></p><p>否则程序会异常退出（局部变量来自系统栈，允许申请空间较小；全局变量来自静态存储区，允许申请的空间较大）</p></li><li><p><strong>对数组中每一个元素赋相同的值</strong></p><p><strong>需要<code>#include &lt;cstring&gt;</code></strong></p><p><code>void* memset(数组名, 值, sizeof(数组名));</code></p><p>memset <strong>按字节赋值</strong>，即对每个字节赋同样的值，<strong>组成int型的4个字节就会被赋成相同的值</strong>。故建议<strong>只用于赋 0或 -1</strong>(0的二进制补码为全0，-1的二进制补码为全1)，不易出错。</p><p><strong>如果要对数组赋其他数字(如 1)，则使用 fill函数（执行速度比 memset 慢）</strong>。</p></li></ol><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ul><li><p>输入</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>scanf(&quot;%s&quot;, str);</code> 识别<strong>空格或换行</strong>作为输入结束，且<strong>空格或回车符会留在缓冲区</strong></p></li><li><p><code>char c = getchar();</code> 能够读入<strong>空格和换行符</strong></p></li><li><p><code>gets(char* str);</code> 识别<strong>换行</strong>作为输入结束，且<strong>回车符会被舍弃，不在缓冲区</strong></p><p>因此，<strong>scanf一个输入后，如果要使用gets，需要先用 getchar 接收scanf后的空格或换行符</strong>。</p><p>另外，<strong>PAT使用C++提交时</strong>，使用<code>gets()</code>函数会出现<strong>编译错误</strong>，建议使用C++函数。</p></li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>cin &gt;&gt;</code></p></li><li><p><code>cin.getline(数组名称, 数组大小)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指定最多读入 9 个字符，超出即报错</span></span><br><span class="line"><span class="comment">（实际数组最多能存放99个字符，空字符\0 占用一个字符位）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>输出</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>printf(str);</code> </li><li><code>putchar(char c);</code></li><li><code>puts(char* str);</code> 输出数组内容后，<strong>紧跟一个换行</strong></li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br></pre></td></tr></table></figure><ul><li><code>cout &lt;&lt;</code></li></ul></li></ul></li><li><p>字符数组的存放方式</p><p>字符数组的<strong>末尾都有一个 空字符<code>\0</code>(即NULL)，表示存放的字符串的结尾</strong>。空字符<code>\0</code> 在<strong>gets</strong>和<strong>scanf</strong>输入字符串时，会<strong>自动添加在输入的字符串后面</strong>，并<strong>占用一个字符位</strong>。<strong>puts</strong>和<strong>printf</strong>就是<strong>通过识别<code>\0</code>作为字符串的结尾进行输出</strong>。</p><ul><li>空字符<code>\0</code><strong>占用一个字符位</strong>，因此<strong>字符数组的长度一定要比实际存储字符串的长度 至少多1</strong>。</li><li>如果<strong>使用<code>getchar()</code>输入字符串</strong>，一定要在<strong>每个字符串后加入<code>\0</code>，否则printf和puts输出字符串会因无法识别字符串末尾而输出一大堆乱码</strong>。</li></ul></li></ul><hr><h3 id="C-的标准库类-string"><a href="#C-的标准库类-string" class="headerlink" title="C++ 的标准库类 string"></a>C++ 的标准库类 string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>若引用了<code>&lt;iostream&gt;</code>头文件，创建string对象时，无须引用<code>&lt;string&gt;</code>，因为<code>&lt;iostream&gt;</code>有对<code>std::string</code>的间接引用。但时要对string对象运用相关的函数操作，仍须引用<code>&lt;string&gt;</code>。</p><ul><li><p>输入一整行</p><p><code>getline(cin, str)</code></p></li><li><p>比较字符串大小</p><ul><li><p><code>str1.compare(str2)</code></p><p><strong>按字典顺序(顺序越靠后，越大)</strong>，返回两个字符串大小的比较</p></li></ul></li></ul><hr><h3 id="cstring-头文件"><a href="#cstring-头文件" class="headerlink" title="cstring 头文件"></a>cstring 头文件</h3><ol><li><p><code>strlen(str)</code></p><p>得到字符数组中<strong>第一个<code>\0</code>前 的字符个数</strong></p></li><li><p><code>strcmp(str1, str2)</code></p><p><strong>按字典顺序(顺序越靠后，越大)</strong>，返回两个字符串大小的比较结果：</p><ul><li><code>str1 &lt; str2</code>，返回一个<strong>负整数</strong>(不同编译器处理不同，<strong>不一定是 -1</strong>)</li><li><code>str1 == str2</code>，返回一个0</li><li><code>str1 &gt; str2</code>，返回一个<strong>正整数</strong>(不同编译器处理不同，<strong>不一定是 +1</strong>)</li></ul></li><li><p><code>strcpy(str1, str2)</code></p><p>把 str2 复制给 str1，<strong>包括结束符<code>\0</code></strong></p></li><li><p><code>strcat(str1, str2)</code></p><p>把 str2 <strong>拼接</strong>到 str1 后面</p></li></ol><hr><h3 id="字符串与数字的相互转换"><a href="#字符串与数字的相互转换" class="headerlink" title="字符串与数字的相互转换"></a>字符串与数字的相互转换</h3><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br></pre></td></tr></table></figure><p>字符串 <strong>转为 数字</strong></p><ul><li><code>atoi(str)</code>：将字符串转为 int型</li><li><code>atol(str)</code>：将字符串转为 long long型</li><li><code>atof(str)</code>：将字符串转为 double型</li></ul><hr><h5 id="方法二：-sscanf-与-sprintf"><a href="#方法二：-sscanf-与-sprintf" class="headerlink" title="方法二： sscanf 与 sprintf"></a>方法二： sscanf 与 sprintf</h5><p>如果想从屏幕输入 int型变量n 并将 n 输出到屏幕：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n);</span><br><span class="line"><span class="comment">//其实可以表示成如下</span></span><br><span class="line"><span class="built_in">scanf</span>(screen, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(screen, <span class="string">"%d"</span>, n);</span><br></pre></td></tr></table></figure><p><code>sscanf</code>与<code>sprintf</code>的格式如出一辙，只是把screen换成了字符数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n); <span class="comment">//将字符数组str中的内容以"%d"格式写到n中</span></span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d"</span>, n); <span class="comment">//把n以"%d"的格式写到str数组中</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">"2048:3.14,hello"</span>, str2[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从字符串读取格式化输入</span></span><br><span class="line"><span class="comment">    使得 n = 2048, db = 3.14, str2 = hello</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">"%d:%lf,%s"</span>, &amp;n, &amp;db, str2);</span><br><span class="line">    n = <span class="number">12</span>;</span><br><span class="line">    db = <span class="number">3.1415</span>;</span><br><span class="line">    str2[<span class="number">100</span>] = <span class="string">"good"</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    发送格式化输出到字符串</span></span><br><span class="line"><span class="comment">    使得 str = "12:3.14,good"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">"%d:%.2f,%s"</span>, n, db, str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="C-："><a href="#C-：" class="headerlink" title="C++："></a>C++：</h4><p>数字 <strong>转为 字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = to_string(num);</span><br><span class="line">len = str.length();</span><br></pre></td></tr></table></figure><hr><h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><ul><li>参数中数组的<strong>第一维不需要填写长度</strong>(如果是二维数组，<strong>第二维需要填写长度</strong>)</li><li><strong>在函数中对数组元素的修改 等同于 对原数组元素的修改</strong>(与普通局部变量不同)</li></ul><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[][<span class="number">5</span>])</span> </span>&#123;<span class="comment">//参数数组 第一维不需要填写长度，第二维需要填写长度</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    b[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//不适用C语言</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">5</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//不适用C语言</span></span><br><span class="line">    change(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出结果为：</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组不允许作为返回类型出现，<strong>想要返回数组，只能通过参数返回</strong></li></ul><hr><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li><p>C语言习惯于把<code>*</code>放在变量名之前：<code>int *p;</code>(声明多个指针时，<strong>易统一</strong>)</p></li><li><p>C++习惯把<code>*</code>放在数据类型之后：<code>int* p;</code></p></li><li><p><strong>地址赋给<code>p</code>而不是<code>*p</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = &amp;a; <span class="comment">//等价于 int* p = &amp;a;</span></span><br></pre></td></tr></table></figure></li><li><p>指针的加减法</p><ul><li>两个指针相减，得到两个地址的距离</li><li><code>p + 1</code>指 p所指的int型变量 的<strong>下一个int型变量地址</strong></li><li>指针<strong>支持自增和自减操作</strong></li></ul></li></ul><hr><h3 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h3><p>例子：<strong>交换两个数</strong></p><p><strong>只有在获取地址的情况下对元素进行操作，才能真正修改变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a, *p2 = &amp;b;</span><br><span class="line">    swap(p1, p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误写法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* tmp;</span><br><span class="line">    *tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *tmp;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tmp未初始化，存放的地址很大概率指向系统工作区间，不能修改，故后续报错</span></span><br><span class="line"><span class="comment">初始化tmp即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span>* tmp = &amp;x;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="引用的含义"><a href="#引用的含义" class="headerlink" title="引用的含义"></a>引用的含义</h4><p>引用是C++的语法，在编程时极为实用。如果要<strong>修改传入函数的参数，且不使用指针</strong>，可以通过<strong>C++的引用</strong>。引用<strong>不产生副本</strong>，只是<strong>给原变量起个别名</strong>。</p><p>引用的方法：在函数的<strong>参数变量名前加个<code>&amp;</code>即可</strong>。要将<strong>引用<code>&amp;</code></strong>与<strong>取地址运算符<code>&amp;</code></strong>区分开来，<strong>引用并不是取地址的意思</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    change(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x); <span class="comment">//输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h4><p>例子：<strong>交换两个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* tmp = a;</span><br><span class="line">    a = b; <span class="comment">//交换的地址 是 值传递，不会修改原指针的地址</span></span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过引用实现交换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* &amp;a, <span class="keyword">int</span>* &amp;b)</span> </span>&#123; <span class="comment">//通过引用实现交换</span></span><br><span class="line">    <span class="keyword">int</span>* tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a, *p2 = &amp;b;</span><br><span class="line">    swap(p1, p2); <span class="comment">//不能写成 swap(&amp;a, &amp;b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用是产生<strong>变量的别名，常量不可使用引用</strong>。故上述</p><blockquote><p><code>swap(p1, p2); //不能写成 swap(&amp;a, &amp;b);</code></p></blockquote><hr><h2 id="结构体（struct）的使用"><a href="#结构体（struct）的使用" class="headerlink" title="结构体（struct）的使用"></a>结构体（struct）的使用</h2><h3 id="访问结构体内的元素"><a href="#访问结构体内的元素" class="headerlink" title="访问结构体内的元素"></a>访问结构体内的元素</h3><p>假设<code>p</code>是一个指向结构的指针，可以用<strong><code>p-&gt;结构成员</code>的形式（等价于<code>(*p).结构成员</code>）</strong>，引用相应的结构成员。</p><hr><h2 id="algorithm-头文件"><a href="#algorithm-头文件" class="headerlink" title="algorithm 头文件"></a>algorithm 头文件</h2><h3 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h3><p>C语言的<code>qsort</code>函数的使用需要运用指针，且写法上没有C++的<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p><p><code>sort(首元素地址, 尾元素地址的下一个地址, 比较函数cmp(非必填))</code></p><p>如果<strong>不写比较函数cmp</strong>，则<strong>默认升序</strong>排序。如果想要<strong>降序</strong>排序，需要编写比较函数cmp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//返回值为true时，a被排在b之前</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">//降序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言和C++的比较</title>
      <link href="/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td><strong>scanf函数<br>printf函数</strong></td><td>cin<br>cout</td><td>cin 和 cout <strong>无需指定输入输出格式</strong>，<br>但<strong>消耗的时间</strong>比 scanf 和 printf <strong>多得多</strong></td></tr></tbody></table><hr><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><table><thead><tr><th>内容</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>输入输出库</td><td>#include &lt;stdio.h&gt;</td><td><strong>#include &lt;cstdio></strong><br><strong>#include &lt;iostream></strong></td></tr><tr><td>数学函数</td><td>#include &lt;math.h&gt;</td><td><strong>#include &lt;cmath></strong></td></tr><tr><td>字符串有关函数</td><td>#include &lt;string.h&gt;</td><td><strong>#include &lt;cstring></strong></td></tr></tbody></table><hr><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="布尔型变量"><a href="#布尔型变量" class="headerlink" title="布尔型变量"></a>布尔型变量</h3><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td>#include &lt;stdbool.h&gt;</td><td><strong>可直接使用</strong></td><td>true(存储时为1)<br>false(存储时为0)</td></tr></tbody></table><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>C语言：通过 字符数组 表示</li></ul><ul><li>C++：通过 string类 表示</li></ul><hr><h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><ul><li>C语言 — qsort</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b; <span class="comment">//升序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(排序数组, 元素数量, 每个元素的大小(可用<span class="keyword">sizeof</span>获得), 比较函数cmp);</span><br></pre></td></tr></table></figure><ul><li>C++ — sort</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">//降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(首元素地址, 尾元素地址的下一个地址, 比较函数cmp(非必填));</span><br></pre></td></tr></table></figure><table><thead><tr><th>cmp函数的区别</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>返回值类型</td><td>int</td><td>bool</td></tr><tr><td>排序的判断</td><td>返回值 &gt; 0, a 将被排在b后面;<br>返回值 &lt; 0, a 将被排在b前面;</td><td><strong>默认升序</strong><br>返回值为<strong>true</strong>时，a将被排在b<strong>前面</strong></td></tr><tr><td>比较方式</td><td>元素<strong>相减</strong><br>不能用$&gt;$、$&lt;$比较符（<strong>返回无负值</strong>）</td><td>$&gt;$、$&lt;$比较符</td></tr></tbody></table><p><code>qsort</code>函数的使用需要运用指针，且写法上没有<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启动U盘安装Ubuntu(单系统)</title>
      <link href="/2020/01/17/%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>/2020/01/17/%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>由于<strong>PE方式只适用于安装windows</strong>，因此选择常规的<strong>制作启动U盘</strong>进行Ubuntu的安装。</p><h3 id="操作系统镜像下载（桌面版，文件名后缀-iso-torrent）"><a href="#操作系统镜像下载（桌面版，文件名后缀-iso-torrent）" class="headerlink" title="操作系统镜像下载（桌面版，文件名后缀 .iso.torrent）"></a>操作系统镜像下载（桌面版，文件名后缀 .iso.torrent）</h3><ul><li>方式一：<a href="https://ubuntu.com/#download" target="_blank" rel="noopener">Ubuntu官网直接下载镜像</a></li><li>方式二：<a href="http://releases.ubuntu.com/18.04/" target="_blank" rel="noopener">Ubuntu官网下载镜像种子</a> + 迅雷下载镜像 （速度快，<strong>推荐</strong>）</li></ul><h3 id="3G及以上空间的U盘-移动硬盘-用于装载系统镜像"><a href="#3G及以上空间的U盘-移动硬盘-用于装载系统镜像" class="headerlink" title="3G及以上空间的U盘/移动硬盘(用于装载系统镜像)"></a><strong>3G及以上空间</strong>的U盘/移动硬盘(用于装载系统镜像)</h3><h3 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h3><ul><li><p>方式一：<strong>Windows 10 可以直接打开 iso镜像文件，不用下载任何工具</strong></p><ol><li><p>格式化U盘</p></li><li><p>双击ISO文件，然后选中打开的所有文件，复制到U盘即可</p></li></ol></li><li><p>方式二：<a href="http://rufus.ie/" target="_blank" rel="noopener">下载U盘制作制作工具Rufus</a>(<strong>无需安装，可直接运行</strong>)</p><ol><li><p>选择设备(需要被制作的U盘/移动硬盘)</p><ul><li>只有一个外接设备时会自动读取</li><li>如果<strong>外接设备是移动硬盘</strong>，需要<strong>显示高级设备选项 — 显示USB外置硬盘</strong></li></ul></li><li><p>选择操作系统镜像</p></li><li><p><strong>分区类型</strong>（<strong>理论上</strong>（联想Y480不知道为什么无法通过UEFI成功安装））</p><p><a href="https://www.bilibili.com/video/av45677113" target="_blank" rel="noopener">硬盘格式与引导方式、MBR与GPT、UEFI 与LEGACY bios的区别</a></p><ul><li><p>若选择GPT，之后系统安装时选择<strong>UEFI启动</strong>（<strong>推荐</strong>）</p></li><li><p>若选择MBR，之后系统安装时<strong>选择BIOS启动，否则报错</strong>（该模式一定能够安装成功）</p></li></ul></li><li><p>其余选项默认，点击<strong>开始</strong>，即可制作启动U盘</p></li></ol><p><img src="https://i.loli.net/2020/01/17/9KOmaTAQcIqdkpo.png" alt="Rufus制作启动U盘" style="zoom:80%;"></p></li></ul><hr><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol><li><p>重启电脑，进入<strong>选择启动方式界面</strong>（联想笔记本：F12；惠普笔记本：F9）</p></li><li><p>选择启动U盘</p><ul><li>想要安装系统的硬盘的格式为<strong>GPT</strong>，选择<strong>UEFI启动，即 EFI USB Device</strong></li><li>启动U盘分区类型为<strong>MBR</strong>，选择<strong>BIOS启动，即 选择对应的U盘</strong></li></ul></li><li><p>欢迎 — 中文 — 安装Ubuntu</p></li><li><p>键盘布局 — 汉语</p></li><li><p>无线 — 不连接</p></li><li><p>更新和其他软件 — <strong>最小安装</strong></p></li><li><p>安装类型 — 其他选项 — 进行分区</p><p>硬盘大小110GB</p><ul><li><p><strong>UEFI</strong>启动：</p><p>| 空间大小                    | 主分区/逻辑分区 | 类型                     |<br>| ————————— | ————— | ———————— |<br>| 200MB                       | <strong>逻辑分区</strong>    | <strong>EFI</strong>                  |<br>| 8GB<br>（和内存大小一致） | 主分区          | swap(交换)               |<br>| 40GB                        | 逻辑分区        | ext4<br>挂载至 “/”     |<br>| 剩余空间                    | 逻辑分区        | ext4<br>挂载至 “/home” |</p></li><li><p><strong>BIOS</strong>启动：</p><p>| 空间大小               | 主分区/逻辑分区 | 类型                |<br>| ———————- | ————— | ——————- |<br>| 200MB                  | <strong>主分区</strong>      | <strong>biosxx</strong>          |<br>| 8GB （和内存大小一致） | 主分区          | swap(交换)          |<br>| 40GB                   | 逻辑分区        | ext4 挂载至 “/”     |<br>| 剩余空间               | 逻辑分区        | ext4 挂载至 “/home” |</p></li></ul></li><li><p>完成安装，根据提示重启即可(可拔去启动U盘/硬盘，避免再次从启动U盘启动)</p></li></ol><hr><h2 id="将-从主服务器下载-更换为-国内镜像站点下载"><a href="#将-从主服务器下载-更换为-国内镜像站点下载" class="headerlink" title="将 从主服务器下载 更换为 国内镜像站点下载"></a>将 从主服务器下载 更换为 国内镜像站点下载</h2><p>​    显示应用程序 - 软件和更新 - Ubuntu软件 - 下载自 - 其他站点 - 选择最佳服务器（自动选择最合适的站点）</p><hr><h2 id="更新系统文件"><a href="#更新系统文件" class="headerlink" title="更新系统文件"></a>更新系统文件</h2><p><strong>打开终端</strong>的快捷键：<code>Ctrl</code>+<code>Alt</code>+<code>T</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><hr><h2 id="获得各种开发工具"><a href="#获得各种开发工具" class="headerlink" title="获得各种开发工具"></a>获得各种开发工具</h2><p><code>sudo apt-get install build-essential</code></p><ul><li><p>安装<strong>文字编辑器vim</strong>和<strong>浏览器chromium</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br><span class="line">sudo apt-get install chromium-browser</span><br></pre></td></tr></table></figure></li><li><p>树视图</p><p><code>sudo apt-get install tree</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmder</title>
      <link href="/2019/04/16/Cmder/"/>
      <url>/2019/04/16/Cmder/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载Cmder（压缩包，解压即用），有两种不同的版本可供选择：</p><ul><li>Mini</li><li>Full（附带msysgit工具）</li></ul><p>可根据设备是否已安装git自行选择</p><hr><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="添加系统环境变量"><a href="#添加系统环境变量" class="headerlink" title="添加系统环境变量"></a>添加系统环境变量</h3><p>我的电脑 - 右键属性 - 高级系统设置 - 环境变量 - 系统变量，在<code>Path</code>中添加Cmder路径</p><p><img src="https://i.loli.net/2019/04/16/5cb5a739330de.png" alt></p><hr><h3 id="添加Cmder到右键菜单"><a href="#添加Cmder到右键菜单" class="headerlink" title="添加Cmder到右键菜单"></a>添加Cmder到右键菜单</h3><ol><li><code>Win + R</code> - 输入<code>Cmder</code>，确认，打开Cmder</li><li>点击右下方的<code>Create new console</code></li><li>Startup command or {Task} name - {bash::bash}</li><li>Run as administrator</li><li>Start，即打开一个管理员权限的控制台 <img src="https://i.loli.net/2019/04/17/5cb6b470b7f0f.png" alt></li><li>输入 <code>Cmder.exe /REGISTER ALL</code>，回车。即可在每个文件夹中鼠标右键右键 - <code>Cmder here</code>，打开Cmder</li></ol><hr><h2 id="默认开启设置"><a href="#默认开启设置" class="headerlink" title="默认开启设置"></a>默认开启设置</h2><p>Cmder窗口右下角右键<code>Show system menu</code> - General - Choose your startup task or even a shell with arguments: - {bash::bash} - Save settings</p><p><img src="https://i.loli.net/2019/04/17/5cb6bbe028a30.png" alt></p><hr><h2 id="关闭Tab不提示"><a href="#关闭Tab不提示" class="headerlink" title="关闭Tab不提示"></a>关闭Tab不提示</h2><p>Cmder窗口右下角右键<code>Show system menu</code> - General - Confirm - Close confirmations下的复选框全不勾选 - Save settings</p><p><img src="https://i.loli.net/2019/04/17/5cb6bd25b23b6.png" alt></p><hr><p>参考：<a href="http://weikeqin.cn/2017/04/28/cmder-notes/" target="_blank" rel="noopener">Cmder 使用 笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dev-C++</title>
      <link href="/2019/04/16/Dev-Cpp/"/>
      <url>/2019/04/16/Dev-Cpp/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dev-C++是一个SourceForge的项目，<strong>早已停止更新</strong>。</p><p>缺点：</p><ul><li>分辨率低，脱节于屏幕素质的提升，使用感官不佳</li><li>中文注释容易乱码，且没有明显的选项用来修改编码格式</li></ul><hr><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>安装过程中的语言没有中文选项，选择English即可，按照默认选项安装。首次运行时，选择<strong>使用软件时的语言</strong>为简体中文即可，按照默认选项完成初运行配置。</p><hr><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul><li>菜单栏 - 工具 - 编辑器选项 - 语法 - 预设 - Obsidian 黑曜石主题</li></ul><p><img src="https://i.loli.net/2019/04/16/5cb598b4cba28.png" alt="工具 - 编辑器选项"></p><p><img src="https://i.loli.net/2019/04/16/5cb599bfef712.png" alt="语法 - 预设 - Obsidian 黑曜石主题"></p><ul><li><p>菜单栏 - 工具 - 编辑器选项 - 基本</p><ul><li style="list-style: none"><input type="checkbox" checked> 显示编辑器提示</li><li style="list-style: none"><input type="checkbox" checked> 显示函数提示</li><li>高亮显示当前行 - 色彩 - Black</li></ul><p><img src="https://i.loli.net/2019/04/16/5cb59bb680afc.png" alt></p></li></ul><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>菜单栏 - 工具 - 编辑器选项 - 显示 - 字体 - YaHei Consolas Hybrid</p><p>字体下载： <a href="https://pan.baidu.com/s/1kldCHl7A5SIZaCLJniLzwQ" target="_blank" rel="noopener"><a href="https://pan.baidu.com/s/1kldCHl7A5SIZaCLJniLzwQ" target="_blank" rel="noopener">Consolas和微软雅黑混合字体</a></a></p><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>自动整理代码</td><td>Ctrl + Shift + A</td></tr><tr><td>代码补全</td><td>Ctrl + Space(<strong>和输入法切换快捷键冲突</strong>)</td></tr></tbody></table><p>自定义快捷键：工具 - 快捷键选项 - 菜单项的底部 - Show Code Completion(代码补全)，自定义即可。</p><hr><h2 id="添加-C99-C-11-标准"><a href="#添加-C99-C-11-标准" class="headerlink" title="添加 C99/C++11 标准"></a>添加 C99/C++11 标准</h2><p>工具 - 编译选项 - 编译时加入以下命令 - <code>-std=c99</code>或<code>-std=C++11</code></p><p><img src="https://i.loli.net/2019/04/16/5cb59e4d63a98.png" alt></p><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”"><a href="#初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”" class="headerlink" title="初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”"></a>初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”</h3><p>菜单栏 - 工具 - 编译选项 - 代码生成/优化 - 连接器 - 产生调试信息 - Yes</p><p><img src="https://i.loli.net/2019/04/17/5cb6d8b4f11b0.png" alt></p><h3 id="调试窗口查看变量的实时数据"><a href="#调试窗口查看变量的实时数据" class="headerlink" title="调试窗口查看变量的实时数据"></a>调试窗口查看变量的实时数据</h3><p>开启调试后，有三种方式可以查看变量的实时数据：</p><ol><li>左侧调试窗口 - 空白处鼠标右键 - 添加查看</li><li>下侧调试窗口 - 添加查看</li><li>代码界面鼠标在变量名处停留，会显示当前变量值</li></ol><p><img src="https://i.loli.net/2019/04/17/5cb6dc99352a7.png" alt></p><hr><p>参考：</p><ul><li><del><a href="https://ice1000.org/2016/10/28/DevCpp/" target="_blank" rel="noopener">如何正确使用 DEV C++</a></del></li><li><a href="https://blog.csdn.net/MonkeyWang98/article/details/80202024" target="_blank" rel="noopener">DEV-C++调试时出现“项目没有调试信息，你想打开调试选项并重新生成吗”</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dev-C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>香港两日半 | 不妨长作岭南人</title>
      <link href="/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/"/>
      <url>/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="情之所起"><a href="#情之所起" class="headerlink" title="情之所起"></a>情之所起</h2><p>说起香港，脑海中闪过的第一个念头就是《重庆森林》——重庆大厦里奔走的林青霞、趴在半山扶梯上窥看编号633住处的王菲和她哼唱的《California Dreamin’》。终于要去见识这个憧憬太久的目的地了啊。</p><p>准备用完整的两天时间游览香港，从杭州出发，在三种方案中做选择： </p><ol><li>飞机直飞香港 （香港机场，位置较偏，根据实时价格、抵达时间综合考虑）</li><li>高铁直达香港（西九龙高铁站，高价、抵达时间深夜）</li><li>火车到<strong>深圳站</strong>，无缝衔接<strong>罗湖关口</strong>（硬卧￥360+ ~ ￥400，当天下午出发，隔天早上6点多或8点多抵达深圳站）</li></ol><p>由于勤(shi)俭(ge)节(qiong)约(bi)，同时为了能最大化利用在港时间，选择了方案3，买了03月19日的15:17杭州东站出发的T101次硬卧中铺，03月20日08:15抵达深圳站。03月22日16:00深圳站返程。</p><p>以及如下准备：  </p><ul><li style="list-style: none"><input type="checkbox" checked> 带上身份证去办港澳通行证（￥80）+ 香港团队旅游签注（￥15，<strong>现在团签可自助过关，与个签没有分别</strong>；7个工作日出证）  </li><li style="list-style: none"><input type="checkbox" checked> 去中国银行兑换1000港币  </li><li style="list-style: none"><input type="checkbox" checked> 买好路上的干粮</li><li style="list-style: none"><input type="checkbox" checked> 备好北纬22°所需衣物</li><li style="list-style: none"><input type="checkbox" checked> 预订酒店（一般酒店都备有转换插头，无需自带）</li><li style="list-style: none"><input type="checkbox" checked> 根据个人需求：淘宝买香港的x日电话卡；或在手机自带的全球上网一类app上购买流量包</li></ul><p><strong>冲冲冲！</strong></p><hr><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p>一夜的火车，从北纬30°到北纬22°，20+℃的气温暗示着夏天的气息。换上短袖，跟着指示牌前往关口。</p><p><img src="https://i.loli.net/2019/03/27/5c9b65af74dc6.jpeg" alt="标识牌"></p><p><img src="https://i.loli.net/2019/03/29/5c9db75b6307e.jpeg" alt="标识牌"></p><p>自助过关，机器读取港澳通行证，人脸+指纹识别后出内地关口，再经香港的检查人员核实身份后，即可入关。</p><p><img src="https://i.loli.net/2019/03/29/5c9db7a38f91a.jpeg" alt="自助查验标识"></p><p><img src="https://i.loli.net/2019/03/29/5c9db7cb6463a.jpeg" alt></p><p><img src="https://i.loli.net/2019/03/29/5c9db7e0dd89f.jpeg" alt></p><p>过关之后，先去柜台办了一张八达通，把1000港币破开。接着跟着标识牌去羅湖站坐港铁MTR。上了地铁以后，一看手机果然没有信号了，启用购买的流量包，在墙外的Internet上尽情呼吸。</p><h3 id="第一站-大學"><a href="#第一站-大學" class="headerlink" title="第一站 大學"></a>第一站 大學</h3><p><img src="http://p1-q.mafengwo.net/s13/M00/D4/7C/wKgEaVybmLqAcKOZAAj0436BHXM79.jpeg" alt="大學站"></p><p>大學站所指的大學是<strong>香港中文大學</strong>，一出地铁站就可以出现在校园之内。在香港中文大學可以初窥香港的地形，依山而建、高低错落，似极了重庆，对重庆曾经的小香港别称有了一丝恍然。来香港中文大學主要是为了打卡景点<strong>天人合一</strong>，顺便感受一下高等学府的环境与氛围。</p><p>校内有免费大巴可以乘坐，坐上可到<strong>新亚学院</strong>的车次，天人合一便只有几步之遥。</p><p>我以为能拍到的天人合一 和 我实际上拍到的天人合一……</p><p><img src="http://p2-q.mafengwo.net/s13/M00/15/90/wKgEaVybrXWAEF5lAA2DIiXf-E829.jpeg" alt="天人合一"></p><p>校园角落：</p><p><img src="http://p3-q.mafengwo.net/s13/M00/DA/16/wKgEaVybm9-AOh6xABCfboRpnSc44.jpeg" alt></p><p><img src="http://n3-q.mafengwo.net/s13/M00/DA/1C/wKgEaVybm-KAckzIAA5ElX33Oes68.jpeg" alt></p><p><img src="http://n4-q.mafengwo.net/s13/M00/DA/22/wKgEaVybm-WAPVXZABLFqn7fKRA87.jpeg" alt="头脑特工队"></p><p><img src="http://n1-q.mafengwo.net/s13/M00/DA/2A/wKgEaVybm-mAenGvABy4pAOS__I08.jpeg" alt="巴士站点的宝可梦装饰"></p><p><img src="https://i.loli.net/2019/03/29/5c9dba427e1d0.jpeg" alt="校园里很容易发现的宝可梦元素"></p><p><img src="http://p3-q.mafengwo.net/s13/M00/D5/6A/wKgEaVybmUaAOfqXAB-iQlRulA098.jpeg" alt></p><p>香港的车道上总会印着慢駛，斑马线上总会印着望左或望右，当我们在说城市的人文关怀的时候，我们在说什么：</p><p><img src="https://i.loli.net/2019/03/29/5c9dbd1e0f31c.jpeg" alt></p><p><img src="http://b1-q.mafengwo.net/s13/M00/D5/51/wKgEaVybmT2AWbyIAB88o5XJexk61.jpeg" alt="img"></p><hr><h3 id="第二站-彩虹"><a href="#第二站-彩虹" class="headerlink" title="第二站 彩虹"></a>第二站 彩虹</h3><p><img src="http://b4-q.mafengwo.net/s13/M00/DA/EC/wKgEaVybnGiATIJBABrUlqkj9j080.jpeg" alt="彩虹站"></p><p>逛完香港中文大學之后，继续坐上开往紅磡方向的東鐡綫，经由九龍塘换乘开往調景嶺方向的觀塘綫，在彩虹站下车，C3/C4口出站，<del>跟着感觉走就到了打卡点</del>跟着导航找到一个三层的<strong>停车楼</strong>，走上楼就到了彩虹邨的天台球场打卡点。</p><p><img src="http://n4-q.mafengwo.net/s13/M00/21/3A/wKgEaVyYpPWASCoxABbKpJXZH7g06.jpeg" alt></p><p>坪石邨就在彩虹邨附近，一并打卡。</p><p><img src="http://p2-q.mafengwo.net/s13/M00/21/47/wKgEaVyYpQKAX3IQABkI976-WGg74.jpeg" alt></p><hr><h3 id="第三站-旺角"><a href="#第三站-旺角" class="headerlink" title="第三站 旺角"></a>第三站 旺角</h3><p><img src="http://p1-q.mafengwo.net/s13/M00/DD/68/wKgEaVybnhWAfe3tAA8QRIHaSp453.jpeg" alt></p><p>预订的酒店在旺角站附近的新興大厦，12点多到酒店登记，接待的前台一口甜软的台湾腔，仿佛服务上升了一个台阶，因为两点之后房间才能清理好，把行李暂存到前台之后出门觅食。</p><p>奥海城有一家轮胎一星的添好運点心专门店，有点路，但也可以顺便熟悉一下市区，就慢慢摇过去。香港的红绿灯还有喇叭播放的摇铃提醒，通过不同的节奏来提供听觉上的交通信号。当我们在说城市设计的时候，我们在说什么。这家添好運不在商场内部，而是外围的街边店，用普通话取了号，但店员在叫号的时候只用粤语，结果就过号了Orz…最终跟另外一家口拼了一桌，得以入座。点了酥皮叉烧包、虾饺、牛肉肠粉，满足。</p><p>吃完之后，去逛香港特色的“二楼书店”。寸土寸金的香港，小众的个体书店隐匿于窄小楼梯通往的上层楼层，西洋菜街分布着多家二楼书店，这个时候导航显得十分无力<del>，果然还是要跟着感觉走</del>。有一定年头的旧式电梯和陈旧的楼道已经相辅相成，一迈进逼仄的楼道，隔着喧闹的街市，年代感迎面而来。</p><p>走在街道上，正巧看到宣扬法轮功和抵制邪教的横幅只有一布之隔，各自发声。下意识感慨神奇，心生羡慕。</p><p>最终在商务印书馆找到了想买的书，外面世界的书真不便宜。如果国内能出版的话，最多￥30+应该就能买到，不过可以理解成出版自由的附加值来抚慰自己，以及感谢支付宝的境外推广活动。</p><h3 id="第四站-尖沙咀"><a href="#第四站-尖沙咀" class="headerlink" title="第四站 尖沙咀"></a>第四站 尖沙咀</h3><p>逛完书店，回到住处入住了房间。躺下来补充一下体力之后，出门地铁前往尖沙咀。因为一心想趁着天还亮着，去拍香港文化中心，没有注意就在尖沙咀站附近的重庆大厦。走了一段距离，就走到了香港文化中心。</p><p>维港一瞥：</p><p>然后由西到东走了一遍星光大道，走马观花了一遍著名港星的手印和简介。麦兜作为出现在星光大道上的唯一卡通形象，“木有鱼丸，木有粗面”的麦兜在香港的地位可见一斑，虽然是在愚人节之前来香港，但猪年看到出乎意料的麦兜也算应景。</p><p>逛完了星光大道，想着走回尖沙咀站打卡重庆大厦。走进重庆大厦，一股闷热感和走动的印度面孔让人感慨电影中的重庆大厦的相关画面，但如今与当初相比，治安和清洁方面该是好了很多，其中实在逛无可逛。看了下地图，发现恰好有一家蘭芳園在重庆大厦负一层。但是不能被重庆大厦的入口所迷惑，因为走进重庆大厦的正门却没有走到负一层的路。只需在街道上往北走上几步路，就能看到地下入口。</p><p>点了丝袜奶茶和猪扒包</p><p>一起拼桌的两位，一位是港人、一位是白人，两人用粤语无障碍交流着，在个别词汇无法表达时，会夹杂着些许英语。在香港这样一个文化如此多元的地域，你很难不被多元的语言交流所感染。正吃着饭，一位内地游客看着我们这桌有一张空着的凳子，便用普通话问白人小哥：“这个位置有人坐吗？”白人小哥停下交流，回头一瞥，同样用普通话回答道：“呃…没有。”不禁感叹白人小哥真的有、东西。吃完晚饭，准备起身结账时，不小心撞了一下桌子，把拼桌两位的饮料洒了一些出来，脑海中瞬间闪过一个念头：“我该说sorry还是对唔住还是唔好意思？”结果怂怂地用普通话说了两句：“不好意思”…</p><p>吃完饭出来天色已暗，不逛诚品，不足以谈人生？诚品书店名声在外，听了太多年，正好海港城有分店，就去逛了逛。逛过之后，才明白逛诚品书店为什么能消磨时间，想来算是个商场中的商场。</p><h3 id="第五站-跑馬地赛马场"><a href="#第五站-跑馬地赛马场" class="headerlink" title="第五站 跑馬地赛马场"></a>第五站 跑馬地赛马场</h3><p>逛完诚品，走向天星碼头，坐天星小轮到对岸，再去跑馬地馬场看每周三的赛马。原本想坐到湾仔碼头（莫名想吃水饺…），一不留神坐上了去往中环碼头的轮渡。</p><p>在天星小轮上一赏维港夜景：</p><p>到达对岸之后，前往公交站，坐上去跑馬地馬场的巴士。到站后发现，票价港币$10的<strong>公众入口只有G口</strong>，还需要往南走上一段路。刷八达通即可入场感受人声鼎沸、灯火通明的香港赌马文化。其中酒水餐饮一应俱全，不得不感叹赛马的魅力。</p><h3 id="第六站-廟街"><a href="#第六站-廟街" class="headerlink" title="第六站 廟街"></a>第六站 廟街</h3><p>看完一场赛马之后，准备坐巴士去廟街。巴士的站点正好在一座印度廟前，正好遇到当天仪式的印度人一家又一家地从中走出，再次感叹文化的多元。廟街不如想象中的热闹，想到极限挑战好想在这里取过景。一家家街角的大排档确实有让人想一尝的想法，但是单人旅途确实和大排档不合适。笔直的廟街中间是搭起棚子的贩卖各色饰品、服装、玩具纪念品的小摊贩，两侧的商铺则有形形色色的食铺、覆上帘子的成人影片店铺，还能看到几位穿着暴露的性服务者… 最后，找到了拍廟街远景的停车楼，我想象中能拍到的廟街 和 我实际上拍到的廟街：</p><p>在麥文記麺家吃了一碗云吞面作宵夜，好像就是running man去吃过的那家。</p><p>走了3万步的一天终于结束了…</p><hr><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h2><h3 id="第七站-翠园金華冰厅"><a href="#第七站-翠园金華冰厅" class="headerlink" title="第七站 翠园金華冰厅"></a>第七站 <del>翠园</del>金華冰厅</h3><p>原本想去翠园（旺角新世纪广场店）吃早茶，在路上找到一片涂鸦墙，真好啊。</p><p>10点多找到店铺后，排号的人已不少，感觉不一定能在11：30前的早茶时间吃完，遂作罢。正好发现金華冰厅就在附近，<del>屁颠屁颠</del>走到店里，点了菠萝油和冻奶茶，菠萝油也太好吃了8？！</p><h3 id="第八站-香港大學"><a href="#第八站-香港大學" class="headerlink" title="第八站 香港大學"></a>第八站 香港大學</h3><p>Pillar of Shame</p><h3 id="第九站-半山扶梯"><a href="#第九站-半山扶梯" class="headerlink" title="第九站 半山扶梯"></a>第九站 半山扶梯</h3><p>原本应该从香港大學出发去卢吉道，但是Google地图用不惯……高德的导航没有给出一个合适的路线，只好曲线救国，先去打卡半山扶梯。</p><p>太平山街周边的涂鸦</p><p>拍了皇后大道、皇后大道西、皇后大道中，最后没有去打卡一下皇后大道东，<del>算了反正都没有皇宫</del>。</p><p>想不起来是先去吃的翠華餐廰还是先逛的半山扶梯。去翠華吃了咖喱牛腩饭和冻鸳鸯。</p><p>半山扶梯</p><h3 id="第十站-太平山顶"><a href="#第十站-太平山顶" class="headerlink" title="第十站 太平山顶"></a>第十站 太平山顶</h3><p><del>智障级徒步曲线爬坡，无数次感慨这就是重庆地形</del>登上凌霄阁观景台，真真正正的一滴都没有了。走了一段卢吉道，回想李尚敏坐红眼航班登卢吉道看香港日出的片段之后，排队缆车下山。</p><h3 id="第十一站-幻彩咏香江"><a href="#第十一站-幻彩咏香江" class="headerlink" title="第十一站 幻彩咏香江"></a>第十一站 <del>幻彩咏香江</del></h3><p>坐巴士去再興燒臘飯店，点了叉烧饭和鱼蛋菜汤。鱼蛋菜汤加了猪油，味道香浓。最后光盘行动…得到了老板娘“好靓仔”的夸奖…</p><p>拖着一滴都没有了的残躯，想去湾仔碼头的观景台看夜景。在8点过几分之后到达，发现是幻彩咏香江的盲区…香港岛这一侧的灯光是主体部分，在湾仔碼头却完美地被建筑遮挡，无法看到。后来发现就在碼头左侧的金紫荆广场应该是香港岛这一侧的优质观景位置。金紫荆广场上有着许多的香港动漫人物的塑像，如步惊云、陈浩南及许多卡通式人物，和对岸的星光大道有遥相呼应的味道。</p><p>从湾仔站打道回府，结束因徒步太平山而被掏空的一天…</p><hr><h2 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h2><h3 id="第十二站-翠园早茶"><a href="#第十二站-翠园早茶" class="headerlink" title="第十二站 翠园早茶"></a>第十二站 翠园早茶</h3><p>稍微比昨天早一点到了翠园，取号之后马上被叫到了号，如愿以偿吃上早茶。龙井+凤爪+豉汁蒸排骨+瑶柱灌汤饺。我对茶餐厅真的没有抵抗力啊…</p><h3 id="第十三站-买买买"><a href="#第十三站-买买买" class="headerlink" title="第十三站 买买买"></a>第十三站 买买买</h3><p>找了一家卖美国保健品的店铺，其中一个店员只会粤语和英语，结账时，为脑子里能出现checkout而感到欣慰… 赶在12点的退房时间前整理好行李退房 。屈臣氏、万宁、莎莎、卓悦等等不表…</p><h3 id="第十四站-重回香港中文大學"><a href="#第十四站-重回香港中文大學" class="headerlink" title="第十四站 重回香港中文大學"></a>第十四站 重回香港中文大學</h3><p>买好必需品后，乘上返程的地铁，想着适合解决午饭的地点。于是又回到开始的地方，轻车熟路去了众志堂食堂，自助点餐冻柠茶+烧味双拼饭后，八达通付款，吃完了在香港的最后一顿，Happy Ending。</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>过关安检、15:00进深圳站。返程的火车上，一群上海老年旅游团好不闹热，其乐融融的气氛能很好地感染他人。</p><p>遇到一个在义乌做生意的60岁韩国大叔。用我蹩脚的韩语+英语表达了我对running man、无限挑战、2天1夜的喜爱之情，尝了他分享的海苔。大叔说自己在中国吃面只吃打着新疆招牌的面和温州海鲜面哈哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优雅使用Windows 10</title>
      <link href="/2019/03/18/%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8Windows-10/"/>
      <url>/2019/03/18/%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8Windows-10/</url>
      
        <content type="html"><![CDATA[<h2 id="桌面效果图"><a href="#桌面效果图" class="headerlink" title="桌面效果图"></a>桌面效果图</h2><p><img src="https://i.loli.net/2019/03/28/5c9c986753d63.png" alt="Win 10桌面"></p><hr><h2 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h2><ul><li>PDF阅读器： <a href="https://www.gaaiho.com/index.php/zh-cn/products/reader/pdf-reader-pc/overview" target="_blank" rel="noopener">文电通PDF阅读器</a></li><li>视频播放器：<a href="https://daumpotplayer.com/download/" target="_blank" rel="noopener">PotPlayer</a></li><li>广告拦截：<a href="http://www.admflt.com/" target="_blank" rel="noopener">阿呆喵</a></li><li>解压缩软件：<a href="https://cn.bandisoft.com/bandizip/" target="_blank" rel="noopener">Bandizip</a></li><li>百度网盘全速下载：<a href="https://pandownload.com/" target="_blank" rel="noopener">PanDownload</a></li><li>UWP：DailyPic(Bing的每日壁纸，可选择性下载中意的壁纸作为桌面背景)</li></ul><hr><h2 id="系统速度优化"><a href="#系统速度优化" class="headerlink" title="系统速度优化"></a>系统速度优化</h2><p><code>Ctrl + alt + Esc</code>打开任务管理器 - 启动 - 选择需要禁用的开机启动项</p><hr><h2 id="任务栏透明化"><a href="#任务栏透明化" class="headerlink" title="任务栏透明化"></a>任务栏透明化</h2><p>Microsoft Store下载<strong>TranslucentTB</strong>，启动。</p><ul><li><strong>Open at boot</strong>(开机启动)</li><li><strong>Regular - Clear</strong>（常规 - 透明）</li></ul><hr><h2 id="滑动关机"><a href="#滑动关机" class="headerlink" title="滑动关机"></a>滑动关机</h2><ol><li><code>Win + S</code>唤出Cortana，搜索<code>SlideToShutdown</code>，选择打开文件位置</li><li>右键 - 发送到 - 桌面快捷方式</li><li>右键 - 属性 - 快捷键，自定义滑动关机快捷键，如<code>Ctrl + Alt + 1</code></li><li>如果想将滑动关机固定到任务栏，见<a href="#Win-10-风格图标">Win 10 风格图标</a></li></ol><hr><h2 id="Win-10-风格图标"><a href="#Win-10-风格图标" class="headerlink" title="Win 10 风格图标"></a>Win 10 风格图标</h2><p>注：仅适用于PC端软件，UWP应用不可用。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>图标素材网站：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>；<a href="https://www.easyicon.net/" target="_blank" rel="noopener">easyicon</a></li><li>PNG格式图标在线转为ico格式图标网站：<a href="https://www.easyicon.net/covert/" target="_blank" rel="noopener">iconvert</a></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>找到需要转换图标的软件快捷方式（如果不是快捷方式，右键 - 发送到 - 桌面快捷方式，统一进行转换）</li><li>在素材网站筛选合适的图标，选择下载<strong>白色</strong>的PNG格式图标</li><li>将图标转为ico格式，下载统一存放（便于管理）</li><li>右键软件快捷方式 - 属性 - 更改图标 - 浏览 - 在ico图标存放地址选择相应图标 - 确定</li><li>右键软件快捷方式 - 固定到任务栏</li><li>删除桌面上的软件快捷方式</li></ol><hr><h2 id="任务栏图标居中"><a href="#任务栏图标居中" class="headerlink" title="任务栏图标居中"></a>任务栏图标居中</h2><ol><li>桌面新建文件夹</li><li>右键任务栏空白处 - <strong>取消勾选</strong>锁定任务栏</li><li>右键任务栏空白处 - 工具栏 - 新建工具栏 - 选择桌面新建的文件夹</li><li>向左拖动新建的工具栏，将应用程序栏挤到右侧</li><li>右键新建的工具栏 - <strong>取消勾选</strong> 显示文本 和 显示标题</li><li>将应用程序栏拖拽到合适的位置后，锁定任务栏</li></ol><hr><h2 id="桌面的系统相关图标隐藏"><a href="#桌面的系统相关图标隐藏" class="headerlink" title="桌面的系统相关图标隐藏"></a>桌面的系统相关图标隐藏</h2><p><code>Win + i</code>打开设置 - 个性化 - 主题 - 相关的设置 - 桌面图标设置 - 取消勾选相应图标即可隐藏</p><hr><h2 id="资源管理器像浏览器一样使用Tab标签页"><a href="#资源管理器像浏览器一样使用Tab标签页" class="headerlink" title="资源管理器像浏览器一样使用Tab标签页"></a>资源管理器像浏览器一样使用Tab标签页</h2><ol><li>下载安装<a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener">QTTabBar</a></li><li><code>Win + E</code>打开资源管理器，查看 - 选项 - 勾选GTTabBar(注：选项按钮上方的默认图形只是选项的其中一项，<strong>需点击选项文字</strong>)，此时资源管理器就多出了标签栏</li><li>右键标签栏空白处 - QTTabBar Options - General - Download language file - 选择更新日期较近的简体中文（注：<strong>下载语言文件需要科学上网</strong>，附<a href="https://pan.baidu.com/s/1mc2Ubnh5JfEoELu5EnIKTg" target="_blank" rel="noopener">百度网盘资源</a>）- apply即可汉化</li><li>标签栏的”+”按钮默认为<strong>浏览文件夹并打开新标签</strong>，比较麻烦。右键标签栏空白处 - QTTabBar 选项 - 鼠标事件 - 标签和标签栏 - 点击标签栏的”+”按钮 - 用户命令 - 创建一个新命令 - 命令的类型 - 文件和文件夹 - 路径（根据个人喜好选择默认打开路径）</li><li>按照个人喜好调整功能</li></ol><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">Win + 数字</td><td style="text-align:left">对应任务栏从左到右固定的程序</td></tr><tr><td style="text-align:left">Win + A</td><td style="text-align:left">通知中心</td></tr><tr><td style="text-align:left">Win + L</td><td style="text-align:left">锁屏</td></tr><tr><td style="text-align:left">Win + D</td><td style="text-align:left">回到桌面/当前界面</td></tr><tr><td style="text-align:left">Win + W</td><td style="text-align:left">WINDOWS INK 工作区</td></tr><tr><td style="text-align:left">Win + - ( + )</td><td style="text-align:left">放大镜</td></tr><tr><td style="text-align:left">Win + Q/S</td><td style="text-align:left">Cortana</td></tr><tr><td style="text-align:left">Win + E</td><td style="text-align:left">文件资源管理器</td></tr><tr><td style="text-align:left">Win + I</td><td style="text-align:left">Windows 设置</td></tr><tr><td style="text-align:left">Win + K</td><td style="text-align:left">蓝牙</td></tr><tr><td style="text-align:left">Ctrl + Alt + Esc</td><td style="text-align:left">任务管理器</td></tr><tr><td style="text-align:left">Win + Ctrl + ⬅/➡</td><td style="text-align:left">切换至相邻的虚拟桌面</td></tr><tr><td style="text-align:left">Win + Shift + S</td><td style="text-align:left">可框选截图</td></tr><tr><td style="text-align:left">Win + Printscreen</td><td style="text-align:left">全屏截图</td></tr></tbody></table><hr><h2 id="触摸板手势"><a href="#触摸板手势" class="headerlink" title="触摸板手势"></a>触摸板手势</h2><table><thead><tr><th>手势</th><th>功能</th></tr></thead><tbody><tr><td>单指点击两次 + 拖动</td><td>多选</td></tr><tr><td>两指拖动</td><td>滚动页面</td></tr><tr><td>两指捏合</td><td>缩放</td></tr><tr><td>三指上滑</td><td>多任务视图</td></tr><tr><td>三指下滑</td><td>显示桌面</td></tr><tr><td>三指左右滑动</td><td>切换应用</td></tr><tr><td>三指单击</td><td>唤出Cortana</td></tr><tr><td>四指单击</td><td>通知中心</td></tr><tr><td>四指左右滑动</td><td>切换虚拟桌面</td></tr></tbody></table><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/yourng/article/details/83013726" target="_blank" rel="noopener">QTTabBar 简单配置</a></li><li><a href="https://sspai.com/post/45594" target="_blank" rel="noopener">Windows 虚拟桌面的高效启动技巧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新笔记本电脑验机</title>
      <link href="/2019/03/18/%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E9%AA%8C%E6%9C%BA/"/>
      <url>/2019/03/18/%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E9%AA%8C%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>准备：下载<strong>卡硬工具箱免安装版</strong>至U盘或其他移动设备。</p><p><strong>以下任何一步有问题，退货。</strong></p><ol><li>检查笔记本外壳是否有<strong>指纹、裂痕、凹陷</strong>，机身是否有<strong>变形</strong>，屏幕是否<strong>完好</strong>。</li><li>USB接口是否有抽插痕迹。</li><li><strong>不插电源，直接按电源键</strong>，若<strong>能开机，则很可能是二手</strong>。</li><li>插上电源，按电源键开机。</li><li>进入系统，系统初始化设置（<strong>若没有设置界面，直接进入了系统，二手</strong>）。</li><li><strong>不连接网络</strong>，防止后续检查有问题无法退货。</li><li>进入桌面后，插上有卡硬工具箱的U盘。<ol><li>显示器工具 - 检测屏幕坏点。</li><li>硬盘工具 - Diskinfo - 检查通电次数和通电时间（<strong>一般通电时间在24小时内，通电次数在150次以内，可以判定为新机硬盘</strong>）。</li></ol></li></ol><p><strong>上述步骤没有出现问题后，依然不要联网，在无理由退货时间内使用电脑，以便后续使用不满意时方便退货。</strong></p><hr><p>参考：<a href="https://zhuanlan.zhihu.com/p/40181275" target="_blank" rel="noopener">笔记本电脑验机指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 验机与续命 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 验机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联想Y480拆机清灰</title>
      <link href="/2019/03/18/%E8%81%94%E6%83%B3Y480%E6%8B%86%E6%9C%BA%E6%B8%85%E7%81%B0/"/>
      <url>/2019/03/18/%E8%81%94%E6%83%B3Y480%E6%8B%86%E6%9C%BA%E6%B8%85%E7%81%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="彻底拆机清灰（涂硅脂、更换）"><a href="#彻底拆机清灰（涂硅脂、更换）" class="headerlink" title="彻底拆机清灰（涂硅脂、更换）"></a><a href="http://ideapad.it168.com/thread-5334703-1-1.html" target="_blank" rel="noopener">彻底拆机清灰</a>（涂硅脂、更换）</h2><h2 id="清理键盘"><a href="#清理键盘" class="headerlink" title="清理键盘"></a>清理键盘</h2><ol><li>键盘在D面有<strong>两个螺丝固定</strong>，先卸下D面挡板，再卸下键盘螺丝、固定光驱的螺丝。</li><li>按照彻底拆机的拆卸键盘方法即可取下键盘。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 验机与续命 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拆机 </tag>
            
            <tag> 清灰 </tag>
            
            <tag> 保养 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑屏幕色差矫正</title>
      <link href="/2019/03/18/%E7%94%B5%E8%84%91%E5%B1%8F%E5%B9%95%E8%89%B2%E5%B7%AE%E7%9F%AB%E6%AD%A3/"/>
      <url>/2019/03/18/%E7%94%B5%E8%84%91%E5%B1%8F%E5%B9%95%E8%89%B2%E5%B7%AE%E7%9F%AB%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<ul><li>电脑屏幕色彩管理软件：LUT Manager</li><li>MAC自带的颜色配置文件：MAC.icc</li><li>适用系统：Windows  </li></ul><hr><ol><li>下载<a href="https://pan.baidu.com/s/1p1jvs2lUirS_KbFI7T7w4g" target="_blank" rel="noopener">LUT Manager和MAC.icc</a></li><li>将MAC.icc放到<code>系统盘/windows/system32/spool/drivers/color/</code>目录下</li><li>打开控制面板（查看方式-图标）- 颜色管理 - 高级 - 更改系统默认值 - 高级 - 使用Windows显示器校准 - 关闭</li><li>设备 - 显示器 - 使用我对此设备的设置 - 添加 - 选择MAC.icc - 设置为默认配置文件 - 关闭</li></ol><hr><p>参考：<a href="https://www.mooyuu.com/school/985/#downs" target="_blank" rel="noopener">矫正色差的软件</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 屏幕色差 </tag>
            
            <tag> LUT Manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE方式安装Windows 10</title>
      <link href="/2019/03/18/PE%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Windows-10/"/>
      <url>/2019/03/18/PE%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Windows-10/</url>
      
        <content type="html"><![CDATA[<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>可以更改硬盘格式与引导方式</li><li>可以备份原有系统的数据</li><li>自带修复软件，可以在不重装系统的情况下修复系统</li></ol><hr><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>PE安装工具下载：<a href="http://www.wepe.com.cn/download.html" target="_blank" rel="noopener">微PE工具箱</a></li><li>操作系统镜像下载：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN</a></li><li><strong>8G及以上空间</strong>的U盘/移动硬盘(主要用于存放系统镜像)</li></ul><hr><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol><li><p>安装PE到U盘/移动硬盘</p></li><li><p>将操作系统镜像放到U盘（或移动硬盘对应的存储分区）</p></li><li><p>重启电脑，进入<strong>选择启动方式界面</strong>（联想笔记本：F12；惠普笔记本：F9）</p></li><li><p>选择PE所在设备，即启动PE</p></li><li><p>启动桌面上的<strong>Windows安装器</strong>：</p><ul><li><p>第一行：选择操作系统镜像文件</p></li><li><p>第二行（选择引导驱动器）：想要安装系统的硬盘的格式（<a href="https://www.bilibili.com/video/av45677113" target="_blank" rel="noopener">硬盘格式与引导方式、MBR与GPT、UEFI 与LEGACY bios的区别</a>）不同，需要选择的盘区也不同。</p><ol><li>GPT格式：选择ESP分区（大约90~250MB大小的一个隐藏盘区）</li><li>MBR格式：选择要装系统的盘区即可</li></ol><p><strong>两种方式都需要右边的三个指示灯不为红色（黄绿两色OK）</strong></p></li><li><p>第三行（安装磁盘的位置）：选择系统将要安装的盘区即可。</p></li><li><p>第四行：选择安装的Win 10版本。</p></li></ul><p>完成以上四行内容即可点击开始安装。</p><p>​    注：用 DiskGenius 格式化硬盘/转换硬盘格式 时记得勾选<strong>对齐分区到此扇区数的整数倍</strong>（即4K对齐，无需修改具体参数）。</p></li><li><p>重启系统，进行Win 10的初始化设置，<strong>建议进入桌面后再联网</strong>，操作过程会快一些。</p></li></ol><hr><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><p>去官网下载驱动安装，或者下载<strong>驱动精灵免安装版</strong>安装驱动（另外，Windows自身的更新会下载部分相关驱动）。</p><p>注：部分<strong>旧机型</strong>官网没有Windows10版本的相关驱动，不建议官网下载相关旧驱动，很可能不兼容。直接使用驱动精灵无脑安装基本驱动即可。</p><p>注注：博主的老机子联想Y480的触摸板在驱动精灵中没有相关的驱动，无法使用Win10的触摸板手势，但是<strong>鲁大师的驱动检测功能下可以看到触摸板驱动，选择升级即可使用手势</strong>。博主猜测此方法同样适用于部分老机型，不得不赞美一下娱乐大师。</p><p>注注注：Elitebook 830 G5的固态硬盘是三星的PM961，需要加上Turbo驱动提速，官网没有直接的链接，可以通过驱动精灵安装。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/av45170351" target="_blank" rel="noopener">Win 10全面官方装系统教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的基本概念</title>
      <link href="/2018/07/18/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/07/18/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>传统的C语言用法中，变量名使用小写字母，符号常量名使用大写字母</p><hr><h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符signed与unsigned可以用于<strong>限定char类型或任何整型</strong>。</p><ul><li><code>signed</code> （默认）<br>如char类型 <code>signed char</code>，取值范围为-128~127</li><li><code>unsigned</code> （<strong>无符号类型</strong>）<br>总是正值或0，例如char类型，<code>unsigned char</code> 取值范围为0~255</li></ul><hr><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><ul><li><p><strong>方法一： const 数据类型 变量名 = 常量；</strong>（<strong>推荐</strong>）</p><p>例： <code>const int AMOUNT=100;</code></p><p><code>const</code>也能配合<strong>数组参数</strong>使用，表明函数不能修改数组元素的值。</p></li><li><p><strong>方法二：#define 标识符 常量</strong><br><strong>末尾没有分号</strong><br>例：<code>#define LOWER 0</code></p></li></ul><hr><h2 id="定义布尔类型"><a href="#定义布尔类型" class="headerlink" title="定义布尔类型"></a>定义布尔类型</h2><ul><li>需要在开头写如下代码：<code>#include &lt;stdbool.h&gt;</code></li></ul><p>布尔类型为<code>bool</code> (Java中为Boolean)</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>例：<code>int number[100];</code> (Java中为 int[] number = new int[100];)</p><p>（C99开始，<strong>可以用变量定义数组大小</strong>）</p><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><ul><li><p><strong>列数必须给出</strong>，行数可以交给编译器来数</p></li><li><p>每行一个<code>{}</code>，用逗号分隔<code>,</code></p></li><li><p>最后的<code>,</code>可以存在，有古老的传统</p></li><li><p>如果内容省略，表示补0</p></li><li><p>也可以用定位（C99 ONLY）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">3</span>, <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>用<code>[n]</code>在初始化数据中给出定位</li><li>没有定位的数据接在前面的位置后面</li><li>其他位置的值补零</li><li>也可以不给出数组大小，让编译器算</li><li>特别适合初始数据稀疏的数组</li></ul></li></ul><h3 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h3><p><code>sizeof(a)/sizeof(a[0])</code></p><ul><li><code>sizeof</code>给出整个数组所占据的内容的大小，单位是字节</li><li><code>sizeof(a[0])</code>给出数组中单个元素的大小，相除就得到了数组的单元个数</li><li>数组作为函数的参数时 实际是指针（数组的地址）,<strong>需要用另一个参数来传入数组的大小</strong><ul><li>不能在<code>[]</code>中给出数组的大小</li><li>不能再利用<code>sizeof</code>来计算数组的元素个数</li></ul></li></ul><h3 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h3><ul><li>数组变量本身<strong>不能被赋值</strong></li><li>要把一个数组的所有元素交给另一个数组，必须采用遍历</li></ul><hr><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>char是一种整数，也是一种特殊的类型——字符。</p><ul><li><code>&#39;&#39;</code>也是一个字符</li><li><code>printf</code>和<code>scanf</code>里用<code>%c</code>来输入输出字符</li></ul><h3 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h3><table><thead><tr><th>字符</th><th>意义</th></tr></thead><tbody><tr><td><code>\b</code></td><td>回退一格</td></tr><tr><td><code>\t</code></td><td>到下一个表格位</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\\</code></td><td>反斜杠本身</td></tr></tbody></table><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>C语言的编译器自上而下，按顺序分析代码</strong>。</p><p><strong>函数的先后顺序</strong>很重要。</p><p>C语言的函数可以将声明和定义分离，从而顺利通过编译,如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>; <span class="comment">//声明，函数原型， 如果没有参数，括号内最好填写 void，更严谨</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">//main的参数部分也可以写 void</span></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">sum(<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d到%d的和是%d\n"</span>, begin, end, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul><li>调用函数时，<strong>给的值可以与参数类型不完全匹配</strong>，编译器自行转换类型，（Java则对类型转换要求严格）。</li><li>C语言调用函数传参数时，是<strong>值传递</strong>。</li></ul><hr><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><ul><li><p>一元运算符<code>&amp;</code><br>获取变量的地址，它的<strong>操作数必须是变量</strong>，没有其他的运算包括其中。<br><code>p = &amp;c;</code> 称p为“指向”c的指针。</p></li><li><p>一元运算符<code>*</code><br>间接寻址运算符。<code>*</code>作用于指针时，将访问指针所指向的变量。</p></li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针就是<strong>保存地址的变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p,q; <span class="comment">//p为指针，值为所指向的地址；*p是int类型变量，为所指向地址上的值；</span></span><br></pre></td></tr></table></figure><h3 id="指针应用场景"><a href="#指针应用场景" class="headerlink" title="指针应用场景"></a>指针应用场景</h3><ol><li><p>交换两个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *pa;</span><br><span class="line">    *pa = *pb;</span><br><span class="line">    *pb = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数需要返回多个值，某些值就只能通过指针返回</p></li></ol><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><ol><li><p>指针是const（<strong>*在const前</strong>）：表示一旦得到了某个变量的地址，不能再指向其他变量；<strong>不影响改变该地址上的值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> q = &amp;i; <span class="comment">//q是const</span></span><br><span class="line">*q = <span class="number">26</span>; <span class="comment">//所指变量的值可以更改</span></span><br><span class="line">q++; <span class="comment">//ERROR!</span></span><br></pre></td></tr></table></figure></li><li><p>所指的类型是const（<strong>*在const后</strong>）：表示不能通过指针去修改那个变量（<strong>不会使那个变量成为const</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i; <span class="comment">// int const *p 作用相同</span></span><br><span class="line">*p = <span class="number">26</span>; <span class="comment">//ERROR! (*p)是const</span></span><br><span class="line">i = <span class="number">26</span>; <span class="comment">//OK</span></span><br><span class="line">p = &amp;j; <span class="comment">//OK</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><p>以下四种函数原型等价</p><ul><li><code>int sum(int *arr, int n);</code></li><li><code>int sum(int *, int);</code></li><li><code>int sum(int arr[], int n);</code></li><li><code>int sum(int [], int)</code></li></ul><p><strong>数组变量是特殊的指针</strong></p><ul><li>数组无需用&amp;取地址</li><li><p>数组的单元表达的是变量，需要用&amp;取地址</p></li><li><p><code>[]</code>运算符可以对数组做，也可以对指针做<br><code>p[0] &lt;==&gt; a[0]</code></p></li><li><p><code>*</code>运算符可以对指针做，也可以对数组做</p></li><li><p>数组变量是const的指针，所以不能被赋值<br><code>int a[] &lt;==&gt; int *const a=...</code></p></li></ul><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C语言的字符串以字符数组的形态存在</p><ul><li>不能用运算符对字符串做运算<ul><li>通过数组的方式可以遍历字符串</li></ul></li></ul><p>以整数0结尾的一串字符为字符串。（0或<code>\0</code>是一样的，但是和<code>&#39;0&#39;</code>不同）</p><ul><li><strong>0标志字符串的结束，但不是字符串的一部分</strong></li><li>字符串以数组的形式存在，以数组或<strong>指针(主)的形式访问</strong></li><li><code>string.h</code>里有很多处理字符串的函数</li></ul><h3 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> word[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> line[<span class="number">10</span>] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>例如：<code>Hello</code>，字符串会被编译器变成一个字符数组放在某处，这个数组的<strong>长度是5+1</strong>，结尾还有<strong>表示结束的0</strong></p><p>例：<code>char* s = &quot;Hello, world!&quot;;</code></p><ul><li>s是一个指针，初始化为指向一个字符串常量<ul><li>由于这个常量存储的地方，实际上s为<code>const char* s</code>。(历史原因，编译器接受不带const的写法)</li><li>试图对s所指的字符串做写入会导致严重的后果</li></ul></li><li>如果需要修改字符串，应该用数组：<code>char s[] = &quot;Hello, world!&quot;;</code></li></ul><p><strong>选择指针还是数组形式处理字符串？</strong></p><ul><li><p>数组（字符串就存放在当前位置，<strong>如果要构造一个字符串</strong>）</p><ul><li>作为本地变量，空间被自动回收</li></ul></li><li><p>指针（不知道字符串的存储位置，<strong>如果要处理一个字符串</strong>）</p><ul><li>处理参数</li><li>动态分配空间</li></ul></li></ul><hr><h2 id="读入、输出数据"><a href="#读入、输出数据" class="headerlink" title="读入、输出数据"></a>读入、输出数据</h2><ul><li>需要在开头写如下代码：<code>#include &lt;stdio.h&gt;</code></li></ul><p>读取数据，需要在变量名前加上<code>&amp;</code>，从而赋值给变量。</p><h3 id="EOF（End-Of-File"><a href="#EOF（End-Of-File" class="headerlink" title="EOF（End Of File)"></a>EOF（End Of File)</h3><p>可以通过<code>printf(&quot;%d&quot;, EOF);</code>读取EOF的数值，一般的设备上值是-1。<br>EOF操作：</p><ul><li>windows：<code>Ctrl + Z</code></li><li>unix：<code>Ctrl + D</code></li></ul><h3 id="浮点数的输入输出"><a href="#浮点数的输入输出" class="headerlink" title="浮点数的输入输出"></a>浮点数的输入输出</h3><ul><li>输入：<code>scanf(&quot;%lf&quot;, ...);</code></li><li>输出：<ul><li><code>printf(&quot;%f&quot;, ...);</code> //float和double类型，printf函数都使用%f进行说明</li><li><code>printf(&quot;%ld&quot;, ...);</code> //对应long整型的参数</li></ul></li></ul><h3 id="字符的输入-输出"><a href="#字符的输入-输出" class="headerlink" title="字符的输入/输出"></a>字符的输入/输出</h3><ul><li>输入 <code>getchar()</code><br>从文本流中读入下一个输入字符，并将其作为结果值返回。</li><li>输出 <code>putchar(c)</code><br>打印一个字符</li></ul><h3 id="字符串的输入输出"><a href="#字符串的输入输出" class="headerlink" title="字符串的输入输出"></a>字符串的输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p>scanf读入一个单词（到空格、tab或回车为止）</p><hr><ul><li><code>program &lt;infile</code><br>从输入文件<code>infile</code>中读取字符。</li><li><code>otherprogram | program</code><br>将程序<code>otherprogram</code>的标准输出 通过管道，重定向到程序program的标准输入上。 </li></ul><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul><li><code>&amp;</code> 与</li><li><code>|</code> 或</li><li><code>^</code> 异或</li><li><code>~</code> 求反码</li><li><code>&gt;&gt;</code> 右移（高位出现的空位，原来高位是什么，就用什么补该空位；<code>&gt;&gt;&gt;</code>无符号右移，<strong>高位的空位用0补</strong>）</li></ul><hr><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li><p>外部</p><ul><li>用<code>static</code>声明限定外部变量与函数，可以将对象的<strong>作用域限定为被编译源文件的剩余部分</strong>。</li><li>通过<code>static</code>限定外部对象，可以达到隐藏外部对象的目的。</li><li>如果把函数名声明为static类型，则该函数名除了对该函数的声明所在的文件可见外，其他文件都无法访问。</li></ul></li><li><p>内部</p><ul><li><code>static</code>类型的内部变量，不管其所在函数是否被调用，都会存在。（一直占据存储空间；自动变量：随着函数的 调用/退出 而 存在/消失）</li></ul></li></ul><h2 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h2><p><code>register</code>声明告诉编译器，它所声明的变量在程序中使用频率较高</p><hr><h2 id="结构（和java中的类-概念类似-只有变量没有函数）"><a href="#结构（和java中的类-概念类似-只有变量没有函数）" class="headerlink" title="结构（和java中的类 概念类似,只有变量没有函数）"></a>结构（和java中的类 概念类似,只有变量没有函数）</h2><p>关键字<code>struct</code>引入结构声明。</p><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>关键字<code>struct</code>后面的名字是可选的，称为<strong>结构标记</strong>。</p><ul><li><p>有结构标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt</span> = &#123;</span><span class="number">320</span>, <span class="number">200</span>&#125;; <span class="comment">//定义了一个struct point类型的变量pt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt2</span> = &#123;</span>.y = <span class="number">200</span>, .x = <span class="number">320</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>无结构标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; p1, p2; <span class="comment">//p1、p2都是无标记结构，里面有x和y</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>结构的合法操作只有几种：<strong>作为一个整体赋值和赋值（包括向函数传递参数以及从函数返回值）</strong>，通过<code>&amp;</code>运算符取地址，访问其成员。</p><p>例：函数<code>makepoint</code>，带有两个整型参数，并返回一个point类型的结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct point <span class="title">makepoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">temp</span>;</span></span><br><span class="line">temp.x = x;</span><br><span class="line">temp.y = y;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结构指针</strong>的使用频度非常高，为了使用方便，C语言提供了另一种简写方式。假设<code>p</code>是一个指向结构的指针，可以用<code>p-&gt;结构成员</code>的形式（等价于<code>(*p).结构成员</code>），引用相应的结构成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct point* <span class="title">getStruct</span><span class="params">(struct point *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, p-&gt;x, p-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言提供一个编译时的一元运算符sizeof，可以用来<strong>计算任一对象的长度</strong>。</p><p><code>sizeof 对象</code>和<code>sizeof(类型名)</code>会返回一个整型值，等于指定对象或类型<strong>占用的存储空间字节数</strong>。</p><h3 id="类型定义-typedef"><a href="#类型定义-typedef" class="headerlink" title="类型定义 (typedef)"></a>类型定义 (typedef)</h3><p><code>typedef</code>用来<strong>建立新的 数据类型名</strong>。<br>例如，声明<code>typedef int Length;</code><br>将Length定义为与int具有同等意义的名字，Length与类型int完全相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span> &#123;</span><span class="comment">//ADate同样可以略去</span></span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125; Date; <span class="comment">//简化了复杂的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可正常构造结构后，按如下方式定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span> <span class="title">Date</span>;</span></span><br></pre></td></tr></table></figure><hr><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>C99之前无法用变量作为数组定义的大小，当时如何解决该问题？</p><p><code>malloc</code>函数：在需要时，向操作系统申请存储空间，需要<code>#include &lt;stdlib.h&gt;</code>。</p><p><code>void* malloc(size_t size);</code></p><ul><li>向malloc申请的空间的大小以字节为单位</li><li>返回的结果是<code>void*</code>，需要类型转换为需要的类型。例如<code>int *a = (int*)malloc(n*sizeof(int))</code></li></ul><p>因为程序中的某些地方可能不通过 malloc调用 申请空间，所以，<strong>malloc管理的空间不一定是连续的</strong>。</p><h3 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h3><p><code>free(a);</code><br><strong>malloc得到的空间一定要有free的习惯，只能free申请来的空间的首地址</strong></p><hr><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a><code>gets()</code></h3><p>gets()函数包含于stdio.h头文件，会一直读取用户输入，直至换行为止；而scanf一直读至空格键</p><hr><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul><li><p><code>strlen</code> 字符串长度<br><code>size_t strlen (const char *s);</code> 返回s的字符串长度，不包括结尾的0</p></li><li><p><code>strcmp</code> 比较字符串<br><code>int strcmp (const char *s1, char *s2);</code> 比较字符串的大小，返回两者 第一个不同的字符的差值</p></li><li><p><code>strncmp</code> 比较字符串</p><p><code>int strncmp (const char *s1, const char *s2, size_t n)</code> 比较字符串，<code>n</code>为比较的字符数量，若前n个字符相同，返回0 </p></li><li><p><code>strcpy</code> 复制<br><code>char* strcpy(char *restrict dst, const char *restrict src);</code> 把src的字符串复制给dst<br><strong><code>restrict</code>表明src和dst不重叠</strong>，返回dst</p><p>复制字符串的操作示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(dst,src);</span><br></pre></td></tr></table></figure><p><code>memcpy</code>复制</p><p><code>void* memcpy (void*dest, const void *src, size_t n);</code></p><p><strong>与<code>strcpy</code>相比，<code>memcpy</code>并不是遇到’\0’就结束，而是一定会拷贝完n个字节。</strong></p></li><li><p>字符串中找字符<br><code>char* strchr(const char *s, int c);</code><br><code>char* strrchr(const char *s, int c);</code><br>返回NULL表示没有找到</p></li><li><p>字符串中找字符串<br><code>char* strstr(const char *s1, const char *s2);</code><br><code>char* strcasestr(const char *s1, const char *s2); //忽略大小写 查找字符串</code> </p></li><li><p>连接字符串</p><p><code>char *strcat(char *dest, const char *restrict src);</code>将参数 src 字符串复制到参数 dest 所指的字符串尾部</p></li></ul><hr><h3 id="标准库函数-qsort排序"><a href="#标准库函数-qsort排序" class="headerlink" title="标准库函数 qsort排序"></a>标准库函数 qsort排序</h3><p>C语言有<code>qsort()</code>；C++有<code>sort()</code>；Java有<code>Arrays</code>类</p><p><code>qsort()</code>声明在stdlib.h文件中。<br><code>void qsort(void *base,size_t nelem,size_t width,int (*cmp)(const void *,const void *));</code></p><ul><li><p>base:<br>要排序的数组</p></li><li><p>nmemb:<br>数组中的元素数目</p></li><li><p>size:<br>每个数组元素占用内存空间，可使用sizeof获得</p></li><li><p>cmp:<br>比较两个数组元素的比较函数，返回值是<strong>int类型</strong>。比较函数的第一个参数值a与参数b，<strong>此函数需要自定义</strong></p><ul><li>返回值 &gt; 0, a 将被排在b后面;</li><li>返回值 &lt; 0, a 将被排在b前面;</li><li>示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123; <span class="comment">//升序</span></span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">long</span> <span class="keyword">int</span> *)b; <span class="comment">//不能用'&gt;'、'&lt;'比较符(返回无负值)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="转换字符大小写"><a href="#转换字符大小写" class="headerlink" title="转换字符大小写"></a>转换字符大小写</h3><p>函数声明在&lt;ctype.h&gt;文件中：</p><p><code>int tolower(int c)</code></p><p><code>int toupper(int c)</code></p><hr><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li><p>枚举是用关键字<code>enum</code>来声明的一种自定义的数据类型：</p><p><code>enum 枚举类型名字 {名字0, 名字1, ..., 名字n};</code></p></li><li><p>枚举类型名字<strong>通常不使用</strong>，大括号中的名字就是<strong>常量符号，类型是int，值依次从0到n</strong>。</p><p>如<code>enum color {red, yellow, green};</code></p></li><li><p><strong>主要应用：当需要一些可以排列起来的常量值时，定义枚举就是为了给这些常量值名字</strong></p></li><li><p>枚举类型可以跟上enum作为类型：<code>void f(enum color c);</code>；<code>enum color t = red;</code></p></li></ul><h3 id="枚举量"><a href="#枚举量" class="headerlink" title="枚举量"></a>枚举量</h3><ul><li>声明枚举量的时候可以指定值：<code>enum color {red = 1, yellow, green = 5};</code></li></ul><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="构造结点"><a href="#构造结点" class="headerlink" title="构造结点"></a>构造结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><h3 id="构造链表"><a href="#构造链表" class="headerlink" title="构造链表"></a>构造链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node *head;</span><br><span class="line">&#125; List;</span><br></pre></td></tr></table></figure><hr><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="全局变量初始化"><a href="#全局变量初始化" class="headerlink" title="全局变量初始化"></a>全局变量初始化</h3><ul><li><strong>没有做初始化的全局变量会得到0值</strong><ul><li>指针会得到NULL值</li></ul></li><li>只能用编译时刻已知的值来初始化全局变量</li><li>它们的初始化发生在main函数之前</li></ul><p><strong>如果函数内部存在与全局变量同名的变量，则全局变量被隐藏</strong></p><h3 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a>静态本地变量</h3><ul><li>在本地变量定义时加上<code>static</code>修饰符就成为静态本地变量，<strong>没有做初始化的静态变量会得到0值</strong></li><li><strong>当函数离开的时候，静态本地变量会继续存在并保持其值</strong></li><li>静态本地变量的初始化只在第一次进入该函数时，以后进入函数会保持上次离开的值</li></ul><p><strong>静态本地变量是特殊的全局变量</strong></p><hr><h2 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h2><ul><li><code>#</code>开头的是编译预处理指令</li></ul><h3 id="define-用来定义宏"><a href="#define-用来定义宏" class="headerlink" title="#define 用来定义宏"></a>#define 用来定义宏</h3><ul><li><code>#define &lt;名字&gt; &lt;值&gt;</code>（结尾没有分号，不是C语句）</li><li>名字必须是一个单词，值可以是各种东西</li><li>在C语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字换成值（文本替换）</li></ul><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>如果一个宏的<strong>值中有其他宏的名字</strong>，也会被替换</li><li>如果宏的值超过一行，最后一行之前的行末需要加<code>\</code></li><li>宏的值后边的注释不会被当作宏的值的一部分</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRT printf(<span class="meta-string">"%f "</span>, PI); \</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, PI2)</span><br></pre></td></tr></table></figure><h3 id="预定义的宏"><a href="#预定义的宏" class="headerlink" title="预定义的宏"></a>预定义的宏</h3><ul><li>_LINE_ ：当前行号</li><li>_FILE_ ：文件路径</li><li>_DATE_ ：日期</li><li>_TIME_ ：时间</li></ul><h3 id="带参数的宏的原则"><a href="#带参数的宏的原则" class="headerlink" title="带参数的宏的原则"></a>带参数的宏的原则</h3><ul><li><p>一切都要括号</p><ul><li>整个值要括号</li><li>参数出现的每个地方都要括号</li></ul><p>例：<code>#define RADTODEG(x) ((x)*57.29578)</code></p></li><li><p>可以带多个参数</p><p><code>#define MIN(a,b) ((a)&gt;(b)?(b):(a))</code></p></li><li><p>也可以组合（嵌套）使用其他宏</p></li></ul><h3 id="include-头文件"><a href="#include-头文件" class="headerlink" title="#include 头文件"></a>#include 头文件</h3><p>将included的文件的全部内容原封不动d地插入到所在位置，因此也不一定要在.c文件最前面<code>#include</code></p><ul><li><code>#include &quot;xxx.h&quot;</code> （要求编译器首先在当前目录寻找该文件，如果没有，到编译器指定目录去找）</li><li><code>#include &lt;xxx.h&gt;</code> （让编译器只在指定目录寻找）</li></ul><p>把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中<code>#include</code>这个头文件，就能让编译器在编译的时候知道函数的原型。<code>#include</code>和宏一样在是编译预处理指令。</p><p><strong><code>#include</code>不是用来引入库的</strong>，<code>stdio.h</code>中只有printf等函数的原型，用来保证调用时给出的参数值是正确的类型。printf的代码在另外的地方，某个.lib（Windows）或.a（Unix）中。现在的C语言编译器默认会引入所有的标准库。</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul><li>在使用和定义这个函数的地方都应该<code>#include</code>这个头文件</li><li>一般的做法是任何.c文件都有对应同名的.h文件，把所有对外公开的函数原型和全局变量的声明放进去</li></ul><h3 id="不对外公开的函数"><a href="#不对外公开的函数" class="headerlink" title="不对外公开的函数"></a>不对外公开的函数</h3><ul><li>在函数前加上<code>static</code>使其成为只能在<strong>所在编译单元中</strong>被使用的函数</li><li>在全局变量前面加上<code>static</code>使其成为只能在<strong>所在编译单元中</strong>被使用的全局变量</li></ul><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><ul><li><code>int i;</code>是变量的定义（产生代码）</li><li><code>extern int i;</code>是变量的声明（不产生代码）</li></ul><h3 id="标准头文件结构"><a href="#标准头文件结构" class="headerlink" title="标准头文件结构"></a>标准头文件结构</h3><ul><li><p>运用条件编译和宏，保证这个头文件在一个编译单元中只会被<code>#include</code>一次</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LIST_HEAD__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIST_HEAD__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"node.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span> &#123;</span></span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p><code>%[flags][width][.prec][hlL]type</code></p><ul><li>Flag</li></ul><table><thead><tr><th>Flag</th><th>含义</th></tr></thead><tbody><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>强制显示符号（正数会显示+）</td></tr><tr><td>(space)</td><td>正数留空</td></tr><tr><td>0</td><td>0填充</td></tr></tbody></table><ul><li>width</li></ul><table><thead><tr><th>width或prec</th><th>含义</th></tr></thead><tbody><tr><td>number</td><td>最小字符数（总长，包括小数点后的位数）</td></tr><tr><td>*</td><td>下一个参数是字符数，例：<code>printf(&quot;%*d, 6, 123&quot;);</code></td></tr><tr><td>.number</td><td>小数点后的位数</td></tr><tr><td>.*</td><td>下一个参数是小数点后的位数</td></tr></tbody></table><ul><li>hlL</li></ul><table><thead><tr><th>hlL（类型修饰）</th><th>含义</th></tr></thead><tbody><tr><td>hh</td><td>单个字节</td></tr><tr><td>h</td><td>short</td></tr><tr><td>l</td><td>long</td></tr><tr><td>ll</td><td>long long</td></tr><tr><td>L</td><td>long double</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th>type</th><th>用于</th></tr></thead><tbody><tr><td>i 或 d</td><td>int</td></tr><tr><td>u</td><td>unsigned int</td></tr><tr><td>o</td><td>八进制</td></tr><tr><td>x</td><td>十六进制</td></tr><tr><td>X</td><td>字母大写的十六进制</td></tr><tr><td>f 或 F</td><td>float</td></tr><tr><td>e 或 E</td><td>指数</td></tr><tr><td>g</td><td>float</td></tr><tr><td>G</td><td>float</td></tr><tr><td>a 或 A</td><td>十六进制浮点数</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>n</td><td>读入/写出的个数</td></tr></tbody></table><h3 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h3><p><code>%[flag]type</code></p><ul><li>flag</li></ul><table><thead><tr><th>flag</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>跳过</td></tr><tr><td>数字</td><td>最大字符数</td></tr><tr><td>hh</td><td>char</td></tr><tr><td>h</td><td>short</td></tr><tr><td>l</td><td>long, double</td></tr><tr><td>ll</td><td>long long</td></tr><tr><td>L</td><td>long double</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>int</td></tr><tr><td>i</td><td>整数，也可以是16进制、8进制</td></tr><tr><td>u</td><td>unsigned int</td></tr><tr><td>o</td><td>8进制</td></tr><tr><td>x</td><td>16进制</td></tr><tr><td>a, e, f, g</td><td>float</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>[…]</td><td>允许的字符（例：<code>*[^,]</code>是到<code>,</code>之前的所有字符都跳过）</td></tr><tr><td>p</td><td>指针</td></tr></tbody></table><hr><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h3><ul><li><p><code>&amp;</code> 与</p><p>相同位上都为1，结果为1；否则结果为0</p></li><li><p><code>|</code> 或</p><p>相同位上至少一个是1，结果为1；否则结果为0</p></li><li><p><code>~</code> 取反</p><p>把1位变0，0位变1</p></li><li><p><code>^</code> 异或</p><p>如果两个位相等，结果为0；两个位不相等，结果为1。</p><p>对一个变量用同一个值异或两次，变量不变（可用于加密）</p></li></ul><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul><li><p><code>&lt;&lt;</code> 左移</p><ul><li><p><code>i &lt;&lt; j</code>：i中所有的位向左移动j个位置，<strong>右边填入0</strong></p></li><li><p><code>x &lt;&lt;= n</code> 等价于x *= $2^n$</p></li></ul></li><li><p><code>&gt;&gt;</code> 右移</p><ul><li><code>i &gt;&gt; j</code>：i中所有的位向右移j个位置。unsigned类型，左边填入0；signed类型，左边填入原来的最高位</li><li><code>x &gt;&gt;= n</code> 等价于x /= $2^n$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下的一些终端操作</title>
      <link href="/2018/06/27/Ubuntu%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/27/Ubuntu%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="终端界面的说明"><a href="#终端界面的说明" class="headerlink" title="终端界面的说明"></a>终端界面的说明</h2><p>示例：<br><code>hunter@Hunter-PC:~$</code></p><ul><li>最左侧的<code>hunter</code>是<strong>目前用户的账号</strong></li><li>@之后的<code>Hunter-PC</code>是<strong>主机名</strong></li><li><code>~</code>是<strong>目前所在目录</strong>；<code>~</code>为<strong>当前用户的home目录</strong></li><li><code>$</code>是<strong>提示字符</strong>；root的提示符为<code>#</code>，普通用户为<code>$</code></li></ul><p>登录后取得的程序被称为<code>Shell</code>(壳，因为该程序负责最外面跟使用者沟通，被戏称称为壳程序）</p><p>在Linux下平常<strong>最好使用一般账号来登录</strong>，需要动用到系统功能修订时，再使用root。</p><hr><h2 id="操作说明及技巧"><a href="#操作说明及技巧" class="headerlink" title="操作说明及技巧"></a>操作说明及技巧</h2><p><strong>Linux严格区分大小写</strong>。</p><p>在指令列模式里面下达指令时，会有两种主要的情况：</p><ul><li>直接显示结果，然后回到命令提示字符，等待下一个指令的输入</li><li>进入到该指令的环境，直到结束该指令，回到命令提示字符的环境</li></ul><hr><ul><li>指令太长的时候，可以使用<code>\</code>使指令连续到下一行。<code>\</code>后需要立刻接<br><strong>回车</strong>，才能跳脱！</li></ul><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + Alt + T</td><td>打开终端</td></tr><tr><td>Shift + Ctrl + C/V</td><td>复制/粘贴</td></tr></tbody></table><hr><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><p><strong>Linux命令中，参数一般是无序的，特殊情况除外</strong>。</p><h3 id="更新系统文件"><a href="#更新系统文件" class="headerlink" title="更新系统文件"></a>更新系统文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p><code>sudo apt-get install xxx（程序名）</code></p><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><ul><li><p><code>sudo apt-get remove -purge xxx(程序名)</code></p></li><li><p><code>sudo apt autoremove</code></p></li></ul><h3 id="磁盘管理命令"><a href="#磁盘管理命令" class="headerlink" title="磁盘管理命令"></a>磁盘管理命令</h3><ul><li><p>注销Linux：<code>exit</code>(Linux本身还在运行，只是退出了登录的操作)</p></li><li><p>语系</p><ul><li>显示目前支持的语系：<br>  <code>locale</code></li><li><p>修改语系：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.utf8</span><br><span class="line">export LC_ALL=en_US.utf8</span><br></pre></td></tr></table></figure><p>LANG只与<strong>输出讯息</strong>有关，若需要更改其他不同的信息，要同步更新<code>LC_ALL</code>。</p></li></ul></li><li><p>显示日期：<code>date</code></p></li><li><p>计算器：<code>bc</code>(win10的ubuntu子系统需要先安装)<br>  事实上，该操作是<strong>进入到<code>bc</code>这个软件的工作环境</strong>。<br>  　　<code>bc</code>预设仅<strong>输出整数</strong>，如果要输出小数，需要先执行<code>scale=number</code>，<code>number</code>是小数点位数</p><ul><li>要离开<code>bc</code>，需要输入<code>quit</code>命令</li></ul></li><li><p>转换成root用户：<code>sudo su</code></p></li><li><p>展示文件和目录：<code>ls</code></p><ul><li><code>-a/--all</code> 展示当前目录下<strong>所有文件和目录</strong>（隐藏文件和特殊目录以<code>.</code>开头）</li><li><code>-l</code> 查询详细列表(可以组合使用<code>-al</code>)</li><li><code>-h</code> 友好展示信息<br><code>ls -l</code>可以简写为<code>ll</code></li></ul></li><li><p>切换目录：<code>cd</code></p><ul><li><code>~</code> 当前用户的家目录</li><li><code>/</code> 根目录</li><li><code>-</code> 切换到上次访问的目录</li></ul></li><li><p>显示当前所在目录：<code>pwd</code>(print working directory)</p></li><li><p>创建目录：<code>mkdir</code></p><ul><li><code>-p</code>(parents) 父目录不存在的情况下，生成父目录</li><li><code>-v</code> 显示命令执行过程中的详细信息</li></ul></li><li><p>删除<strong>空</strong>目录：<code>rmdir</code></p></li></ul><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><ul><li><p>快捷查看当前文件的内容：<code>cat</code>，<strong>适合查看少量信息的文件</strong></p></li><li><p>分页显示内容，标注每行的行号：<code>less -mN</code>(<strong>适用于大量数据的查看</strong>)</p><ul><li><code>回车</code> 向下n行（需要定义，默认为1行）</li><li><code>空格</code> 向下一页</li><li><code>b</code> 向上一页</li><li><code>q</code> 退出</li></ul></li><li><p>快速查看文件后n行的内容：<code>tail -n</code>(<strong>查看日志</strong>)</p></li><li><p>复制文件/目录：<code>cp 需要复制的文件 复制的位置</code></p><ul><li><code>-r/--recursive</code> 递归处理，将指定目录下的子目录一并处理<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求：把/root/Demo.java 文件复制到 /root/t1 目录中，改名为d.java</span><br><span class="line">位置：root</span><br><span class="line">命令：cp Demo.java t1/d.java</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>文件移动：<code>mv 需要移动的文件 移动的位置</code></p><ul><li><code>-f</code> 强制性覆盖</li><li><strong>文件/目录重命名操作</strong>：<code>mv 原文件 新文件名</code>（原文件名即转换为新文件名）</li></ul></li><li><p>文件/目录删除：</p><ul><li><code>rm 文件名</code><ul><li><code>-f/--force</code> 强制删除</li><li><code>-r/--recursive</code> 递归处理，将指定目录下的子目录一并处理</li></ul></li><li><code>rm -rf 目录</code></li></ul></li><li><p>查找文件或目录：<code>find [目录名] -name &#39;需要查找的字符串&#39;</code>（不填写目录名则在当前目录下查找）</p></li><li><p>压缩、解压命令：<code>tar</code></p><ul><li><code>-c</code> 建立一个压缩文件(create)</li><li><code>-x</code> 解开一个压缩文件(extract)</li><li><code>-z</code> 用gzip压缩</li><li><code>-v</code> 压缩过程中显示文件(verbose)</li><li><code>-f</code> 使用档名，在f之后要接档名(file)</li></ul></li></ul><p>Linux的压缩包格式：<code>*.tar</code>(打包不压缩)、<code>*.tar.gz</code>(打包并压缩文件大小)</p><pre><code>- 压缩：`tar -zcvf 压缩包名.tar.gz 需要压缩的内容`例如`tar -zcvf test.tar.gz *`(将当前目录下内容进行打包压缩)- 解压：`tar -zxvf 需要解压的压缩包名.tar.gz [-C 指定解压路径]`</code></pre><h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><ul><li><p>查看系统进程：<code>ps -ef</code>(Process Status) 同时会显示执行ps命令的进程信息<br>示例：<code>ps -ef | grep -i vim</code> 查看vim相关的进程</p></li><li><p>强制结束进程：<code>kill -9 pid号</code></p></li><li><p>显示网络设备：<code>ifconfig</code></p></li><li>测试和目标的连通性：<code>ping ip地址</code></li></ul><h3 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h3><ul><li>权限更改：<code>chmod 权限设置 需要更改权限的文件</code><ul><li><code>-R/--recursive</code> 递归处理<br>示例：</li><li>更改所属用户(user)的权限：<code>chmod u=rwx test.txt</code></li><li>更改所属组(group)的权限：<code>chmod g=rx test.txt</code></li><li>更改其他用户(other)的权限：<code>chmod o=rx test.txt</code></li><li>更改所有用户(all)的权限：<code>chmod a=r test.txt</code></li></ul></li></ul><hr><h2 id="几个重要的热键"><a href="#几个重要的热键" class="headerlink" title="几个重要的热键"></a>几个重要的热键</h2><ul><li><p><code>Tab</code><br><code>Tab</code>具有<strong>命令补全</strong>和<strong>文件补齐</strong>的功能，<strong>可以避免打错指令或文件名</strong>。</p><ul><li><code>Tab</code>接在一串指令的第一个字的后面，则为<strong>命令补全</strong></li><li><code>Tab</code>接在一串指令的第二个字以后时，则为<strong>文件补齐</strong></li></ul></li><li><p><code>Ctrl + c</code>：中断目前程序</p></li><li><p><code>Ctrl + d</code>: 键盘输入结束；也可以用来取代<code>exit</code>的输入</p></li><li><p><code>Ctrl + PgUp/PgDown</code>：翻页（指令执行后，显示的内容很长时可以用到）</p></li></ul><hr><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><h3 id="指令名后加上-help"><a href="#指令名后加上-help" class="headerlink" title="指令名后加上--help"></a>指令名后加上<code>--help</code></h3><p>即可查看指令的用法，如<code>cal --help</code>。</p><h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>　　<code>man</code>是<code>manual</code>(操作说明)的简写，通过<code>man 指令名</code>进入的画面，就是<code>man page</code>。</p><p><strong>man page下</strong>能使用的相关操作：  </p><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PgDn</td><td>向下翻一页</td></tr><tr><td>PgUp</td><td>向上翻一页</td></tr><tr><td>Home</td><td>去到第一页</td></tr><tr><td>End</td><td>去到最后一页</td></tr><tr><td><code>/string</code></td><td>向<strong>下</strong>搜寻string这个字符串，如果要搜寻vbird 的话，就输入/vbird</td></tr><tr><td><code>?string</code></td><td>向<strong>上</strong>搜寻string 这个字符串</td></tr><tr><td><code>n, N</code></td><td>利用<code>/</code>或<code>?</code>来查找字符串时，可以用<code>n</code>来继续下一个查找，利用<code>N</code>来进</td></tr></tbody></table><p>行<strong>反向查找</strong> |<br>| q | 结束这次的man page |</p><hr><p>示例（<code>man date</code>）:<br><img src="https://i.loli.net/2019/03/28/5c9c99ef62fbb.png" alt="man date操作之后的页面"></p><p>在页面第一行，可以看到<code>DATE(1)</code>，<code>DATE</code>是指令名称，<code>(1)</code>代表<strong>一般用户可使用的指令</strong>。</p><table><thead><tr><th style="text-align:right">代号</th><th>代表内容</th></tr></thead><tbody><tr><td style="text-align:right">1</td><td>用户在shell 环境中可以操作的指令或可执行文件</td></tr><tr><td style="text-align:right">2</td><td>系统核心可呼叫的函数与工具等</td></tr><tr><td style="text-align:right">3</td><td>一些常用的函数(function)与函式库(library)，大部分为C 的函式库(libc)</td></tr><tr><td style="text-align:right">4</td><td>装置文件的说明，通常在/dev 下的文件</td></tr><tr><td style="text-align:right">5</td><td>配置文件或者是某些文件的格式</td></tr><tr><td style="text-align:right">6</td><td>游戏(games)</td></tr><tr><td style="text-align:right">7</td><td>惯例与协议等，例如Linux 文件系统、网络协议、ASCII code 等等的说明</td></tr><tr><td style="text-align:right">8</td><td>系统管理员可用的管理指令</td></tr><tr><td style="text-align:right">9</td><td>跟kernel 有关的文件</td></tr></tbody></table><hr><p><code>man page</code>大致分成以下几个部分：</p><table><thead><tr><th>代号</th><th>内容说明</th></tr></thead><tbody><tr><td>NAME</td><td>简短的指令、数据名称说明</td></tr><tr><td>SYNOPSIS</td><td>简短的指令下达语法(syntax)简介</td></tr><tr><td>DESCRIPTION</td><td>较为完整的说明，这部分最好仔细看看！</td></tr><tr><td>OPTIONS</td><td>针对SYNOPSIS 部分中，有列举的所有可用的选项说明</td></tr><tr><td>COMMANDS</td><td>当这个程序(软件)在执行的时候，可以在此程序(软件)中下达的指令</td></tr><tr><td>FILES</td><td>这个程序或数据所使用或参考或连结到的某些文件</td></tr><tr><td>SEE ALSO</td><td>可以参考的，跟这个指令或数据有相关的其他说明！</td></tr><tr><td>EXAMPLE</td><td>一些可以参考的范例</td></tr></tbody></table><p>在查询某个数据时可以这样来查阅：</p><ol><li>先察看NAME的项目，看一下这个资料的意思</li><li>再详看一下DESCRIPTION，这个部分会提到很多相关的资料与使用时机，从这个地方可以学到很多小细节</li><li>如果这个指令已经很熟悉了，主要就是查询关于OPTIONS的部分，可以知道每个选项的意义，可以下达比较细部的指令内容</li><li>最后再看一下，跟这个资料有关的还有哪些东西可以使用。举例来说，date的<code>SEE ALSO</code>就告知我们还可以利用<code>info coreutils date</code>来进一步查阅数据；</li><li>某些说明内容还会列举有关的文件(FILES部分)来提供我们参考！这些都是很有帮助的！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据请求的具体扩展名、请求头不同，返回不同格式的相同内容</title>
      <link href="/2018/06/14/%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A9%E5%B1%95%E5%90%8D%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E5%86%85%E5%AE%B9/"/>
      <url>/2018/06/14/%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A9%E5%B1%95%E5%90%8D%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="内容协商多视图"><a href="#内容协商多视图" class="headerlink" title="内容协商多视图"></a>内容协商多视图</h2><p><a href="https://blog.csdn.net/yu412346928/article/details/20637439" target="_blank" rel="noopener">SpringMVC配置多视图-内容协商原理</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><a href="https://junq.io/spring-mvc%E5%AE%9E%E7%8E%B0http%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86-content-negotiation.html" target="_blank" rel="noopener">Spring MVC三种方式实现HTTP内容协商(Content Negotiation)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
          <category> Spring MVC </category>
          
          <category> 视图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视图 </tag>
            
            <tag> ContentNegotiatingViewResolver </tag>
            
            <tag> contentNegotiationManager </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
