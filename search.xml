<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法题目分类</title>
      <link href="/2020/02/16/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/"/>
      <url>/2020/02/16/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>根据《算法笔记》一书，对PAT甲级、乙级真题和<a href="http://codeup.cn/contest.php" target="_blank" rel="noopener">codeup</a>部分试题进行分类。</p><h2 id="1-C-C-快速入门"><a href="#1-C-C-快速入门" class="headerlink" title="1. C/C++快速入门"></a>1. C/C++快速入门</h2><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104146906" target="_blank" rel="noopener">codeup 杨辉三角</a></li></ul><hr><h3 id="1-2-指针"><a href="#1-2-指针" class="headerlink" title="1.2 指针"></a>1.2 指针</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104151149" target="_blank" rel="noopener">codeup C语言10.16</a></li></ul><hr><h3 id="1-3-结构体的使用"><a href="#1-3-结构体的使用" class="headerlink" title="1.3 结构体的使用"></a>1.3 结构体的使用</h3><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104156997" target="_blank" rel="noopener">codeup C语言11.1</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104158080" target="_blank" rel="noopener">codeup C语言11.2</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104158719" target="_blank" rel="noopener">codeup C语言11.4</a></li></ul><hr><h2 id="2-入门模拟"><a href="#2-入门模拟" class="headerlink" title="2. 入门模拟"></a>2. 入门模拟</h2><h3 id="2-1-简单模拟"><a href="#2-1-简单模拟" class="headerlink" title="2.1 简单模拟"></a>2.1 简单模拟</h3><p><strong>不涉及算法，只是根据题目描述来编写代码，考察代码能力。</strong></p><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/weixin_39345384/article/details/104163314" target="_blank" rel="noopener">codeup 问题 B: A+B</a></td><td>\</td></tr><tr><td><strong>B1001 害死人不偿命的(3n+1)猜想</strong></td><td>\</td></tr><tr><td><strong>B1010 一元多项式求导</strong></td><td>\</td></tr><tr><td><strong>B1011 A+B和C</strong></td><td>\</td></tr><tr><td><strong>B1012 数字分类</strong></td><td>有条不紊地整理</td></tr><tr><td><strong>B1016 部分A+B</strong></td><td>\</td></tr><tr><td><strong>B1018 锤子剪刀布</strong></td><td><strong>注意scanf留在缓冲区的换行符<code>\n</code>的处理</strong></td></tr><tr><td><strong>B1026 程序运行时间</strong></td><td>\</td></tr><tr><td><strong>B1032 挖掘机技术哪家强</strong></td><td>统计各学校总分的方式</td></tr><tr><td><strong>B1046 划拳</strong></td><td>\</td></tr><tr><td><strong>A1002</strong> <strong>A+B for Polynomials</strong></td><td>非零系数项个数的统计</td></tr><tr><td><strong>A1009</strong> <strong>Product of Polynomials</strong></td><td>第二个多项式可边读边处理</td></tr><tr><td><strong>A1042</strong> <strong>Shuffling Machine</strong></td><td><strong>将扑克顺序号转为实际牌号的方式</strong></td></tr><tr><td><strong>A1046 Shortest Distance</strong></td><td>便于计算距离的方式</td></tr><tr><td><strong>A1065</strong> <strong>A+B and C (64bit)</strong></td><td><strong>B1011</strong> <strong>A+B 和 C 进阶版</strong><br><strong>负数相加若溢出，可能得到0</strong></td></tr></tbody></table><hr><h3 id="2-2-查找元素"><a href="#2-2-查找元素" class="headerlink" title="2.2 查找元素"></a>2.2 查找元素</h3><p>查找是学习写代码的一项基本功。</p><ul><li>一般来说，如果需要在一个比较小范围的数据集内内进行查找，<strong>直接遍历</strong>即可。</li><li>如果需要查找的范围较大，可以用<a href="#35-二分">二分查找</a><strong>等算法</strong>进行更快速的查找</li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1004</strong> <strong>成绩排名</strong></td><td>\</td></tr><tr><td><strong>B1028</strong> <strong>人口普查</strong></td><td><strong>1. 不合理年龄的判断方式</strong><br><strong>2. 需要考虑全不合理的情况</strong></td></tr><tr><td><strong>B1032</strong> <strong>挖掘机技术哪家强</strong></td><td>统计各学校总分的方式</td></tr><tr><td><strong>B1041</strong> <strong>考试座位号</strong></td><td>\</td></tr><tr><td><strong>A1011</strong> <strong>World Cup Betting</strong></td><td>\</td></tr><tr><td><strong>A1006</strong> <strong>Sign In and Sign Out</strong></td><td>方法类似 B1028 人口普查</td></tr><tr><td><strong>A1036</strong> <strong>Boys vs Girls</strong></td><td>\</td></tr></tbody></table><hr><h3 id="2-3-图形输出"><a href="#2-3-图形输出" class="headerlink" title="2.3 图形输出"></a>2.3 图形输出</h3><p>做法一般有两种：</p><ul><li>通过规律，直接进行输出</li><li>定义一个二维字符数组，通过规律填充，然后输出整个二维数组</li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1027</strong> <strong>打印沙漏</strong></td><td><strong>沙漏高度和符号数量的关系</strong></td></tr><tr><td><strong>B1036</strong> <strong>跟奥巴马一起编程</strong></td><td>\</td></tr><tr><td><strong>A1031</strong> <strong>Hello World for U</strong></td><td>根据 n1和n3为  $\leq$ n2，且满足 n1+n2+n3 = N+2 的最大值，求出n1，n2，n3</td></tr></tbody></table><hr><h3 id="2-4-日期处理"><a href="#2-4-日期处理" class="headerlink" title="2.4 日期处理"></a>2.4 日期处理</h3><p>需要处理好<strong>平年和闰年、大月和小月</strong>的问题，需要<strong>细心</strong>处理。</p><p>闰年的判断方法：</p><ol><li><p><strong>非整百年</strong>：能<strong>被4整除</strong>为闰年</p></li><li><p><strong>整百年</strong>：能<strong>被400整除</strong>的是闰年（<strong>1900年不是闰年</strong>）</p></li></ol><ul><li><a href="https://blog.csdn.net/weixin_39345384/article/details/104252546" target="_blank" rel="noopener">codeup 问题 A: 日期差值</a></li></ul><hr><h3 id="2-5-进制转换"><a href="#2-5-进制转换" class="headerlink" title="2.5 进制转换"></a>2.5 进制转换</h3><p>对一个<strong>P进制的数</strong>，如果要<strong>转换为Q进制</strong>，需要分两步：</p><ol><li><p>将 P进制数x <strong>转换为 十进制数y</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>, pro = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">    y += (x % <span class="number">10</span>) * pro;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">    pro *= p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将 十进制数y <strong>转换为 Q进制数z</strong></p><p>采用<strong>除基取余法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">40</span>], num = <span class="number">0</span>; <span class="comment">//数组z 存放 Q进制数y 的每一位，num为位数</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    z[num++] = y % Q; <span class="comment">//除基取余</span></span><br><span class="line">    y /= Q;</span><br><span class="line">&#125; <span class="keyword">while</span>(y != <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>do···while</code>语句而不是<code>while</code>的原因是：<strong>如果十进制数y = 0，使用<code>while</code>语句将使循环直接跳出，导致结果出错</strong>。</p></li></ol><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1022</strong> <strong>D进制的A+B</strong></td><td><strong>除基取余法</strong></td></tr><tr><td><strong>B1037</strong> <strong>在霍格沃茨找零钱</strong></td><td>\</td></tr><tr><td><strong>A1019</strong> <strong>General Palindromic Number</strong></td><td>\</td></tr><tr><td><strong>A1027</strong> <strong>Colors in Mars</strong></td><td>\</td></tr><tr><td><strong>A1058</strong> <strong>A+B in Hogwarts</strong></td><td>题型同 乙级1037 在霍格沃茨找零钱<br>单位转换过程可能会超过int范围</td></tr></tbody></table><hr><h3 id="2-6-字符串处理"><a href="#2-6-字符串处理" class="headerlink" title="2.6 字符串处理"></a>2.6 字符串处理</h3><p>考察<strong>代码能力</strong>的题型。一般需要<strong>仔细分析清楚</strong>题目中的<strong>输入和输出格式</strong>才能顺利AC。</p><p>有些题目中，可能<strong>实现逻辑非常麻烦</strong>，有很多<strong>细节</strong>和<strong>边界</strong>情况，此类题目需要<strong>多做多想，积累经验</strong>。</p><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1002</strong> <strong>写出这个数</strong></td><td><strong>数字转为字符串</strong>：<br>C语言：<code>sprintf(str, &quot;%d&quot;, num)</code><br>C++：<code>to_string(num)</code></td></tr><tr><td><strong>B1006</strong> <strong>换个格式输出整数</strong></td><td>\</td></tr><tr><td><strong>B1009</strong> <strong>说反话</strong></td><td><strong>句子颠倒，单词本身不颠倒</strong><br>C++ 待更新</td></tr><tr><td><strong>B1014</strong> <strong>福尔摩斯的约会</strong><br><strong>A1061</strong> <strong>Dating</strong></td><td><strong>正确归纳</strong>解码方式</td></tr><tr><td><strong>B1021</strong> <strong>个位数统计</strong></td><td>\</td></tr><tr><td><strong>B1024</strong> <strong>科学计数法</strong><br><strong>A1073</strong> <strong>Scientific Notation</strong></td><td><strong>1. 利用正则表达式，分开读取 数字部分 和 指数部分</strong><br>2. 指数 &lt; 0：整数部分必然为 0<br>3. 指数 &gt;= 0：<br>     - <strong>仍有小数点，何时输出小数点</strong><br>     - 没有小数点，后续输出0</td></tr><tr><td><strong>B1031</strong> <strong>查验身份证</strong></td><td>\</td></tr><tr><td><strong>B1048</strong> <strong>数字加密</strong></td><td><strong>1. 对齐两个整数</strong> <br>     - 若加密正整数A 比 B 长，B<strong>高位补0</strong>后进行加密 <br>     - 若加密正整数A 比 B 短，B<strong>多余的部分正常输出，等同于A高位补0</strong>后进行加密 <br> 2. 结果从数字高位(<strong>字符串低位</strong>)<strong>开始输出</strong></td></tr><tr><td><strong>A1001</strong> <strong>A+B Format</strong></td><td>从<strong>数字高位(字符串低位)开始</strong>，需要添加<code>,</code>的位置满足<strong><code>(i + 1) % 3 == len % 3</code> 且 不是最后一位</strong></td></tr><tr><td><strong>A1005</strong> <strong>Spell It Right</strong></td><td>\</td></tr><tr><td><strong>A1035</strong> <strong>Password</strong></td><td>(待优化)</td></tr><tr><td><strong>A1077</strong> <strong>Kuchiguse</strong></td><td><strong>1. 通过<code>reverse()</code>反转字符串，将后缀转换为前缀，便于比较</strong><br>2. <code>getline()</code>之前注意<strong>读取换行符</strong>。</td></tr><tr><td><strong>A1082</strong> <strong>Read Number in Chinese</strong></td><td>1. <strong>四位数字分为一节</strong>，单位为个、万、亿<br>2. <strong>一节中数字全为0</strong>，则不输出<strong>节的单位</strong><br>3. 节中<strong>第一个非零数之前有0</strong>，则输出<strong>1个</strong>0</td></tr></tbody></table><hr><h2 id="3-算法初步"><a href="#3-算法初步" class="headerlink" title="3. 算法初步"></a>3. 算法初步</h2><h3 id="3-1-排序"><a href="#3-1-排序" class="headerlink" title="3.1 排序"></a>3.1 排序</h3><h4 id="3-1-1-简单选择排序（-O-n-2-）"><a href="#3-1-1-简单选择排序（-O-n-2-）" class="headerlink" title="3.1.1 简单选择排序（$O(n^2)$）"></a>3.1.1 简单选择排序（$O(n^2)$）</h4><p>简单选择排序是指，对一个序列A中的元素<code>A[0] ~ A[n-1]</code>，令<code>i</code>从 0 到 n-1 枚举，进行 n 趟操作，每一趟从<strong>待排部分</strong>$[i, n-1]$中<strong>选择最小元素（记录下标）</strong>，令其<strong>与待排部分</strong>的<strong>第一个元素A[i]</strong>进行交换，使得$[0, i]$<strong>区间有序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//降序 简单选择排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">//选出最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[i])</span><br><span class="line">                k = j; <span class="comment">//记录更小元素的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = A[i]; <span class="comment">//交换A[k]与A[i]</span></span><br><span class="line">        A[i] = A[j];</span><br><span class="line">        A[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-2-直接插入排序（-O-n-2-）"><a href="#3-1-2-直接插入排序（-O-n-2-）" class="headerlink" title="3.1.2 直接插入排序（$O(n^2)$）"></a>3.1.2 直接插入排序（$O(n^2)$）</h4><p>直接插入排序是指，对序列A的n个元素<code>A[0]~A[n-1]</code>，令 i <strong>从 1 </strong>到 n-1 枚举，进行 n - 1 趟操作。</p><p>某一趟时，序列A的前 i 个元素 <code>A[0]~A[i-1]</code>已经有序，则该趟在范围$[0, i - 1]$中，<strong>从后往前</strong>寻找某个位置j，使得<code>A[i]</code>插入后，范围$[0, i]$有序(<strong><code>A[j]~A[i]</code>后移一位</strong>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//升序 直接插入排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = A[i], j = i;</span><br><span class="line">        <span class="comment">//从后往前遍历，便于编写代码</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; A[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-3-冒泡排序（-O-n-2-）"><a href="#3-1-3-冒泡排序（-O-n-2-）" class="headerlink" title="3.1.3 冒泡排序（$O(n^2)$）"></a>3.1.3 冒泡排序（$O(n^2)$）</h4><p>冒泡排序的本质在于<strong>交换</strong>，即每次通过交换的方式把当前<strong>剩余元素的最大值(升序)</strong>移动到一端，当<strong>剩余元素减少到0</strong>时，排序结束。整个过程执行 <strong>n-1 趟</strong>，每一趟<strong>从左到右依次比较相邻的元素</strong>，如果<strong>大的数在左边，则交换</strong>，该趟结束时，<strong>最大数</strong>被移动到<strong>当前剩余数的最右边</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123; <span class="comment">//升序 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">//进行 n - 1 趟排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-4-排序题与sort函数的应用"><a href="#3-1-4-排序题与sort函数的应用" class="headerlink" title="3.1.4 排序题与sort函数的应用"></a>3.1.4 排序题与sort函数的应用</h4><p>PAT中的排序题，大部分<strong>只需要得到排序的最终结果，而不需要去写排序的完整过程(例如冒泡排序、快速排序等)</strong>，因此推荐直接使用<strong>C语言的库函数<code>qsort</code></strong>或是<strong>C++的<code>sort</code>函数</strong>进行排序。<code>qsort</code>函数的使用需要运用指针，且写法上没有<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p><ul><li><p><strong>结构体数组的排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; ssd[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>如果想先<strong>按x</strong>从大到小排序，<strong>在x相等的情况下</strong>，<strong>按y</strong>从小到大排序(即<strong>二级排序</strong>)，cmp的写法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="comment">//返回值为true时，a排在b之前</span></span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">//降序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y; <span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>排名的实现</strong></p><p>很多排序题要求<strong>在排序之后</strong>计算每个个体的<strong>排名</strong>，规则一般是：<strong>分数相同的排名相同，占用一个排位</strong>。例如有5个学生的分数分别为90、88、88、88、86，其排名分别为1、2、2、2、5。</p><p><strong>方法：</strong></p><p>将第一个个体排名记为1，遍历剩余个体，如果当前分数等于上一个个体的分数，则当前个体排名等于<strong>上一个个体的排名</strong>，否则当前个体的排名等于<strong>数组下标+1</strong></p></li></ul><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1015</strong> <strong>德才论</strong><br><strong>A1062</strong> <strong>Talent and Virtue</strong></td><td>设置flag作为考生的分类，便于所有考生<strong>统一排序</strong></td></tr><tr><td><strong>A1012</strong> <strong>The Best Rank</strong></td><td>1. <strong>利用全局变量设计cmp函数</strong><br>2. 通过<strong>记录所有科目的排名</strong>，最后选出最好的排名以及对应科目<br>3. 相同分数者排名相同，<strong>下一不同分数者</strong>排名为<strong>数组下标+1</strong></td></tr><tr><td><strong>A1016</strong> <strong>Phone Bills</strong></td><td><strong>（待优化）</strong><br>1. <strong>通话记录统一先排序</strong>后处理<br>2. <strong>连续的两个通话记录，判断是否为 同一用户 且 为先通话后挂断的状态</strong><br>3. <strong>通话时长的统计方法</strong><br>4. 单位美分cents 要转换为 美元$</td></tr><tr><td><strong>A1025</strong> <strong>PAT Ranking</strong></td><td>\</td></tr><tr><td><strong>A1028</strong> <strong>List Sorting</strong></td><td>\</td></tr><tr><td><strong>A1055</strong> <strong>The World’s Richest</strong></td><td><strong>超时问题。要求输出的人数$\leq$100，通过筛去每个年龄多余的人解决</strong></td></tr><tr><td><strong>A1075</strong> <strong>PAT Judge</strong></td><td><strong>(待优化)</strong><br>1. <strong>不能编译</strong>的提交<strong>得分为0</strong><br>2. 没有提交过的答案需要输出为<code>-</code>，利用<code>&lt;cstring&gt;</code>中的<code>memset</code>函数，<strong>为 得分数组 赋值 -1，表示没有提交过答案</strong><br>3. <strong>没有任何一题通过编译 或 没有提交过答案的人</strong>不记录排名，<strong>设置 是否有通过编译的标识</strong>，进行筛选<br>4. 读取数据时，<strong>将用户数组下标看作id</strong>，便于统计<br>5. 排序<strong>以 是否有通过编译 为 第一排序条件</strong></td></tr><tr><td>A1080</td><td></td></tr><tr><td>A1083</td><td></td></tr><tr><td>A1095</td></tr></tbody></table><hr><h3 id="3-2-散列"><a href="#3-2-散列" class="headerlink" title="3.2 散列"></a>3.2 散列</h3><h4 id="3-2-1-散列-hash-的定义与整数散列"><a href="#3-2-1-散列-hash-的定义与整数散列" class="headerlink" title="3.2.1 散列(hash)的定义与整数散列"></a>3.2.1 散列(hash)的定义与整数散列</h4><blockquote><p>例题:</p><p>给出$N$个正整数，再给出$M$个正整数，问这$M$个数中的每个数分别是否在$N$个数中出现过，其中 $N, M \leq10^5$，且所有正整数均不超过$10^5$。例如 $N = 5，M = 3$， $N$个正整数为 ${8， 3， 7， 6， 2}$，欲查询的$M$个正整数为 ${7， 4， 2}$。</p></blockquote><p>对这个问题，最直观的思路是：对每个欲查询的正整数$x$，遍历所有$N$个数，看是否有一个数与$x$相等。这种做法的时间复杂度为$O(NM)$，显然不是好方法。可以采取<strong>用空间换时间</strong>的方式，用<strong>数组下标</strong>作为<strong>对应整数的标识</strong>，即设定一个<code>bool</code>型数组<code>hashTable[100001]</code>，其中<code>hashTable[x] == true</code>表示正整数$x$在$N$个整数中出现过。这样就可以在一开始读入$N$个正整数时进行预处理。于是，对$M$个欲查询的数，就能直接通过<code>hashTable</code>数组判断出每个数是否出现过，这种做法的时间复杂度为$O(N+M)$。<strong>直接把输入的数作为数组的下标</strong>来对这个数的性质进行统计的方法<strong>非常实用，务必掌握</strong>。</p><p>但是这个方法有一个问题：如果<strong>输入的整数可能是$10^9$大小</strong>，甚至是<strong>字符串</strong>，就<strong>不能将其直接作为数组下标</strong>了。因此我们寻找一种做法，<strong>将元素通过一个函数转换为一个在能接受范围内的整数，使得该整数尽可能唯一地代表这个元素</strong>。这样的方法称为<strong>散列(hash)</strong>，用于转换的函数称为<strong>散列函数H</strong>，也就是说，如果元素在转换前为<code>key</code>，那么转换后就是一个整数<code>H(key)</code>。</p><h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><p>对<code>key</code>是<strong>整数</strong>的情况来说，常用的<strong>散列函数</strong>有：</p><ol><li><p><strong>直接定址法</strong></p><ul><li><p>恒等变换，即 <code>H(key) = key</code></p></li><li><p>线性变换，即 <code>H(key) =  a * key + b</code></p></li></ul></li><li><p><strong>除留余数法</strong></p><p>把<code>key</code><strong>除以一个数<code>mod</code>得到的余数</strong>作为 <code>hash</code>值 的方法，即 <code>H(key) = key % mod</code></p><p>通过这个散列函数，可以把很大的数转换为不超过 mod 的整数，这样就可以将它作为可用的数组下标。显然，当<code>mod</code>是一个<strong>素数</strong>时，<code>H(key)</code><strong>能尽可能覆盖<code>[0,mod]</code>范围内的每一个数</strong>。</p></li><li><p>平方取中法(<strong>很少用</strong>)</p><p>取<code>key</code>的<strong>平方的中间若干位</strong>作为hash值</p></li></ol><hr><h5 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h5><p>当两个不同的数<code>key1</code>和<code>key2</code>他们的hash值相同时，这样的情况称为<strong>冲突</strong>。<strong>解决冲突的常用方法：</strong></p><ol><li><p><strong>开放定址法(获取新的hash值)</strong></p><ul><li><p><strong>线性探查法 (Linear Probing)</strong></p><p>当表中下标为<code>H(key)</code>的位置已经被其他元素占用，则<strong>检查下一个位置<code>H(key)+1</code></strong>，以此类推。<strong>如果检查过程中超过了表长<code>m</code>，那么就回到表的首位继续循环</strong>，直到找到一个可用的位置，或是所有位置都已经被使用。</p><p><code>H = (H(key) + i) % m</code>；<strong>(i = 0, 1, 2, …, m-1)</strong></p><p><strong>缺点</strong>：容易导致<strong>大量元素在相邻的散列地址上“聚集”(堆积)，大大降低查找效率</strong>。</p></li><li><p><strong>平方探查法 (Quadratic Probing)</strong></p><p>当表中下标为<code>H(key)</code>的位置已经被其他元素占用，则按如下顺序检查表中位置</p><p><code>H = (H(key) + i) % m</code>；i = $0, 1^2, -1^2, 2^2, -2^2, …, k^2, -k^2;(k \leq m/2)$</p><p>可<strong>避免聚集</strong>问题。</p><p>缺点：<strong>不能探测到散列表上所有单元</strong>(但至少能探测到一半单元)。</p></li><li><p><strong>再散列法(双散列法)</strong></p><p><code>H = (H1(key) + i * H2(key)) % m</code>；<strong>i 是冲突次数</strong></p></li></ul></li><li><p><strong>链地址法 (拉链法)</strong></p><p>不计算新的hash值，而是把 <strong>所有H(key)相同的key</strong>(称为<strong>同义词</strong>) <strong>存储在一个线性链表中</strong>，由散列地址唯一标识。</p></li></ol><hr><p>一般来说，可以使用<strong>标准库模板库中的<code>map</code></strong>来直接使用hash的功能（C++11以后可以用 <code>unordered_map</code>，<strong>速度更快</strong>），因此除非必须模拟这些方法或是对算法的效率要求比较高，一般不需要自己实现上面解决冲突的方法。</p><hr><h4 id="3-2-2-字符串hash初步"><a href="#3-2-2-字符串hash初步" class="headerlink" title="3.2.2 字符串hash初步"></a>3.2.2 字符串hash初步</h4><p>如果<strong><code>key</code>不是整数</strong>，应该如何设计散列函数？</p><blockquote><p>例题：</p><p>如何将一个二维整点$P$的坐标映射为一个整数，使得整点$P$可以由该整数唯一标识？</p></blockquote><p>假设一个整点$P$的坐标是$(x,y)$，其中$0\leq x,y\leq Range$，那么可以令<code>hash</code>函数为<code>H(P) = x * Range + y</code>，这样对数据范围内的任意两个整点$P1$与$P2$，<code>H(P1)</code>都不会等于<code>H(P2)</code>，就可以用<code>H(P)</code>来唯一地标识该整点P，<strong>接着</strong>便可以<strong>通过整数hash的方法进一步映射到较小的范围</strong>。</p><p>字符串hash是指<strong>将一个字符串S映射为一个整数</strong>，使得该整数可以尽可能唯一地代表字符串S。</p><p>为了讨论问题方便，<strong>假设字符串均由大写字母A~Z构成</strong>，不妨把 A~Z 视为 0~25。接着按照<strong>26进制转换为10进制</strong>的思路，实现将字符串映射为整数的需求(转换成的整数最大为$26^{len}-1$，len为字符串长度)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span> </span>&#123; <span class="comment">//将字符串S转换为整数</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>); <span class="comment">//将26进制转换为10进制</span></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免转换成的整数过大，需要注意 字符串长度len 不能太长。如果字符串中<strong>还有小写字母，可以把 A~Z 作为 0~25，把 a~z 作为 26~51</strong>，这样就变成了<strong>52进制转换为10进制</strong>的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0l</span> i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(S[i])) &#123;</span><br><span class="line">            id = id * <span class="number">52</span> + (S[i] - <span class="string">'A'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">islower</span>(S[i])) &#123;</span><br><span class="line">            id = id * <span class="number">52</span> + (S[i] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果字符中还有数字，一般有两种处理方法：</p><ol><li><p>按照小写字母的处理方法，<strong>增大进制数至62</strong>。</p></li><li><p>如果保证在字符串的<strong>末尾是个确定的数字</strong>，就可以把前面英文字母的部分按上面的思路转换成整数，再<strong>将末尾的数字直接拼接上去</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>);</span><br><span class="line">   id = id * <span class="number">10</span> + (S[len - <span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>例题：</p><p>给出N个字符串(由三位大写字母组成)，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span> </span>&#123; <span class="comment">//将字符串S转换为整数</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>); <span class="comment">//将26进制转换为10进制</span></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="keyword">int</span> hashTable[<span class="number">26</span> * <span class="number">26</span> * <span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">string</span> S[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; S[i];</span><br><span class="line">        <span class="keyword">int</span> id = hashFunc(S[i], <span class="number">3</span>);</span><br><span class="line">        hashTable[id]++; <span class="comment">//字符串出现的次数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> id = hashFunc(tmp, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; hashTable[id] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出字符串出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-3-相关习题"><a href="#3-2-3-相关习题" class="headerlink" title="3.2.3 相关习题"></a>3.2.3 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1005</strong> <strong>继续(3n+1)猜想</strong></td><td>奇数在判断过程中，可能大小会超过100</td></tr><tr><td><strong>B1029</strong> <strong>旧键盘</strong><br><strong>A1084</strong> <strong>Broken Keyboard</strong></td><td>待优化</td></tr><tr><td><strong>B1033</strong> <strong>旧键盘打字</strong></td><td><strong>不能用<code>scanf</code>或<code>cin</code>读取字符串</strong>，应采用<code>gets(str)</code>或<code>getline(cin, str)</code>，因为题目<strong>只保证第 2 行输入的文字串非空</strong></td></tr><tr><td><strong>B1038</strong> <strong>统计同成绩学生</strong></td><td>\</td></tr><tr><td><strong>B1039</strong> <strong>到底买不买</strong><br><strong>A1092</strong> <strong>To Buy or Not to Buy</strong></td><td>\</td></tr><tr><td><strong>B1042</strong> <strong>字符统计</strong></td><td>\</td></tr><tr><td><strong>B1043</strong> <strong>输出PATest</strong></td><td>\</td></tr><tr><td><strong>B1047</strong> <strong>编程团体赛</strong></td><td>\</td></tr><tr><td>A1041</td><td></td></tr><tr><td>A1050</td><td></td></tr><tr><td>A1048</td></tr></tbody></table><hr><h3 id="3-3-递归"><a href="#3-3-递归" class="headerlink" title="3.3 递归"></a>3.3 递归</h3><h4 id="3-3-1-分治"><a href="#3-3-1-分治" class="headerlink" title="3.3.1 分治"></a>3.3.1 分治</h4><p><strong>分治(divide and conquer)</strong>的全称为“<strong>分而治之</strong>”。分治法<strong>将原问题划分成若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解</strong>。分治法的三个步骤：</p><ol><li>分解：将原问题分解为若干和原问题拥有相同或相似结构的子问题。</li><li>解决：递归求解所有子问题。如果存在子问题的规模小到可以直接解决，就直接解决它。</li><li>合并：将子问题的解合并为原问题的解。</li></ol><p>分治法<strong>分解出的子问题</strong>应当是<strong>相互独立、没有交叉</strong>的。如果存在两个子问题有相交部分，就不应该使用分治法解决。分治法作为一种算法思想，<strong>既可以使用递归的手段实现，也可以通过非递归的手段实现</strong>。一般来说，<strong>使用 递归 实现较为容易</strong>。</p><hr><h4 id="3-3-2-递归"><a href="#3-3-2-递归" class="headerlink" title="3.3.2 递归"></a>3.3.2 递归</h4><p>递归很适合用来<strong>实现分治思想</strong>。</p><p>递归的逻辑中一般有两个重要概念：</p><ol><li><strong>递归边界</strong></li><li><strong>递归调用</strong></li></ol><p>其中<strong>递归调用</strong>是将原问题<strong>分解为若干个子问题</strong>的手段，而<strong>递归边界</strong>则是<strong>分解的尽头</strong>。递归的代码结构中一定存在这两个该概念，<strong>它们支撑起了整个递归最关键的逻辑</strong>。</p><blockquote><p>经典例子1：使用递归求解n的阶乘</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * F(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; F(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经典例子2：求 Fibonacci 数列的第n项</p><p>Fibonacci 数列(即斐波那契数列) 是满足 F(0) = 1, F(1) = 1, F(n) = F(n-1) + F(n-2) (n $\geq$ 2) 的数列，数列的前几项为 1, 1, 2, 3, 5, 8, 13, 21, … 。</p></blockquote><p>从定义中可以获知<strong>递归边界为 F(0) = 1 和 F(1) = 1</strong>，且递归调用为 F(n) = F(n-1) + F(n-2)  (n $\geq$ 2) ，因此可以仿照求解n的阶乘的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) &#123; <span class="comment">//递归边界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> F(n<span class="number">-1</span>) + F(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; F(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来看<strong>全排列(Full Permutation)</strong>。全排列指<strong>n个整数能形成的 所有排列</strong>。</p><p>现在需要按字典序从小到大的顺序输出$1\sim n$的全排列，其中$(a_1, a_2, …, a_n)$的字典序小于$(b_1, b_2, …, b_n)$是指存在一个$i$，使得$a_1=b_1$、$a_2 = b_2$、…、$a_{i-1} = b_{i-1}$、$a_i &lt; b_i$成立。</p><p>从递归的角度考虑，就可以分为若干个子问题：“输出以1开头的全排列”、“输出以2开头的全排列” … “输出以n开头的全排列”。<strong>不妨设定一个数组<code>P</code></strong>，用来存放当前的排列；再设定一个<strong>散列数组<code>hashTable</code></strong>，其中<code>hashTable[x]</code>，当整数<code>x</code>已经在数组<code>P</code>中时，为<code>1</code>。</p><p>按顺序往<code>P</code>的第1位到第n位中填入数字。<strong>不妨假设当前已经填好了<code>P[1] ~ P[index-1]</code>，正准备填<code>P[index]</code></strong>。显然需要枚举 1 ~ n，如果当前枚举的数字<code>x</code>还没有在<code>P[1] ~ P[index-1]</code>中(即<code>hashTable[x] == 0</code>)，那么就把它填入<code>P[index]</code>，同时将<code>hashTable[x]</code>置为<code>1</code>，然后去处理<code>P</code>的第<code>index + 1</code>位(<strong>即进行递归</strong>)；<strong>当递归完成时，再将<code>hashTable[x]</code>还原为<code>0</code>，以便让<code>P[index]</code>填下一个数字</strong>。</p><p>那么<strong>递归边界</strong>是什么呢？显然，当<code>index</code>达到<code>n + 1</code>时，说明<code>P</code>的的第<code>1 ~ n</code>位都已经填好了，此时可以把数组P输出，表示生成了一个排列，然后直接<code>return</code>即可。下面给出<code>n = 3</code>时的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>) &#123; <span class="comment">//递归边界，已经处理完排列的 1~n 位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; P[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123; <span class="comment">//枚举 1~n，试图将 x 填入 P[index]</span></span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="number">0</span>) &#123; <span class="comment">//如果 x 不在 P[1] ~ P[index - 1] 中</span></span><br><span class="line">            P[index] = x; <span class="comment">//令 P 的第 index 位为 x，即把x加如当前排列</span></span><br><span class="line">            hashTable[x] = <span class="number">1</span>; <span class="comment">//记 x 已在 P 中</span></span><br><span class="line">            generateP(index + <span class="number">1</span>, n); <span class="comment">//处理排列的第 index + 1 号位</span></span><br><span class="line">            hashTable[x] = <span class="number">0</span>; <span class="comment">//已处理完 P[index] 为 x 的子问题，还原状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>, P[<span class="number">11</span>], hashTable[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">generateP(<span class="number">1</span>); <span class="comment">//从P[1]开始填</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后的最后</strong>来看<strong>$n$皇后问题</strong>。$n$皇后问题是指在一个$n*n$的国际象棋棋盘上放置$n$个皇后，使得这$n$个皇后<strong>两两均不在同一行、同一列、同一条对角线上</strong>，求合法的方案数。</p><p>对于这个问题，如果采用组合数的方式来枚举每一种情况(即从$n^2$个位置中选择$n$个位置)，那么需要$C_{n\times n}^n$的枚举量。但是<strong>换个思路，考虑到每行只能放置一个皇后、每列也只能放置一个皇后，如果把n列皇后所在的行号依次写出，那么就会是$1 \sim n$的一个排列</strong>。于是只需要枚举$1 \sim n$的所有排列，查看每个排列对应的放置方案是否合法，统计其中合法的方案即可。</p><p>于是可以<strong>在全排列的代码基础上进行求解</strong>。由于当达到递归边界时表示生成了一个排列，所以<strong>需要在起内部判断是否为合法方案</strong>，即<strong>遍历每两个皇后</strong>，判断它们<strong>是否在同一条对角线上</strong>(显然不在同一行和同一列)，若不是，则累计计数变量<code>cnt</code>即可。主要代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>) &#123; <span class="comment">//递归边界，生成一个排列</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//flag为true表示当前排列为一个合法方案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//遍历任意两个皇后</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(i - j) == <span class="built_in">abs</span>(P[i] - P[j])) <span class="comment">//如果在一条对角线上</span></span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="comment">//当前方案合法</span></span><br><span class="line">            cnt++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="number">0</span>) &#123;</span><br><span class="line">            P[index] = x;</span><br><span class="line">            hashTable[x] = <span class="number">1</span>;</span><br><span class="line">            generateP(index + <span class="number">1</span>);</span><br><span class="line">            hashTable[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种<strong>枚举所有情况，然后判断每一种情况是否合法的朴素做法</strong>称为<strong>暴力法</strong>。</p><p>通过思考可以发现，当已经放置了一部分皇后时，<strong>可能剩余的皇后无论怎样放置都不可能合法，就不需要继续递归，直接返回上层即可</strong>。这种做法称为<strong>回溯法</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>) &#123; <span class="comment">//递归边界，生成一个 合法方案</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123; <span class="comment">//第 x 行</span></span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="number">0</span>) &#123; <span class="comment">//第 x 行还没有皇后</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//flag 为 1 表示当前皇后不会和之前的皇后冲突</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt; index; pre++) &#123; <span class="comment">//遍历之前的皇后</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(x - P[pre])) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>; <span class="comment">//与之前的皇后在一条对角线冲突</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//如果可以把皇后放在第 x 行</span></span><br><span class="line">                P[index] = x; <span class="comment">//令第 index 列皇后的行号为 x</span></span><br><span class="line">                hashTable[x] = <span class="number">1</span>; <span class="comment">//第 x 行已被占用</span></span><br><span class="line">                generateP(index + <span class="number">1</span>); <span class="comment">//递归处理第 index + 1 行皇后</span></span><br><span class="line">                hashTable[x] = <span class="number">0</span>; <span class="comment">//递归完毕，还原第 x 行 为 为占用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-4-贪心"><a href="#3-4-贪心" class="headerlink" title="3.4 贪心"></a>3.4 贪心</h3><h4 id="3-4-1-简单贪心"><a href="#3-4-1-简单贪心" class="headerlink" title="3.4.1 简单贪心"></a>3.4.1 简单贪心</h4><p>贪心法是<strong>求解一类最优化问题</strong>的方法，它总是考虑在当前状态下<strong>局部最优(或较优)</strong>的策略，来<strong>使全局的结果达到最优(或较优)</strong>。要获得<strong>最优</strong>结果，要求中间的每步策略都是最优的，因此<strong>严谨使用</strong>贪心法来求解最优化问题<strong>需要对采取的策略进行证明</strong>。证明的一般思路是使用<strong>反证法及数学归纳法</strong>，即假设策略不能导致最优解，然后通过一系列推导来得到矛盾，以此证明策略是最优的，最后用数学归纳法保证全局最优。不过对平常使用来说，也许没有时间或不太容易对想到的策略进行严谨的证明(<strong>贪心的证明往往比贪心本身更难</strong>)，因此一般来说，<strong>如果在想到某个似乎可行的策略，并且自己无法举出反例，那么就勇敢的实现它</strong>。</p><hr><h4 id="3-4-2-区间贪心"><a href="#3-4-2-区间贪心" class="headerlink" title="3.4.2 区间贪心"></a>3.4.2 区间贪心</h4><p><strong>区间不相交问题</strong>：给出$N$个开区间$(x, y)$，从中选择尽可能多的开区间，使得这些开区间两两没有交集。例如对开区间$(1, 3)$、$(2,4)$、$(3, 5)$、$(6, 7)$来说，可以选出最多三个区间$(1, 3)$、$(3, 5)$、$(6, 7)$，它们互相没有交集。</p><p>首先考虑最简单的情况，如果开区间$I_1$被开区间$I_2$包含(如图4-5a所示)，则选择$I_1$是最好的选择，因为这样就<strong>有更大的空间去容纳其他开区间</strong>。</p><p>接下来<strong>把所有开区间按左端点$x$从大到小排序</strong>，如果去掉区间包含的情况，那么一定有$y_1 &gt; y_2 &gt; … &gt; y_n$成立(如图4-5b所示)。观察发现，$I_1$右边有一段一定不会和其他区间重叠，如果把它去掉，那么$I_1$的左边剩余部分就会被$I_2$包含，由图4-5a的情况可知，应当选择$I_1$。因此对这种情况，<strong>总是先选择 左端点最大 的区间</strong>。值得注意的是，<strong>总是先选择右端点最小的区间</strong>的策略也是可行的。</p><p><img src="https://i.loli.net/2020/03/07/KlvHnuEwTJkcVsP.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inteval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="comment">//开区间左右端点</span></span><br><span class="line">&#125; I[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Inteval a, Inteval b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) &#123; <span class="comment">//先按左端点从大到小排序</span></span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x; </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//左端点相同的 按右端点从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n, n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; I[i].x &gt;&gt; I[i].y;</span><br><span class="line">    sort(I, I + n, cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, lastX = I[<span class="number">0</span>].x; <span class="comment">//记录不相交区间的个数，上一个被选中区间的左端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(I[i].y &lt;= lastX) &#123; <span class="comment">//如果该区间右端点在 lastX 左边</span></span><br><span class="line">            lastX = I[i].x; <span class="comment">//以 I[i] 作为新选中的区间</span></span><br><span class="line">            cnt++; <span class="comment">//不相交区间个数加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与这个问题类似的是<strong>区间选点问题：给出$N$个闭区间$[x, y]$，求最少需要确定多少个点，才能使每个闭区间中都至少存在一个点</strong>。例如对闭区间$[1,4]$、$[2, 6]$、$[5, 7]$来说，需要两个点(例如3、5)才能保证每个闭区间内都有至少一个点。</p><p>事实上，这个问题和区间不相交问题的策略是一致的。首先，回到图4-5a，如果闭区间$I_1$被闭区间$I_2$包含，那么在$I_1$中取点可以保证这个点一定在$I_2$内。接着<strong>把所有区间按左端点从大到小排序，去除掉区间包含的情况</strong>，就可以得到图4-5b。由于每个闭区间中都需要存在一个点，因此<strong>对左端点最大的区间$I_1$来说，取左端点就能让它尽可能多地覆盖其他区间</strong>。区间选点问题的代码只需要把区间不想交问题代码中的<code>I[i].y &lt;= lastX</code>改为<code>I[i].y &lt; lastX</code>即可。</p><p>总的来说，不是所有问题都适合使用贪心法，但是这并不妨碍贪心算法称为一个简洁、实用、高效的算法。</p><hr><h4 id="3-4-3-相关习题"><a href="#3-4-3-相关习题" class="headerlink" title="3.4.3 相关习题"></a>3.4.3 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1020</strong> <strong>月饼</strong><br><strong>A1070</strong> <strong>Mooncake</strong></td><td>库存量和售价都应该定义为double类型</td></tr><tr><td><strong>B1023</strong> <strong>组个最小数</strong></td><td>\</td></tr><tr><td><strong>A1033</strong> <strong>To Fill or Not to Fill</strong></td><td><strong>能到达的距离</strong>内，<strong>由近到远遍历</strong>，有三种情况：<br><br>1. 最近距离的加油站都到不了<br>2. 出现油价比目前低的加油站，就直接去<br>    2.1 <strong>油不够</strong>，只加能刚好到达的油量<br>    2.2 <strong>不用加油</strong><br>3. 没有更低价的加油站，就<strong>加满油(能尽量少加更贵的油)</strong>，去<strong>价格相对 最低</strong>的加油站</td></tr><tr><td>A1037</td><td></td></tr><tr><td>A1038</td><td></td></tr><tr><td>A1067</td></tr></tbody></table><hr><h3 id="3-5-二分"><a href="#3-5-二分" class="headerlink" title="3.5 二分"></a>3.5 二分</h3><h4 id="3-5-1-二分查找"><a href="#3-5-1-二分查找" class="headerlink" title="3.5.1 二分查找"></a>3.5.1 二分查找</h4><p>二分查找的<strong>高效之处</strong>在于，<strong>每一步都可以去除当前区间中的一半元素</strong>，因此其时间复杂度是$O(\log n)$，这是十分优秀的。</p><p>在严格<strong>递增</strong>序列中查找给定的数$x$的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; x) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[n] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, binarySearch(A, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">6</span>), binarySearch(A, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果过二分<strong>上界超过<code>int</code>型数据范围的一半</strong>，当欲查询元素在序列较靠后位置时，语句<code>mid = (left + right) / 2</code>中的<code>left + right</code>就<strong>有可能超过int而导致溢出</strong>，通常<strong>使用等价语句<code>mid = left + (right - left) / 2</code>作为代替</strong>，以避免溢出。另外，二分法可以<strong>使用递归</strong>进行实现，但在程序设计时，<strong>更多采用非递归的写法</strong>。</p><p>接下来探讨更进一步的问题：如果递增序列$A$中的<strong>元素可能重复</strong>，那么如何对给定的欲查询元素$x$，<strong>求出序列中第一个$\geq x$的元素位置$L$以及第一个$&gt;x$的元素的位置$R$</strong>，这样元素$x$在序列中的存在区间就是$[L, R)$。</p><p>例如对下标从0开始、有5个元素的序列${1,3,3,3,6}$来说，如果要查询3，则应当得到$L = 1$、$R = 4$；如果查询 5，则应当得到$L = R = 4$。<strong>如果序列中没有$x$，$L$和$R$也可以理解为 假设序列中存在$x$，则$x$应当在的位置</strong>。</p><p>先来考虑第一个小问：求序列中的第一个$\geq x$的元素位置。</p><ol><li>若<code>A[mid] &gt;= x</code>，说明第一个$\geq x$的元素的位置一定在<strong><code>mid</code>处或<code>mid</code>的左侧，应往左子区间[left, mid]继续查询，即令<code>right = mid</code></strong></li><li>若<code>A[mid] &lt; x</code>，说明第一个$\geq x$的元素的位置一定在<strong><code>mid</code>右侧，应往右子区间[mid+1, right]继续查询，即令<code>left = mid + 1</code></strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt;= x) &#123; <span class="comment">//中间值 &gt;= x</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//中间值 &lt; x</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">//返回夹出来的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码有两个需要注意的地方：</p><ol><li>循环条件为<code>left &lt; right</code>，而不是之前的<code>left &lt;= right</code>，这是由问题本身决定的。因为<strong>如果想要返回第一个<code>&gt;= x</code>的元素的位置，就不需要判断元素<code>x</code>本身是否存在</strong>。</li><li>二分的<strong>初始区间</strong>应当能<strong>覆盖到所有可能返回的结果</strong>，考虑到欲查询元素可能比序列中所有元素都大，此时应当返回n，因此<strong>二分上界是n</strong>，故二分的初始区间为<code>[left, right] = [0, n]</code>。</li></ol><p>接下来解决第二小问：求序列中第一个大于x的元素的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, itn right, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt; x) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">//返回夹出来的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lower_bound</code>和<code>upper_bound</code>函数都在解决这样一个问题：<strong>寻找有序序列中第一个满足某条件的元素的位置</strong>。这是一个非常重要且经典的问题，平时能碰到的大部分二分法问题都可以归结于这个问题。</p><hr><h4 id="3-5-2-二分法拓展"><a href="#3-5-2-二分法拓展" class="headerlink" title="3.5.2 二分法拓展"></a>3.5.2 二分法拓展</h4><p>首先介绍如何计算$\sqrt2$的<strong>近似值</strong>。</p><p>对$f(x) = x^2$来说，在$x \in [1, 2]$范围内，$f(x)$随着$x$的增大而增大，<strong>这就给使用二分法创造了条件</strong>。</p><p><strong>以精确到$10^{-5}$为例</strong>，令浮点型<code>left</code>和<code>right</code>的<strong>初值分别是 1 和 2</strong>，然后根据中点<code>mid</code>处$f(x)$的值与 2 的大小来选择子区间进行逼近：</p><ol><li>若<code>f(mid) &gt; 2</code>，说明<code>mid</code> &gt; $\sqrt2$，令<code>right = mid</code></li><li>若<code>f(mid) &lt; 2</code>，说明<code>mid</code> &lt; $\sqrt2$，令<code>left = mid</code></li></ol><p>上面两个步骤当<code>right - left</code> &lt; $10^{-5}$时结束，显然<strong>当<code>left</code>与<code>right</code>的距离 &lt; $10^{-5}$ 时已满足精度要求</strong>，<code>mid</code>即为所求的近似值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>; <span class="comment">//精度为 10^&#123;-5&#125;，科学计数法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calSqrt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> left = <span class="number">1</span>, right = <span class="number">2</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; eps) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &gt; <span class="number">2</span>) &#123; <span class="comment">//即 mid &gt; sqrt(2)</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，计算$\sqrt2$的近似值的问题是这样一个问题的特例：<strong>给定一个定义在$[L, R]$上的单调函数$f(x)$，求方程<code>f(x) = 0</code>的根</strong>。</p><p>同样假设精度要求为<code>eps</code> = $10^{-5}$，函数$f(x)$在$[L,R]$上递增，<strong>令<code>left</code>与<code>right</code>的初值分别为$L$、$R$</strong>。根据<strong>中点<code>mid</code>的函数值<code>f(mid)</code> 与 0 的大小关系</strong>来判断往哪个子区间继续逼近<code>f(x) = 0</code>的根：</p><ol><li>若<code>f(mid) &gt; 0</code>，说明<code>f(x) = 0</code>的根在<code>mid</code>左侧，应往左子区间继续逼近，即令<code>right = mid</code></li><li>若<code>f(mid) &lt; 0</code>，说明<code>f(x) = 0</code>的根在<code>mid</code>右侧，应往右子区间继续逼近，即令<code>left = mid</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>; <span class="comment">//精度为 10^&#123;-5&#125;，科学计数法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> left = L, right = R, mid;</span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; eps) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid; <span class="comment">//f(x) = 0 的根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-5-3-快速幂"><a href="#3-5-3-快速幂" class="headerlink" title="3.5.3 快速幂"></a>3.5.3 快速幂</h4><h4 id="3-5-4-相关习题"><a href="#3-5-4-相关习题" class="headerlink" title="3.5.4 相关习题"></a>3.5.4 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>A1010</strong> <strong>Radix</strong></td><td>1. <strong>基数上界为 已确认数字的十进制大小 + 1 与 下界中的较大值（确保不会出现多个解(而且基数不确定的数，只有一位数的时候才可能多个解) )</strong><br>2. 基数过大时，数值转换为十进制会发生<strong>上溢，存储结果为负数</strong></td></tr><tr><td>A1044</td><td></td></tr><tr><td>A1048</td></tr></tbody></table><hr><h3 id="3-6-tow-pointers"><a href="#3-6-tow-pointers" class="headerlink" title="3.6 tow pointers"></a>3.6 tow pointers</h3><h4 id="3-6-1-什么是two-pointers"><a href="#3-6-1-什么是two-pointers" class="headerlink" title="3.6.1 什么是two pointers"></a>3.6.1 什么是two pointers</h4><h4 id="3-6-2-归并排序"><a href="#3-6-2-归并排序" class="headerlink" title="3.6.2 归并排序"></a>3.6.2 归并排序</h4><h4 id="3-6-3-快速排序"><a href="#3-6-3-快速排序" class="headerlink" title="3.6.3 快速排序"></a>3.6.3 快速排序</h4><h4 id="3-6-4-相关习题"><a href="#3-6-4-相关习题" class="headerlink" title="3.6.4 相关习题"></a>3.6.4 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td><strong>B1030</strong> <strong>完美数列</strong><br><strong>A1085</strong> <strong>Perfect Sequence</strong></td><td>\</td></tr><tr><td>B1035<br>A1089</td><td></td></tr><tr><td>A1029</td><td></td></tr><tr><td>A1048</td></tr></tbody></table><hr><h3 id="3-7-其他高效技巧与算法"><a href="#3-7-其他高效技巧与算法" class="headerlink" title="3.7 其他高效技巧与算法"></a>3.7 其他高效技巧与算法</h3><h4 id="3-7-1-打表"><a href="#3-7-1-打表" class="headerlink" title="3.7.1 打表"></a>3.7.1 打表</h4><h4 id="3-7-2-活用递推"><a href="#3-7-2-活用递推" class="headerlink" title="3.7.2 活用递推"></a>3.7.2 活用递推</h4><h4 id="3-7-3-随机选择法"><a href="#3-7-3-随机选择法" class="headerlink" title="3.7.3 随机选择法"></a>3.7.3 随机选择法</h4><h4 id="3-7-4-相关习题"><a href="#3-7-4-相关习题" class="headerlink" title="3.7.4 相关习题"></a>3.7.4 相关习题</h4><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1040<br>A1093</td><td></td></tr><tr><td>B1045<br>A1101</td></tr></tbody></table><hr><h2 id="4-数学问题"><a href="#4-数学问题" class="headerlink" title="4.  数学问题"></a>4.  数学问题</h2><h3 id="4-1-简单数学"><a href="#4-1-简单数学" class="headerlink" title="4.1 简单数学"></a>4.1 简单数学</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1003</td><td></td></tr><tr><td>B1019<br>A1069</td><td></td></tr><tr><td>B1049<br>A1104</td><td></td></tr><tr><td>A1008</td><td></td></tr><tr><td>A1049</td></tr></tbody></table><hr><h3 id="4-2-最大公约数与最小公倍数"><a href="#4-2-最大公约数与最小公倍数" class="headerlink" title="4.2 最大公约数与最小公倍数"></a>4.2 最大公约数与最小公倍数</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1008</td></tr></tbody></table><hr><h3 id="4-3-分数的四则运算"><a href="#4-3-分数的四则运算" class="headerlink" title="4.3 分数的四则运算"></a>4.3 分数的四则运算</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1034<br>A1088</td><td></td></tr><tr><td>A1081</td></tr></tbody></table><hr><h3 id="4-4-素数"><a href="#4-4-素数" class="headerlink" title="4.4 素数"></a>4.4 素数</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1007</td><td></td></tr><tr><td>B1013</td><td></td></tr><tr><td>A1015</td><td></td></tr><tr><td>A1078</td></tr></tbody></table><hr><h3 id="4-5-质因子分解"><a href="#4-5-质因子分解" class="headerlink" title="4.5 质因子分解"></a>4.5 质因子分解</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1059</td><td></td></tr><tr><td>A1096</td></tr></tbody></table><hr><h3 id="4-6-大整数运算"><a href="#4-6-大整数运算" class="headerlink" title="4.6 大整数运算"></a>4.6 大整数运算</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1023</td><td></td></tr><tr><td>A1024</td></tr></tbody></table><hr><h3 id="4-7-扩展欧几里得算法"><a href="#4-7-扩展欧几里得算法" class="headerlink" title="4.7 扩展欧几里得算法"></a>4.7 扩展欧几里得算法</h3><h3 id="4-8-组合数"><a href="#4-8-组合数" class="headerlink" title="4.8 组合数"></a>4.8 组合数</h3><hr><h2 id="5-C-标准模板库介绍"><a href="#5-C-标准模板库介绍" class="headerlink" title="5. C++标准模板库介绍"></a>5. C++标准模板库介绍</h2><h3 id="5-1-vector"><a href="#5-1-vector" class="headerlink" title="5.1 vector"></a>5.1 vector</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1039</td><td></td></tr><tr><td>A1047</td></tr></tbody></table><hr><h3 id="5-2-set"><a href="#5-2-set" class="headerlink" title="5.2 set"></a>5.2 set</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1063</td></tr></tbody></table><hr><h3 id="5-3-string"><a href="#5-3-string" class="headerlink" title="5.3 string"></a>5.3 string</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1060</td></tr></tbody></table><hr><h3 id="5-4-map"><a href="#5-4-map" class="headerlink" title="5.4 map"></a>5.4 map</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1044<br>A1100</td><td></td></tr><tr><td>A1022</td><td></td></tr><tr><td>A1054</td><td></td></tr><tr><td>A1071</td></tr></tbody></table><hr><h3 id="5-5-queue"><a href="#5-5-queue" class="headerlink" title="5.5 queue"></a>5.5 queue</h3><h3 id="5-6-priority-queue"><a href="#5-6-priority-queue" class="headerlink" title="5.6 priority_queue"></a>5.6 priority_queue</h3><h3 id="5-7-stack"><a href="#5-7-stack" class="headerlink" title="5.7 stack"></a>5.7 stack</h3><h3 id="5-8-pair"><a href="#5-8-pair" class="headerlink" title="5.8 pair"></a>5.8 pair</h3><h3 id="5-9-algorithm"><a href="#5-9-algorithm" class="headerlink" title="5.9 algorithm"></a>5.9 algorithm</h3><hr><h2 id="6-数据结构专题1"><a href="#6-数据结构专题1" class="headerlink" title="6. 数据结构专题1"></a>6. 数据结构专题1</h2><h3 id="6-1-栈的应用"><a href="#6-1-栈的应用" class="headerlink" title="6.1 栈的应用"></a>6.1 栈的应用</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1051</td></tr></tbody></table><hr><h3 id="6-2-队列的应用"><a href="#6-2-队列的应用" class="headerlink" title="6.2 队列的应用"></a>6.2 队列的应用</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1056</td></tr></tbody></table><hr><h3 id="6-3-链表处理"><a href="#6-3-链表处理" class="headerlink" title="6.3 链表处理"></a>6.3 链表处理</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>B1025<br>A1074</td><td></td></tr><tr><td>A1032</td><td></td></tr><tr><td>A1052</td><td></td></tr><tr><td>A1097</td></tr></tbody></table><hr><h2 id="7-搜索专题"><a href="#7-搜索专题" class="headerlink" title="7. 搜索专题"></a>7. 搜索专题</h2><h3 id="7-1-深度优先搜索DFS"><a href="#7-1-深度优先搜索DFS" class="headerlink" title="7.1 深度优先搜索DFS"></a>7.1 深度优先搜索DFS</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1103</td></tr></tbody></table><hr><h3 id="7-2-广度优先搜索BFS"><a href="#7-2-广度优先搜索BFS" class="headerlink" title="7.2 广度优先搜索BFS"></a>7.2 广度优先搜索BFS</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1091</td></tr></tbody></table><hr><h2 id="8-数据结构专题2"><a href="#8-数据结构专题2" class="headerlink" title="8. 数据结构专题2"></a>8. 数据结构专题2</h2><h3 id="8-1-树与交叉树"><a href="#8-1-树与交叉树" class="headerlink" title="8.1 树与交叉树"></a>8.1 树与交叉树</h3><h3 id="8-2-二叉树的遍历"><a href="#8-2-二叉树的遍历" class="headerlink" title="8.2 二叉树的遍历"></a>8.2 二叉树的遍历</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1020</td><td></td></tr><tr><td>A1086</td><td></td></tr><tr><td>A1102</td></tr></tbody></table><hr><h3 id="8-3-树的遍历"><a href="#8-3-树的遍历" class="headerlink" title="8.3 树的遍历"></a>8.3 树的遍历</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1004</td><td></td></tr><tr><td>A1053</td><td></td></tr><tr><td>A1079</td><td></td></tr><tr><td>A1090</td><td></td></tr><tr><td>A1094</td><td></td></tr><tr><td>A1106</td></tr></tbody></table><hr><h3 id="8-4-二叉查找树BST"><a href="#8-4-二叉查找树BST" class="headerlink" title="8.4 二叉查找树BST"></a>8.4 二叉查找树BST</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1043</td><td></td></tr><tr><td>A1064</td><td></td></tr><tr><td>A1099</td></tr></tbody></table><hr><h3 id="8-5-平衡二叉树"><a href="#8-5-平衡二叉树" class="headerlink" title="8.5 平衡二叉树"></a>8.5 平衡二叉树</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1066</td></tr></tbody></table><hr><h3 id="8-6-并查集"><a href="#8-6-并查集" class="headerlink" title="8.6 并查集"></a>8.6 并查集</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1107</td></tr></tbody></table><hr><h3 id="8-7-堆"><a href="#8-7-堆" class="headerlink" title="8.7 堆"></a>8.7 堆</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1098</td></tr></tbody></table><hr><h3 id="8-8-哈夫曼树"><a href="#8-8-哈夫曼树" class="headerlink" title="8.8 哈夫曼树"></a>8.8 哈夫曼树</h3><hr><h2 id="9-图算法专题"><a href="#9-图算法专题" class="headerlink" title="9. 图算法专题"></a>9. 图算法专题</h2><h3 id="9-1-图的定义和相关术语"><a href="#9-1-图的定义和相关术语" class="headerlink" title="9.1 图的定义和相关术语"></a>9.1 图的定义和相关术语</h3><h3 id="9-2-图的存储"><a href="#9-2-图的存储" class="headerlink" title="9.2 图的存储"></a>9.2 图的存储</h3><h3 id="9-3-图的遍历"><a href="#9-3-图的遍历" class="headerlink" title="9.3 图的遍历"></a>9.3 图的遍历</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1013</td><td></td></tr><tr><td>A1021</td><td></td></tr><tr><td>A1034</td><td></td></tr><tr><td>A1076</td></tr></tbody></table><hr><h3 id="9-4-最短路径"><a href="#9-4-最短路径" class="headerlink" title="9.4 最短路径"></a>9.4 最短路径</h3><table><thead><tr><th>题目</th><th>解题关键</th></tr></thead><tbody><tr><td>A1003</td><td></td></tr><tr><td>A1018</td><td></td></tr><tr><td>A1030</td><td></td></tr><tr><td>A1072</td><td></td></tr><tr><td>A1087</td></tr></tbody></table><hr><h3 id="9-5-最小生成树"><a href="#9-5-最小生成树" class="headerlink" title="9.5 最小生成树"></a>9.5 最小生成树</h3><h3 id="9-6-拓扑排序"><a href="#9-6-拓扑排序" class="headerlink" title="9.6 拓扑排序"></a>9.6 拓扑排序</h3><h3 id="9-7-关键路径"><a href="#9-7-关键路径" class="headerlink" title="9.7 关键路径"></a>9.7 关键路径</h3><hr><h2 id="10-动态规划专题"><a href="#10-动态规划专题" class="headerlink" title="10. 动态规划专题"></a>10. 动态规划专题</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑盒测试</title>
      <link href="/2020/02/03/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/02/03/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对黑盒测试来说，<strong>所有输入数据都放在一个文件里</strong>。</p></blockquote><hr><h2 id="单点测试"><a href="#单点测试" class="headerlink" title="单点测试"></a>单点测试</h2><p>PAT试题基本为<strong>单点测试</strong>（即<strong>一次运行一组数据，一组数据通过测试则获得这组数据的分值</strong>）。</p><hr><h2 id="多点测试"><a href="#多点测试" class="headerlink" title="多点测试"></a>多点测试</h2><p>多点测试要求程序<strong>一次运行所有数据，并要求输出结果都正确，只要存在错误，即不得分</strong>。<br><strong>大部分 在线判题系统(Online Judge)  都采用了多点测试</strong>。<br>由于要求程序能运行所有数据，因此<strong>必须保证程序能反复执行代码的核心部分</strong>，这<strong>就要用到循环</strong>。</p><h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>题目一般有3中输入的格式，需要采用不同输入方式。</p><ol><li><strong><code>while··· EOF</code>型</strong></li></ol><p>题目<strong>没有给定输入的结束条件</strong>，则<strong>默认读取到文件末尾</strong>。</p><blockquote><p>EOF（End Of File)</p><p>可以通过<code>printf(&quot;%d&quot;, EOF);</code>读取EOF的数值，一般的设备上值是-1。<br>EOF操作：</p><ul><li>windows：<code>Ctrl + Z</code></li><li>unix：<code>Ctrl + D</code></li></ul></blockquote><p><code>scanf</code> 若成功读入一个值，返回1；若成功读入2个值，返回2；若<strong>读入失败，返回 -1</strong>，C/C++中，<code>EOF</code>即为 -1。</p><p>正常情况下，控制台中的输入不会失败，只有读取文件时<strong>到达文件末尾，导致无法读取时，才会产生读入失败</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取数字、字符、字符串</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串</span></span><br><span class="line"><span class="keyword">while</span> (gets(str) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="2"><li><strong><code>while··· break</code>型</strong></li></ol><p>题目要求，<strong>当输入的数据满足某个条件时，停止输入</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更简洁的写法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), a || b) &#123;<span class="comment">// scanf()恒不为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="3"><li><strong><code>while (T--)</code>型</strong></li></ol><p>题目给出测试数据的组数，然后才给出相应数量数组的输入数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ol><li><p>正常输出</p></li><li><p>每组数据输出之后，额外加一个空行</p></li><li><p><strong>两组输出数据之间有一个空行，最后一组数据后面没有空行</strong></p><p>一般在第三种输入类型<code>while (T--)</code>情况下出现，只需通过判断T是否为0选择是否输出额外的换行。</p></li></ol><hr><h3 id="重置变量"><a href="#重置变量" class="headerlink" title="重置变量"></a>重置变量</h3><p>在多点测试中，<strong>每一次循环都要重置变量和数组</strong>，否则在下一组数据来临时，变量和数组不是初始状态，将出错。<strong>重置数组一般使用<code>memset</code>函数或<code>fill</code>函数</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> OJ </tag>
            
            <tag> 在线判题系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++解题干货</title>
      <link href="/2020/02/01/C_C++%E8%A7%A3%E9%A2%98%E5%B9%B2%E8%B4%A7/"/>
      <url>/2020/02/01/C_C++%E8%A7%A3%E9%A2%98%E5%B9%B2%E8%B4%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h2><ol><li><p><strong>整型int</strong>取值范围：$-2^{31} \sim +(2^{31}-1)$，题目要求<strong>绝对值在$10^9$以内 或 32位整数</strong>，则<strong>用int型表示</strong></p></li><li><p><strong>长整型long long</strong>取值范围：$-2^{63} \sim +(2^{63}-1)$，题目要求<strong>绝对值在$10^{18}$以内 或 64位整数</strong>，则<strong>用long long型表示</strong></p><p>注：如果 long long 型赋 $&gt; 2^{31}-1$的初值，需要在初值后加上LL，否则编译错误。如<code>long long num = 123456789012345LL;</code></p></li><li><p>浮点型数据<strong>一律用double存储</strong>，而不用float(精度低，6~7位)</p></li><li><p>字符常量使用<strong>ASCII码(范围0~127)</strong>统一编码。</p><ul><li>0~9 的ASCII码值：48~57</li><li>A~Z 的ASCII码值：65~90</li><li>a~z 的ASCII码值：97~122 (<strong>比大写字母的ASCII码值大32</strong>)</li></ul></li><li><p>强制类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">12.56</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)r); <span class="comment">//输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, (<span class="keyword">double</span>)a / (<span class="keyword">double</span>)b);<span class="comment">//输出0.6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td>#include &lt;cstdio><br><strong>scanf函数<br>printf函数</strong></td><td>#include &lt;iostream> <br>using std::cin;<br>using std::cout;<br>cin<br>cout</td><td>cin 和 cout <strong>无需指定输入输出格式</strong>，<br>但<strong>消耗的时间</strong>比 scanf 和 printf <strong>多得多</strong>。<br>故<strong>推荐使用C语言的 scanf 和 printf</strong>，<br>只有在十分必要的时候使用 cin 和 cout</td></tr></tbody></table><h3 id="输入和输出格式"><a href="#输入和输出格式" class="headerlink" title="输入和输出格式"></a>输入和输出格式</h3><table><thead><tr><th>类型</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>long long</td><td><code>scanf(&quot;%lld&quot;, &amp;n);</code></td><td><code>printf(&quot;%lld&quot;, n);</code></td></tr><tr><td>double</td><td><code>scanf(&quot;%lf&quot;, &amp;db);</code></td><td><code>printf(&quot;%f&quot;, db);</code></td></tr><tr><td>字符串</td><td><code>scanf(&quot;%s&quot;, str);</code><br>(<strong>无需 取地址符&amp;</strong>)<br></td><td><code>printf(&quot;%s&quot;, str);</code></td></tr><tr><td>char</td><td><code>c1 = getchar();</code><br><strong>能读入换行符<code>\n</code></strong></td><td><code>putchar(c1);</code></td></tr></tbody></table><h3 id="实用的输出格式"><a href="#实用的输出格式" class="headerlink" title="实用的输出格式"></a>实用的输出格式</h3><ol><li><p><code>%md</code></p><p>使不足m位的int型变量以m位进行<strong>右对齐</strong>输出，高位<strong>用空格补齐</strong>；若变量本身超过m位，则保持原样。</p></li><li><p><code>%0md</code></p><p>使不足m位的int型变量以m位进行<strong>右对齐</strong>输出，高位<strong>用0补齐</strong>；若变量本身超过m位，则保持原样。</p></li><li><p><code>%.mf</code></p><p>让浮点数保留m位小数(<strong>四舍六入五成双</strong>)输出。如果要<strong>四舍五入</strong>，需要用到<strong>round函数</strong>。</p><blockquote><p>四舍六入五成双：</p><ul><li>5后有数时：舍5入1</li><li>5后无数时：<ul><li>5前为奇数，舍5入1</li><li>5前为偶数，舍5不进（0是偶数）</li></ul></li></ul></blockquote></li></ol><hr><h2 id="C-标准库头文件"><a href="#C-标准库头文件" class="headerlink" title="C++标准库头文件"></a>C++标准库头文件</h2><table><thead><tr><th>C++标准库</th><th>包含内容</th></tr></thead><tbody><tr><td>&lt;iostream></td><td>C++标准输入和输出函数 的函数原型</td></tr><tr><td>&lt;cstdio></td><td>C风格标准输入和输出函数 的函数原型</td></tr><tr><td>&lt;iomanip></td><td><strong>格式化数据流</strong>的流操纵符 的函数原型</td></tr><tr><td>&lt;cmath></td><td><strong>数学库</strong>函数 的函数原型</td></tr><tr><td>&lt;ctime></td><td>处理时间和日期的函数 的函数原型</td></tr><tr><td>&lt;cstdlib></td><td><strong>数与文本的转换、内存分配、随机数</strong>及其他各种<strong>工具函数</strong> 的函数原型</td></tr><tr><td>&lt;random></td><td>产生<strong>非确定性的随机数</strong> 的功能库</td></tr><tr><td>&lt;cctype></td><td><strong>测试 字符</strong>特定属性(如是否为数字、标点符号等)函数 的函数原型<br><strong>转换 大小写字母</strong>的函数 的函数原型</td></tr><tr><td>&lt;iterator></td><td><strong>访问 C++标准库容器中数据</strong> 的类</td></tr><tr><td>&lt;algorithm></td><td><strong>操作 C++标准库容器中数据</strong> 的函数</td></tr><tr><td>&lt;string></td><td>C++标准库的 <code>string</code>类 的定义</td></tr><tr><td>&lt;cstring></td><td>C风格<strong>字符串处理</strong>函数 的函数原型</td></tr></tbody></table><hr><h3 id="lt-cmath"><a href="#lt-cmath" class="headerlink" title="&lt;cmath>"></a>&lt;cmath></h3><ol><li><p><strong><code>double fabs(double x)</code></strong></p><p><strong>浮点型取绝对值</strong></p></li><li><p><strong><code>double floor(double x)</code>和<code>ceil(double x)</code></strong></p><p><strong>向下取整</strong>和<strong>向上取整</strong></p></li><li><p><strong><code>double round(double x)</code></strong><br><strong>针对小数点后一位四舍五入</strong></p><p>另，<strong>不使用函数进行四舍五入的方法</strong>：</p><p><code>num = num + 0.5</code> </p></li><li><p><strong><code>double pow(double r, double p)</code></strong></p><p>求 r 的 p次方</p><p><strong>$10^n$还有另外的表示方法，如</strong></p><ul><li>$10^3$ 可写成 <code>1e3</code></li><li>$2\times10^6$可写成<code>2e6</code></li><li>$3\times10^{-6}$可写成<code>3e-6</code></li></ul></li><li><p><strong><code>double sqrt(double x)</code></strong></p><p>求 x 的算术平方根</p></li><li><p><strong><code>double log(double x)</code></strong>和<strong><code>double log10(double x)</code></strong></p><p>求 x <strong>以 $e$ 为底</strong>的对数 和 <strong>以10为底</strong>的对数</p><p>针对<strong>任意底数求对数的函数</strong>，必须用<strong>换底公式</strong>，即$\log_ab = \ln b/\ln a$</p></li><li><p><strong><code>double exp(double x)</code></strong></p><p>指数函数$e^x$</p></li><li><p>三角函数</p><p><strong>x为弧度</strong></p><ul><li><code>sin(double x)</code></li><li><code>cos(double x)</code></li><li><code>tan(double x)</code></li></ul></li></ol><hr><h3 id="lt-ctime"><a href="#lt-ctime" class="headerlink" title="&lt;ctime>"></a>&lt;ctime></h3><ol><li><p><code>time_t time(time_t *seconds)</code></p><p>返回<strong>自 格林尼治标准时间的1970年1月1日0时 起 到现在</strong>的<strong>秒数</strong>。如果<code>seconds</code>不为空，<strong>返回值也存储在<code>seconds</code>中</strong>。</p></li></ol><hr><h3 id="lt-cstdlib"><a href="#lt-cstdlib" class="headerlink" title="&lt;cstdlib>"></a>&lt;cstdlib></h3><ol><li><p><code>int rand()</code></p><p><code>rand</code>函数生成 [0, RAND_MAX] 之间的一个<strong>整数</strong></p><p>直接由<code>rand</code>函数生成的数的范围<strong>常常不能满足具体需要</strong>，可以通过<strong>比例缩放(scaling)</strong>方法得到所需的随机数。例如<strong>模拟投掷六面骰子，结果可以用<code>rand() % 6 + 1</code>表示</strong>。其中数字6称为<strong>比例缩放因子</strong>。</p></li><li><p><code>void srand(unsigned int seed)</code></p><p><code>rand</code>函数<strong>实际上生成的是 伪随机数</strong>。程序每次执行时产生的序列都是重复的，将其调整为每次执行时都产生不同的随机数序列的过程称为<strong>随机化</strong>，可以<strong>通过<code>srand</code>函数实现</strong>。<code>srand</code>函数接收一个<code>unsigned int</code>值，<strong>为</strong> <code>rand</code>函数使用的<strong>随机数发生器 “播种”</strong>，从而产生不同的随机数序列。为了<strong>在随机化时不用每次都输入“种子”</strong>，可以使用如下语句：</p><p><code>srand(static_cast&lt;unsigned int&gt;(time(NULL) ) );</code></p></li></ol><hr><h3 id="lt-cctype"><a href="#lt-cctype" class="headerlink" title="&lt;cctype>"></a>&lt;cctype></h3><ol><li><p><code>int isalnum(int c)</code></p><p>字符是否为<strong>数字或字母</strong></p></li><li><p><code>int isalpha(int c)</code></p><p>字符是否是<strong>字母</strong></p></li><li><p><code>int isdigit(int c)</code></p><p>字符是否是十进制<strong>数字</strong></p></li><li><p><code>int islower(int c)</code></p><p>是否是<strong>小写字母</strong></p></li><li><p><code>int isupper(int c)</code></p><p>是否是<strong>大写字母</strong></p></li><li><p><code>int tolower(int c)</code></p><p>把大写字母 <strong>转换为 小写字母</strong></p><p><strong>不会改变非字母字符的值</strong></p></li><li><p><code>int toupper(int c)</code></p><p>把小写字母 <strong>转换为 大写字母</strong></p><p><strong>不会改变非字母字符的值</strong></p></li></ol><hr><h3 id="lt-algorithm"><a href="#lt-algorithm" class="headerlink" title="&lt;algorithm>"></a>&lt;algorithm></h3><ol><li><p><code>max(x, y)</code>和<code>min(x, y)</code></p></li><li><p><code>abs(x)</code>：<code>x</code>必须是<strong>整数</strong>，因此更推荐使用<code>&lt;cmath&gt;</code>下的<code>fabs(x)</code></p></li><li><p><code>swap(x, y)</code></p></li><li><p><code>reverse(it1, it2)</code></p><p><strong>可以将 数组指针在[it1, it2)之间的元素 或 容器的迭代器在[it1, it2)之间的元素 进行反转</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">reverse(a, a + <span class="number">4</span>); <span class="comment">//将 a[0] ~ a[3]反转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//输出结果：13 12 11 10 14 15</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"abcdefghi"</span>;</span><br><span class="line">reverse(str.begin() + <span class="number">2</span>, str.begin() + <span class="number">6</span>); <span class="comment">//对str[2] ~ str[5]反转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：abfedcghi</span></span><br></pre></td></tr></table></figure></li><li><p><code>next_permutation</code>函数</p><p>给出一个序列在<strong>全排列中的下一个序列</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span>(next_permutation(a, a + <span class="number">3</span>)); <span class="comment">//a[0]~a[2]之间的序列求解下一个序列</span></span><br></pre></td></tr></table></figure></li><li><p><code>fill</code>函数</p><p>对数组或容器中某一段区间元素<strong>赋相同的值</strong>。和<code>&lt;cstring&gt;</code>的<code>memset</code>不同(基本只用于赋<strong>0或-1</strong>)，可以赋<strong>数组类型对应范围中的任意值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fill(a, a + <span class="number">5</span>, <span class="number">233</span>); <span class="comment">//a[0] ~ a[4] 均赋值为 233</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//输出结果：233 233 233 233 233</span></span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p><code>sort</code>函数</p><p>C语言的<code>qsort</code>函数的使用需要运用指针，且写法上没有C++的<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p><p><code>sort(首元素地址, 尾元素地址的下一个地址, 比较函数cmp(非必填))</code></p><p>如果<strong>不写比较函数cmp</strong>，则<strong>默认升序</strong>排序。如果想要<strong>降序</strong>排序，需要编写比较函数cmp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//返回值为true时，a被排在b之前</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">//降序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在STL标准容器中，<strong>只有<code>vector</code>、<code>string</code>、<code>deque</code>可以使用<code>sort</code>，因为像<code>set</code>、<code>map</code>这种容器是用红黑树实现的，元素本身有序，故不允许使用<code>sort</code>排序</strong>。</p></li><li><p><code>lower_bound</code>和<code>upper_bound</code></p><p><code>lower_bound(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>第一个值$\geq$<code>val</code>的元素的位置</strong>。</p><p><code>upper_bound(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>第一个值&gt;<code>val</code>的元素的位置</strong>。</p><p><strong>如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。如果没有找到相应元素，则返回可以插入该元素的位置的指针或迭代器</strong>。</p></li><li><p><code>max_element</code>和<code>min_element</code></p><p><code>max_element(first, last)</code>用来寻找在数组或容器中的[first, last)范围内<strong>最大元素的位置</strong>。</p><p><code>min_element(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>最小元素的位置</strong>。</p><p><strong>如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器</strong>。</p></li></ol><hr><h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><h4 id="lt-vector"><a href="#lt-vector" class="headerlink" title="&lt;vector>"></a>&lt;vector></h4><p><strong>向量</strong>(“<strong>变长数组</strong>”的叫法更容易理解)，<strong>长度可以根据需要进行变化，比较节省空间</strong>。试题中，有时会碰到<strong>只用普通数组会超内存的情况，使用<code>vector</code>会让问题的解决便捷许多</strong>；另外，<code>vector</code>还可以用来<strong>以邻接表的方式存储图</strong>。</p><ol><li><p><code>vector</code>的定义</p><p><code>vector&lt;typename&gt; name</code></p><p>如果<code>typename</code>也是一个STL(Standard Template Library)容器，<strong>在C++11之前，定义的时候，在符号<code>&gt;&gt;</code>之间要加上空格</strong>。如：<code>vector&lt;vector&lt;int&gt; &gt; name;</code>，可以理解为<strong>两个维都可变长的二维数组</strong>。</p><p>而vector数组的定义，如：<code>vector&lt;typename&gt; Arrayname[arraySize];</code>，<strong>一维长度已固定，注意两者的区别</strong>。</p></li><li><p><code>vector</code>常用函数</p><ol><li><p><code>push_back(typename x)</code>：在 vector <strong>末尾添加</strong>一个元素 x</p></li><li><p><code>pop_back()</code>：<strong>删除</strong> vector 的<strong>末尾元素</strong></p></li><li><p><code>begin()</code>：取 vector 的<strong>首元素地址</strong></p></li><li><p><code>end()</code>：取 vector 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p></li><li><p><code>size()</code>：获取 vector 中的<strong>元素个数</strong></p></li><li><p><code>clear()</code>：<strong>清空</strong> vector 中所有元素</p></li><li><p><code>insert(vector&lt;typename&gt;::iterator it, typename x)</code>：向vector的 <strong>任意迭代器 it 处</strong> 插入一个元素 x</p><p>如<code>vi.insert(vi.begin() + 2, -1); //将 -1 插入vi[2]</code></p></li><li><p><code>erase()</code></p><ul><li>删除迭代器为 it 处的元素：<code>erase(it);</code></li><li>删除 [firstIt, lastIt) 内所有元素：<code>erase(firstIt, lastIt);</code></li></ul></li></ol></li><li><p><code>vector</code>容器内元素的访问</p><ol><li><p>通过<strong>下标</strong>访问</p></li><li><p>通过<strong>迭代器iterator</strong>访问</p><p><code>vector&lt;typename&gt;::iterator it;</code>，这样就得到了迭代器<code>it</code>，可以通过<strong><code>*it</code>来访问<code>vector</code>里的元素</strong>。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">        vi.push_back(i); <span class="comment">//在 vi 的 末尾 添加元素 i</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin(); <span class="comment">//vi.begin() 为取 vi 的首元素地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *(it + i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>vi[i]</code>和<code>vi.begin() + i</code><strong>等价</strong>。在常用的STL容器中，<strong>只有<code>vector</code>和<code>string</code>中，才允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong>。</p><p>迭代器还实现了自增和自减的操作，于是还有一种遍历<code>vector</code>中元素的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector 的迭代器不支持 it &lt; vi.end() 写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin(); it != vi.end(); it++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h4 id="lt-set"><a href="#lt-set" class="headerlink" title="&lt;set>"></a>&lt;set></h4><p><strong>集合</strong>，是一个<strong>内部自动递增排序 且 不含重复元素</strong>的容器。试题中，可能出现需要<strong>去掉重复元素</strong>的情况，而且<strong>有可能因为这些元素 比较大 或者 类型不是<code>int</code>型 而不能直接开散列表</strong>，这种情况下就可以用<code>set</code>来保留元素本身而不考虑个数。虽然上述情况<strong>也可以通过再开一个数组进行下标和元素对应来解决</strong>，但<code>set</code>提供了<strong>更为直观</strong>的接口，并且可以实现<strong>自动排序</strong>，可以在做某些题时<strong>减少思维量</strong>。</p><ol><li><p><code>set</code>的定义</p><p><code>set&lt;typename&gt; name;</code></p><p>和<code>vector</code>相同，如果<code>typename</code>也是一个STL容器，<strong>在C++11之前，定义的时候，在符号<code>&gt;&gt;</code>之间要加上空格</strong>。如：<code>set&lt;vector&lt;int&gt; &gt; name;</code>，可以理解为<strong>两个维都可变长的二维数组</strong>。</p></li><li><p><code>set</code>常用函数</p><ol><li><p><code>begin()</code>：取 set 的<strong>首元素地址</strong></p></li><li><p><code>end()</code>：取 set 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p></li><li><p><code>size</code>：获取 set 中的<strong>元素个数</strong></p></li><li><p><code>clear()</code>：<strong>清空</strong> set 中所有元素</p></li><li><p><code>insert(typename x)</code>：将 x 插入 set 容器中，并自动递增排序和去重，时间复杂度为$O(logN)$</p></li><li><p><code>find(typename value)</code>：返回 set 中<strong>对应值为 value 的迭代器</strong></p><p>如：<code>set&lt;int&gt;::iterator it = st.find(2);</code> //在 set 中查找2，返回其迭代器</p></li><li><p><code>erase()</code></p><ul><li><p>删除单个元素</p><ul><li><p>删除迭代器为 it 处的元素：<code>erase(it);</code></p><p>可以结合<code>find</code>函数使用，如：<code>st.erase(st.find(100))</code></p></li><li><p>删除值为 value 的元素：<code>erase(value);</code></p></li></ul></li><li><p>删除 [firstIt, lastIt) 内所有元素：<code>erase(first, last)</code></p></li></ul></li></ol></li><li><p><code>set</code>容器内元素的访问</p><p><code>set</code><strong>只能通过 迭代器iterator 访问</strong>，因为<strong>只有<code>vector</code>和<code>string</code>中，才允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong>，因此只能按如下方式枚举：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">st.insert(<span class="number">3</span>);</span><br><span class="line">    st.insert(<span class="number">5</span>);</span><br><span class="line">    st.insert(<span class="number">2</span>);</span><br><span class="line">    st.insert(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//set 的迭代器不支持 it &lt; vi.end() 写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.begin(); it != st.end(); it++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：<code>2 3 5</code>，可以发现，<code>set</code>内的元素自动<strong>递增</strong>排序，且自动去除了重复元素。</p></li><li><p>延伸</p><p><code>set</code>中元素是唯一的，如果<strong>处理元素不唯一的情况，需要使用<code>multiset</code></strong>。C++11 标准中还增加了<code>unordered_set</code>，<strong>以散列代替<code>set</code>内部的红黑树(一种自平衡二叉查找树)实现</strong>，使其可以用来<strong>去重但不排序</strong>的需求，速度比set快得多。</p></li></ol><hr><h4 id="lt-string"><a href="#lt-string" class="headerlink" title="&lt;string>"></a>&lt;string></h4><ol><li><p><code>string</code>中内容的访问</p><ol><li><p>通过下标访问</p><p>一般来说，<strong>可以直接像字符数组那样去 访问</strong><code>string</code>，如果要读入和输出<strong>整个字符串</strong>，则<strong>只能用<code>cin</code>和<code>cout</code></strong>。那么有办法用<code>printf</code>输出<code>string</code>吗？</p><p>用<code>string</code>的函数<code>c_str()</code>可以将<code>string</code>类型<strong>转换为字符数组</strong>进行输出。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.c_str());</span><br></pre></td></tr></table></figure></li><li><p>通过迭代器访问</p><p>有些函数比如<code>insert()</code>与<code>erase()</code>要求以迭代器为参数进行访问。由于<code>string</code>不像其他STL容器那样需要参数，因此可以直接如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = str.begin(); it != str.end(); i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it;</span><br></pre></td></tr></table></figure><p><strong><code>string</code>和<code>vector</code>一样，允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong></p></li></ol></li><li><p><code>string</code>常用函数</p><ol><li><p><code>operator+=</code></p><p><code>string</code>的加法，可以将两个<code>string</code><strong>直接拼接</strong>。</p></li><li><p><code>compare operator</code></p><p>两个<code>string</code>类型可以<strong>直接使用 比较符 比较大小</strong>，比较规则是<strong>按字典序</strong>。</p></li><li><p><code>begin()</code>：取 string 的<strong>首元素地址</strong></p></li><li><p><code>end()</code>：取 string 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p></li><li><p><code>size()/length()</code>：返回 string 的长度</p></li><li><p><code>clear()</code>：清空 string 中的数据</p></li><li><p><code>insert</code></p><ul><li><p>在 pos 位置插入字符串：<code>insert(int pos, string str)</code>，<strong>原来位置的字符串顺延</strong>。</p></li><li><p>在 迭代器it 位置插入字符串：</p><p><code>insert(it, it2, it3)</code>，<code>it2</code>和<code>it3</code>为<strong>待插字符串的首尾迭代器</strong>，用来表示串 [it2, it3) 将被插在 it 位置上</p></li></ul></li><li><p><code>string::npos</code>：是一个<strong>常数</strong>，本身值为<strong>-1</strong>，但由于是<code>unsigned_int</code>类型，因此实际上<strong>可以认为是最大值</strong>。用于作为<code>find</code>函数失配时的返回值。</p></li><li><p><code>find()</code></p><ul><li><code>str.find(string str1)</code>：当 str1 是子串时，返回在 str 中<strong>第一次出现的位置</strong>；如果不是字串，则返回<code>string::npos</code></li><li><code>str.find(string str1, int pos)</code>：从 pos 位置开始匹配 str1</li></ul></li><li><p><code>erase()</code></p><ul><li>删除单个元素：<code>erase(it)</code>，目标字符<strong>之后的字符字串 前移</strong>。</li><li>删除一个区间内的所有元素，目标区间<strong>之后的字符字串 前移</strong>。<ul><li><code>erase(firstIt, lastIt)</code>，删除 [firstIt, lastIt) 间的所有字符</li><li><code>erase(int pos, int length)</code>，pos 是删除的起始位置</li></ul></li></ul></li><li><p><code>substr(int pos, int length)</code>：<strong>返回</strong>从 pos 位置开始，长度为 length 的<strong>字串</strong>。</p></li><li><p><code>replace()</code></p><ul><li><code>str.replace(int pos, int lenth, str1)</code>：把 str 从 pos 位置开始，长度为 length 的字串替换为 str1，<strong>替换位置之后的字符串不变</strong>。</li><li><code>str.replace(it1, it2, str1)</code>：把 str 的迭代器 [it1, it2) 范围的字串替换为 str1，<strong>替换位置之后的字符串不变</strong>。</li></ul></li></ol></li></ol><hr><h4 id="lt-map"><a href="#lt-map" class="headerlink" title="&lt;map>"></a>&lt;map></h4><p><strong>映射</strong>，<code>map</code><strong>可以将 任何基本类型(包括STL容器) 映射到 任何基本类型(包括STL容器)</strong>。</p><p>来看一个情况：判定给的一些数字在某个文件中是否出现过。如果数字很大，那么就不便建立散列的数组。这时，<strong>可以通过<code>map</code>，将这些数字当成字符串，建立<code>string</code>至<code>int</code>的映射</strong>。</p><ol><li><p><code>map</code>的定义</p><p><code>map&lt;typename1, typename2&gt; mp;</code>：<code>&lt; &gt;</code>内第一个是 键(key) 的类型，第二个是 值(value) 的类型。<strong>map 会以 键 从小到大的顺序自动排序(因为 map 内部是使用红黑树实现的，set也是如此)</strong>。<strong>map 的一个键只能对应一个值</strong>。如果是 int 型映射到 int 型，就相当于普通的 int 型数组。</p><p>如果是<strong>字符串到整型的映射，必须使用 string 而不能使用 char数组</strong>：<code>map&lt;string, int&gt; mp;</code>，因为<strong>数组不能作为键值</strong>。</p></li><li><p><code>map</code>常用函数</p><ol><li><p><code>begin()</code>：取 map 的<strong>首元素地址</strong></p></li><li><p><code>end()</code>：取 map 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p></li><li><p><code>find(key)</code>：返回 键key的对应映射值 的迭代器</p><p><code>map&lt;char int&gt;::iterator it = mp.find(&#39;b&#39;);</code></p></li><li><p><code>erase()</code></p><ul><li>删除单个元素：<ul><li><code>erase(it)</code>：it 为待删除映射的迭代器</li><li><code>erase(key)</code>：key 为待删除映射的键</li></ul></li><li>删除一个区间内的所有映射：<code>erase(firstIt, lastIt)</code></li></ul></li><li><p><code>size()</code>：获取映射的对数</p></li><li><p><code>clear()</code>：清空 map 中的所有映射</p></li></ol></li><li><p><code>map</code>容器内元素的访问</p><ol><li><p>通过下标访问</p><p>例如定义为<code>map&lt;char, int&gt; mp</code>的map来说，可以直接使用<code>mp[&#39;c&#39;]</code>的方式来访问对应的整数。</p></li><li><p>通过迭代器访问</p><p><code>map&lt;typename1, typename2&gt;::iterator it;</code>，因为 map 的每一对映射都有两个 typename，这决定了必须<strong>能通过一个 it 来同时访问键和值</strong>。事实上，<code>map</code>可以使用<code>it-&gt;first</code>来访问键，<code>it-&gt;second</code>来访问值。</p></li></ol></li><li><p>延伸</p><p>map 的 键和值是唯一的(一对一)，而<strong>如果需要一个键对应多个值(一对多)，就只能用<code>multimap</code></strong>。C++11 标准中还增加了<code>unordered_map</code>，以散列代替 map 内部的红黑树实现，使其可以只处理映射而不按key值排序，速度比 map 快得多。</p></li></ol><hr><h4 id="lt-queue"><a href="#lt-queue" class="headerlink" title="&lt;queue>"></a>&lt;queue></h4><p>队列，先进先出。</p><ol><li><p><code>queue</code>的定义</p><p><code>queue&lt;typename&gt; name;</code></p></li><li><p><code>queue</code>常用函数</p><ol><li><code>push(x)</code>：将 x 进<strong>行入 队尾</strong></li><li><code>front()</code>、<code>back()</code>：分别获得队首和队尾元素</li><li><code>pop()</code>：令<strong>队首</strong>元素<strong>出队</strong></li><li><code>empty()</code>：<strong>检测 queue 是否为空</strong></li><li><code>size()</code>：返回队列内元素个数</li></ol></li><li><p><code>queue</code>容器内元素的访问</p><p>由于队列是一种先进先出的限制性数据结构，因此<strong>只能通过<code>front()</code>来访问队首元素，<code>back()</code>访问队尾元素</strong>。</p></li><li><p><code>queue</code>的常见用途</p><p>当需要实现<strong>广度优先搜索(BFS)</strong>时，可以不用手动实现一个队列，以提高程序的准确性。需要注意的时是，<strong>使用<code>front()</code>和<code>pop()</code>函数之前，必须用<code>empty()</code>判断队列是否为空</strong>，否则可能因为队空而出现错误。</p><p>延伸：STL的容器中还有两种跟队列有关：</p><pre><code>- **双端队列`deque`**：**首尾皆可插入和删除**的队列。</code></pre><ul><li><strong>优先队列<code>priority_queue</code></strong>：使用<strong>堆</strong>实现的<strong>默认当前队列 最大元素置于队首</strong>的容器。</li></ul></li></ol><h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><code>priority_queue</code></h5><ol><li><p><code>priority_queue</code>的定义</p><p><code>priority_queue&lt;typename&gt; name;</code></p></li><li><p><code>priority_queue</code>常用函数</p><ol><li><code>push(x)</code>：将 x入队，时间复杂度为O(<strong>logN</strong>)</li><li><code>top()</code>：获得队首(即堆顶)元素</li><li><code>pop()</code>：令队首元素(即堆顶)元素出队，时间复杂度为O(<strong>logN</strong>)</li><li><code>empty()</code>：检测优先队列是否为空</li><li><code>size()</code>：返回优先队列内元素个数</li></ol></li><li><p><code>priority_queue</code>容器内元素的访问</p><p><strong>只能通过<code>top()</code>函数访问队首元素(优先级最高的元素)</strong>。</p></li><li><p><code>priority_queue</code>内<strong>元素优先级的设置</strong></p><ol><li><p>基本数据类型的优先级设置</p><p>下列两种优先队列的定义是等价的(以<code>int</code>型为例)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure><ul><li><code>vector&lt;int&gt;</code>：用来<strong>承载底层数据结构—堆</strong>的容器</li><li><code>less&lt;int&gt;</code>：表示<strong>数字大的优先级越大</strong>(<strong>默认优先级</strong>)；<code>greater&lt;int&gt;</code>即为<strong>数字小的优先级越大</strong>。</li></ul><p>因此，如果想让最小的元素放在队首，需要如下定义：</p><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code></p></li><li><p>结构体的优先级设置</p><p>比如定义水果的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在希望<strong>按水果价格高的为优先级高</strong>，就需要<strong>重载小于号<code>&lt;</code></strong>：</p><ul><li><p>方式一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price; <span class="comment">//水果价格高的为优先级高</span></span><br><span class="line">        <span class="comment">// return f1.price &gt; f2.price; //水果价格低的为优先级高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>friend</code>为<strong>友元</strong>。<code>bool operator &lt; (fruit f1, fruit f2)</code><strong>对<code>&lt;</code>进行了重载</strong>。此时就可以直接定义<code>fruit</code>类型的优先队列，其内部就是以<strong>水果价格高的为优先级高</strong>：<code>priority_queue&lt;fruit&gt; q;</code></p></li><li><p>方式二：<strong>将重载的函数写在结构体外</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1, fruit f2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit, <span class="built_in">vector</span>&lt;fruit&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure></li></ul><p>即便是<strong>基本数据类型或者其他STL容器(如 set)</strong>，<strong>也可以通过同样的方式来定义优先级</strong>。如果结构体内的数据较为庞大，<strong>建议使用引用来提高效率</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> operate &lt; (<span class="keyword">const</span> fruit &amp;f1, <span class="keyword">const</span> fruit &amp;f2) &#123;</span><br><span class="line">    reutrn f1.price &gt; f2.price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或如下</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> fruit &amp;f1, <span class="keyword">const</span> fruit &amp;f2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>priority_queue</code>的常见用途</p><p>可以解决一些<strong>贪心问题</strong>，也可以<strong>对 Dijkstra 算法进行优化</strong>(因为优先队列的本质是堆)。需要注意的时是，<strong>使用<code>top()</code>函数之前，必须用<code>empty()</code>判断队列是否为空</strong>，否则可能因为队空而出现错误。</p></li></ol><hr><h4 id="lt-stack"><a href="#lt-stack" class="headerlink" title="&lt;stack>"></a>&lt;stack></h4><p>栈</p><ol><li><p><code>stack</code>的定义</p><p><code>stack&lt;typename&gt; name;</code></p></li><li><p><code>stack</code>常用函数</p><ol><li><code>push(x)</code>：将 x 压入栈</li><li><code>top()</code>：获得栈顶元素</li><li><code>pop()</code>：弹出栈顶元素</li><li><code>empty()</code>：检测 stack 是否为空</li><li><code>size()</code>：返回 stack 内元素的个数</li></ol></li><li><p><code>stack</code>容器内元素的访问</p><p><strong>只能通过<code>top()</code>函数访问栈顶元素</strong>。</p></li><li><p><code>stack</code>的常见用途</p><p>stack 用来<strong>模拟实现一些 递归</strong>，防止程序<strong>对栈内存的限制</strong>而导致程序运行出错。对有些题目来说，<strong>如果用普通的函数进行递归，一旦递归层数过深，则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题</strong>。</p></li></ol><hr><h4 id="lt-utility"><a href="#lt-utility" class="headerlink" title="&lt;utility>"></a>&lt;utility></h4><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a><code>pair</code></h5><p>当想要<strong>将两个元素绑在一起作为一个合成元素</strong>，又<strong>不想因此定义结构体</strong>时，使用<code>pair</code>可以很方便地作为一个替代品，即 pair 可以<strong>看作 内部有两个元素 的结构体</strong>。</p><ol><li><p><code>pair</code>的定义</p><p>注意：因为 映射map 的内部实现中涉及 pair，因此<strong>添加 map头文件 时会自动添加 utility头文件</strong>，因此，<strong>记不住 utility头文件，则可以用 map头文件 来代替</strong>。</p><p>pair 有两个参数：<code>pair&lt;typeName1, typeName2&gt; name;</code></p><ul><li><p>如果想<strong>在定义 pair 时进行初始化</strong>，只需要跟上一个小括号，填写两个初始化元素即可：</p><p><code>pair &lt;string, int&gt; p(&quot;haha&quot;, 5);</code></p></li><li><p>如果想<strong>临时构建一个 pair</strong>：</p><ul><li><code>pair&lt;string, int&gt;(&quot;haha&quot;, 5)</code></li><li>使用自带的<code>make_pair</code>函数：<code>make_pair(&quot;haha&quot;, 5)</code></li></ul></li></ul></li><li><p><code>pair</code>中元素的访问</p><p>pair 中<strong>只有两个元素，分别是<code>first</code>和<code>second</code></strong>，只需要<strong>按 正常结构体的方式 访问</strong>即可。</p></li><li><p><code>pair</code>常用函数</p><p><strong>比较操作数</strong>：</p><p>两个 pair 类型数据可以<strong>直接使用比较符比较大小</strong>，比较规则是<strong>先以<code>first</code>的大小作为标准，<code>first</code>相等时去比较<code>second</code>的大小</strong>。</p></li><li><p><code>pair</code>的常见用途</p><ul><li><p>代替二元结构体及其构造函数，节省编码时间</p></li><li><p>作为<code>map</code>的<strong>键值对</strong>来进行插入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">mp.insert(make_pair(<span class="string">"heihei"</span>, <span class="number">5</span>));</span><br><span class="line">mp.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"haha"</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p><strong>一维数组初始化</strong></p><p><strong>如果数组没有初始化，数组中每个元素为随机数</strong>。一维数组的初始化，<strong>未被赋初始值</strong>的元素将<strong>默认初始化为0</strong>，因此，如果想要给整个数组初始化为0，只需第一个元素初始化为0即可。<code>int a[10] = {0};</code>(<strong>不适用C语言</strong>)</p></li><li><p><strong>二维数组初始化</strong></p><p>二维数组初始化需要<strong>按第一维的顺序</strong>，依次<strong>用大括号</strong>给出<strong>第二维初始化</strong>的情况，<strong>未被赋初始值</strong>的元素将<strong>默认初始化为0</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">3</span>&#125;, &#123;&#125;, &#123;<span class="number">8</span>, <span class="number">4</span>&#125;&#125;; <span class="comment">//第二行使用大括号跳过</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">数组初始化为：</span></span><br><span class="line"><span class="comment">3 0</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">8 4</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果数组大小较大(大概$10^6$级别)，需要定义在主函数外(即全局变量)</strong></p><p>否则程序会异常退出（局部变量来自系统栈，允许申请空间较小；全局变量来自静态存储区，允许申请的空间较大）</p></li><li><p><strong>对数组中每一个元素赋相同的值</strong></p><p><strong>需要<code>#include &lt;cstring&gt;</code></strong></p><p><code>void* memset(数组名, 值, sizeof(数组名));</code></p><p>memset <strong>按字节赋值</strong>，即对每个字节赋同样的值，<strong>组成int型的4个字节就会被赋成相同的值</strong>。故建议<strong>只用于赋 0或 -1</strong>(0的二进制补码为全0，-1的二进制补码为全1)，不易出错。</p><p><strong>如果要对数组赋其他数字(如 1)，则使用 fill函数（执行速度比 memset 慢）</strong>。</p></li></ol><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ul><li><p>输入</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>scanf(&quot;%s&quot;, str);</code> 识别<strong>空格或换行</strong>作为输入结束，且<strong>空格或回车符会留在缓冲区</strong></p></li><li><p><code>char c = getchar();</code> 能够读入<strong>空格和换行符</strong></p></li><li><p><code>gets(char* str);</code> 识别<strong>换行</strong>作为输入结束，且<strong>回车符会被舍弃，不在缓冲区</strong></p><p>因此，<strong>scanf一个输入后，如果要使用gets，需要先用 getchar 接收scanf后的空格或换行符</strong>。</p><p>另外，<strong>PAT使用C++提交时</strong>，使用<code>gets()</code>函数会出现<strong>编译错误</strong>，建议使用C++函数。</p></li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>cin &gt;&gt;</code></p></li><li><p><code>cin.getline(数组名称, 数组大小)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指定最多读入 9 个字符，超出即报错</span></span><br><span class="line"><span class="comment">（实际数组最多能存放99个字符，空字符\0 占用一个字符位）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>输出</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>printf(str);</code> </li><li><code>putchar(char c);</code></li><li><code>puts(char* str);</code> 输出数组内容后，<strong>紧跟一个换行</strong></li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br></pre></td></tr></table></figure><ul><li><code>cout &lt;&lt;</code></li></ul></li></ul></li><li><p>字符数组的存放方式</p><p>字符数组的<strong>末尾都有一个 空字符<code>\0</code>(即NULL)，表示存放的字符串的结尾</strong>。空字符<code>\0</code> 在<strong>gets</strong>和<strong>scanf</strong>输入字符串时，会<strong>自动添加在输入的字符串后面</strong>，并<strong>占用一个字符位</strong>。<strong>puts</strong>和<strong>printf</strong>就是<strong>通过识别<code>\0</code>作为字符串的结尾进行输出</strong>。</p><ul><li>空字符<code>\0</code><strong>占用一个字符位</strong>，因此<strong>字符数组的长度一定要比实际存储字符串的长度 至少多1</strong>。</li><li>如果<strong>使用<code>getchar()</code>输入字符串</strong>，一定要在<strong>每个字符串后加入<code>\0</code>，否则printf和puts输出字符串会因无法识别字符串末尾而输出一大堆乱码</strong>。</li></ul></li></ul><hr><h3 id="C-的标准库类-string"><a href="#C-的标准库类-string" class="headerlink" title="C++ 的标准库类 string"></a>C++ 的标准库类 string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>若引用了<code>&lt;iostream&gt;</code>头文件，创建string对象时，无须引用<code>&lt;string&gt;</code>，因为<code>&lt;iostream&gt;</code>有对<code>std::string</code>的间接引用。但时要对string对象运用相关的函数操作，仍须引用<code>&lt;string&gt;</code>。</p><ul><li><p>输入一整行</p><p><code>getline(cin, str)</code></p></li><li><p>比较字符串大小</p><ul><li><p><code>str1.compare(str2)</code></p><p><strong>按字典顺序(顺序越靠后，越大)</strong>，返回两个字符串大小的比较</p></li></ul></li></ul><hr><h3 id="lt-cstring"><a href="#lt-cstring" class="headerlink" title="&lt;cstring>"></a>&lt;cstring></h3><ol><li><p><code>strlen(str)</code></p><p>得到字符数组中<strong>第一个<code>\0</code>前 的字符个数</strong></p></li><li><p><code>strcmp(str1, str2)</code></p><p><strong>按字典顺序(顺序越靠后，越大)</strong>，返回两个字符串大小的比较结果：</p><ul><li><code>str1 &lt; str2</code>，返回一个<strong>负整数</strong>(不同编译器处理不同，<strong>不一定是 -1</strong>)</li><li><code>str1 == str2</code>，返回一个0</li><li><code>str1 &gt; str2</code>，返回一个<strong>正整数</strong>(不同编译器处理不同，<strong>不一定是 +1</strong>)</li></ul></li><li><p><code>strcpy(str1, str2)</code></p><p>把 str2 复制给 str1，<strong>包括结束符<code>\0</code></strong></p></li><li><p><code>strcat(str1, str2)</code></p><p>把 str2 <strong>拼接</strong>到 str1 后面</p></li></ol><hr><h3 id="字符串与数字的相互转换"><a href="#字符串与数字的相互转换" class="headerlink" title="字符串与数字的相互转换"></a>字符串与数字的相互转换</h3><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br></pre></td></tr></table></figure><p>字符串 <strong>转为 数字</strong></p><ul><li><code>atoi(str)</code>：将字符串转为 int型</li><li><code>atol(str)</code>：将字符串转为 long long型</li><li><code>atof(str)</code>：将字符串转为 double型</li></ul><hr><h5 id="方法二：-sscanf-与-sprintf"><a href="#方法二：-sscanf-与-sprintf" class="headerlink" title="方法二： sscanf 与 sprintf"></a>方法二： sscanf 与 sprintf</h5><p>如果想从屏幕输入 int型变量n 并将 n 输出到屏幕：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n);</span><br><span class="line"><span class="comment">//其实可以表示成如下</span></span><br><span class="line"><span class="built_in">scanf</span>(screen, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(screen, <span class="string">"%d"</span>, n);</span><br></pre></td></tr></table></figure><p><code>sscanf</code>与<code>sprintf</code>的格式如出一辙，只是把screen换成了字符数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n); <span class="comment">//将字符数组str中的内容以"%d"格式写到n中</span></span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d"</span>, n); <span class="comment">//把n以"%d"的格式写到str数组中</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">"2048:3.14,hello"</span>, str2[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从字符串读取格式化输入</span></span><br><span class="line"><span class="comment">    使得 n = 2048, db = 3.14, str2 = hello</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">"%d:%lf,%s"</span>, &amp;n, &amp;db, str2);</span><br><span class="line">    n = <span class="number">12</span>;</span><br><span class="line">    db = <span class="number">3.1415</span>;</span><br><span class="line">    str2[<span class="number">100</span>] = <span class="string">"good"</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    发送格式化输出到字符串</span></span><br><span class="line"><span class="comment">    使得 str = "12:3.14,good"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">"%d:%.2f,%s"</span>, n, db, str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="C-："><a href="#C-：" class="headerlink" title="C++："></a>C++：</h4><p>数字 <strong>转为 字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = to_string(num);</span><br><span class="line">len = str.length();</span><br></pre></td></tr></table></figure><hr><h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><ul><li>参数中数组的<strong>第一维不需要填写长度</strong>(如果是二维数组，<strong>第二维需要填写长度</strong>)</li><li><strong>在函数中对数组元素的修改 等同于 对原数组元素的修改</strong>(与普通局部变量不同)</li></ul><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[][<span class="number">5</span>])</span> </span>&#123;<span class="comment">//参数数组 第一维不需要填写长度，第二维需要填写长度</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    b[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//不适用C语言</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">5</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//不适用C语言</span></span><br><span class="line">    change(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出结果为：</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组不允许作为返回类型出现，<strong>想要返回数组，只能通过参数返回</strong></li></ul><hr><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li><p>C语言习惯于把<code>*</code>放在变量名之前：<code>int *p;</code>(声明多个指针时，<strong>易统一</strong>)</p></li><li><p>C++习惯把<code>*</code>放在数据类型之后：<code>int* p;</code></p></li><li><p><strong>地址赋给<code>p</code>而不是<code>*p</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = &amp;a; <span class="comment">//等价于 int* p = &amp;a;</span></span><br></pre></td></tr></table></figure></li><li><p>指针的加减法</p><ul><li>两个指针相减，得到两个地址的距离</li><li><code>p + 1</code>指 p所指的int型变量 的<strong>下一个int型变量地址</strong></li><li>指针<strong>支持自增和自减操作</strong></li></ul></li></ul><hr><h3 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h3><p>例子：<strong>交换两个数</strong></p><p><strong>只有在获取地址的情况下对元素进行操作，才能真正修改变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a, *p2 = &amp;b;</span><br><span class="line">    swap(p1, p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误写法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* tmp;</span><br><span class="line">    *tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *tmp;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tmp未初始化，存放的地址很大概率指向系统工作区间，不能修改，故后续报错</span></span><br><span class="line"><span class="comment">初始化tmp即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span>* tmp = &amp;x;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="引用的含义"><a href="#引用的含义" class="headerlink" title="引用的含义"></a>引用的含义</h4><p>引用是C++的语法，在编程时极为实用。如果要<strong>修改传入函数的参数，且不使用指针</strong>，可以通过<strong>C++的引用</strong>。引用<strong>不产生副本</strong>，只是<strong>给原变量起个别名</strong>。</p><p>引用的方法：在函数的<strong>参数变量名前加个<code>&amp;</code>即可</strong>。要将<strong>引用<code>&amp;</code></strong>与<strong>取地址运算符<code>&amp;</code></strong>区分开来，<strong>引用并不是取地址的意思</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    change(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x); <span class="comment">//输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h4><p>例子：<strong>交换两个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* tmp = a;</span><br><span class="line">    a = b; <span class="comment">//交换的地址 是 值传递，不会修改原指针的地址</span></span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过引用实现交换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* &amp;a, <span class="keyword">int</span>* &amp;b)</span> </span>&#123; <span class="comment">//通过引用实现交换</span></span><br><span class="line">    <span class="keyword">int</span>* tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a, *p2 = &amp;b;</span><br><span class="line">    swap(p1, p2); <span class="comment">//不能写成 swap(&amp;a, &amp;b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用是产生<strong>变量的别名，常量不可使用引用</strong>。故上述</p><blockquote><p><code>swap(p1, p2); //不能写成 swap(&amp;a, &amp;b);</code></p></blockquote><hr><h2 id="结构体（struct）的使用"><a href="#结构体（struct）的使用" class="headerlink" title="结构体（struct）的使用"></a>结构体（struct）的使用</h2><h3 id="访问结构体内的元素"><a href="#访问结构体内的元素" class="headerlink" title="访问结构体内的元素"></a>访问结构体内的元素</h3><p>假设<code>p</code>是一个指向结构的指针，可以用<strong><code>p-&gt;结构成员</code>的形式（等价于<code>(*p).结构成员</code>）</strong>，引用相应的结构成员。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言和C++的比较</title>
      <link href="/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td><strong>scanf函数<br>printf函数</strong></td><td>cin<br>cout</td><td>cin 和 cout <strong>无需指定输入输出格式</strong>，<br>但<strong>消耗的时间</strong>比 scanf 和 printf <strong>多得多</strong></td></tr></tbody></table><hr><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><table><thead><tr><th>内容</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>输入输出库</td><td>#include &lt;stdio.h&gt;</td><td><strong>#include &lt;cstdio></strong><br><strong>#include &lt;iostream></strong></td></tr><tr><td>数学函数</td><td>#include &lt;math.h&gt;</td><td><strong>#include &lt;cmath></strong></td></tr><tr><td>字符串有关函数</td><td>#include &lt;string.h&gt;</td><td><strong>#include &lt;cstring></strong></td></tr></tbody></table><hr><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="布尔型变量"><a href="#布尔型变量" class="headerlink" title="布尔型变量"></a>布尔型变量</h3><table><thead><tr><th>C语言</th><th>C++</th><th>比较</th></tr></thead><tbody><tr><td>#include &lt;stdbool.h&gt;</td><td><strong>可直接使用</strong></td><td>true(存储时为1)<br>false(存储时为0)</td></tr></tbody></table><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><table><thead><tr><th>内容</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>表示方法</td><td>通过 字符数组 表示</td><td>通过 string类 表示</td></tr><tr><td>字符串长度的表示</td><td>#include &lt;string.h&gt;<br>strlen(str)</td><td>#include &lt;string><br>str.length()</td></tr><tr><td>字符串拼接</td><td>#include &lt;string.h&gt;<br>strcat(str1, str2); //把str2拼接到str1之后</td><td>str1 += str2;</td></tr></tbody></table><hr><h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><ul><li>C语言 — qsort</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b; <span class="comment">//升序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(排序数组, 元素数量, 每个元素的大小(可用<span class="keyword">sizeof</span>获得), 比较函数cmp);</span><br></pre></td></tr></table></figure><ul><li>C++ — sort</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">//降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(首元素地址, 尾元素地址的下一个地址, 比较函数cmp(非必填));</span><br></pre></td></tr></table></figure><table><thead><tr><th>cmp函数的区别</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>返回值类型</td><td>int</td><td>bool</td></tr><tr><td>排序的判断</td><td>返回值 &gt; 0, a 将被排在b后面;<br>返回值 &lt; 0, a 将被排在b前面;</td><td><strong>默认升序</strong><br>返回值为<strong>true</strong>时，a将被排在b<strong>前面</strong></td></tr><tr><td>比较方式</td><td>元素<strong>相减</strong><br>不能用$&gt;$、$&lt;$比较符（<strong>返回无负值</strong>）</td><td>$&gt;$、$&lt;$比较符</td></tr></tbody></table><p><code>qsort</code>函数的使用需要运用指针，且写法上没有<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p><p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启动U盘安装Ubuntu(单系统)</title>
      <link href="/2020/01/17/%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>/2020/01/17/%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>由于<strong>PE方式只适用于安装windows</strong>，因此选择常规的<strong>制作启动U盘</strong>进行Ubuntu的安装。</p><h3 id="操作系统镜像下载（桌面版，文件名后缀-iso-torrent）"><a href="#操作系统镜像下载（桌面版，文件名后缀-iso-torrent）" class="headerlink" title="操作系统镜像下载（桌面版，文件名后缀 .iso.torrent）"></a>操作系统镜像下载（桌面版，文件名后缀 .iso.torrent）</h3><ul><li>方式一：<a href="https://ubuntu.com/#download" target="_blank" rel="noopener">Ubuntu官网直接下载镜像</a></li><li>方式二：<a href="http://releases.ubuntu.com/18.04/" target="_blank" rel="noopener">Ubuntu官网下载镜像种子</a> + 迅雷下载镜像 （速度快，<strong>推荐</strong>）</li></ul><h3 id="3G及以上空间的U盘-移动硬盘-用于装载系统镜像"><a href="#3G及以上空间的U盘-移动硬盘-用于装载系统镜像" class="headerlink" title="3G及以上空间的U盘/移动硬盘(用于装载系统镜像)"></a><strong>3G及以上空间</strong>的U盘/移动硬盘(用于装载系统镜像)</h3><h3 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h3><ul><li><p>方式一：<strong>Windows 10 可以直接打开 iso镜像文件，不用下载任何工具</strong></p><ol><li><p>格式化U盘</p></li><li><p>双击ISO文件，然后选中打开的所有文件，复制到U盘即可</p></li></ol></li><li><p>方式二：<a href="http://rufus.ie/" target="_blank" rel="noopener">下载U盘制作制作工具Rufus</a>(<strong>无需安装，可直接运行</strong>)</p><ol><li><p>选择设备(需要被制作的U盘/移动硬盘)</p><ul><li>只有一个外接设备时会自动读取</li><li>如果<strong>外接设备是移动硬盘</strong>，需要<strong>显示高级设备选项 — 显示USB外置硬盘</strong></li></ul></li><li><p>选择操作系统镜像</p></li><li><p><strong>分区类型</strong>（<strong>理论上</strong>（联想Y480不知道为什么无法通过UEFI成功安装））</p><p><a href="https://www.bilibili.com/video/av45677113" target="_blank" rel="noopener">硬盘格式与引导方式、MBR与GPT、UEFI 与LEGACY bios的区别</a></p><ul><li><p>若选择GPT，之后系统安装时选择<strong>UEFI启动</strong>（<strong>推荐</strong>）</p></li><li><p>若选择MBR，之后系统安装时<strong>选择BIOS启动，否则报错</strong>（该模式一定能够安装成功）</p></li></ul></li><li><p>其余选项默认，点击<strong>开始</strong>，即可制作启动U盘</p></li></ol><p><img src="https://i.loli.net/2020/01/17/9KOmaTAQcIqdkpo.png" alt="Rufus制作启动U盘" style="zoom:80%;"></p></li></ul><hr><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol><li><p>重启电脑，进入<strong>选择启动方式界面</strong>（联想笔记本：F12；惠普笔记本：F9）</p></li><li><p>选择启动U盘</p><ul><li>想要安装系统的硬盘的格式为<strong>GPT</strong>，选择<strong>UEFI启动，即 EFI USB Device</strong></li><li>启动U盘分区类型为<strong>MBR</strong>，选择<strong>BIOS启动，即 选择对应的U盘</strong></li></ul></li><li><p>欢迎 — 中文 — 安装Ubuntu</p></li><li><p>键盘布局 — 汉语</p></li><li><p>无线 — 不连接</p></li><li><p>更新和其他软件 — <strong>最小安装</strong></p></li><li><p>安装类型 — 其他选项 — 进行分区</p><p>硬盘大小110GB</p><ul><li><p><strong>UEFI</strong>启动：</p><p>| 空间大小                    | 主分区/逻辑分区 | 类型                     |<br>| ————————— | ————— | ———————— |<br>| 200MB                       | <strong>逻辑分区</strong>    | <strong>EFI</strong>                  |<br>| 8GB<br>（和内存大小一致） | 主分区          | swap(交换)               |<br>| 40GB                        | 逻辑分区        | ext4<br>挂载至 “/”     |<br>| 剩余空间                    | 逻辑分区        | ext4<br>挂载至 “/home” |</p></li><li><p><strong>BIOS</strong>启动：</p><p>| 空间大小               | 主分区/逻辑分区 | 类型                |<br>| ———————- | ————— | ——————- |<br>| 200MB                  | <strong>主分区</strong>      | <strong>biosxx</strong>          |<br>| 8GB （和内存大小一致） | 主分区          | swap(交换)          |<br>| 40GB                   | 逻辑分区        | ext4 挂载至 “/”     |<br>| 剩余空间               | 逻辑分区        | ext4 挂载至 “/home” |</p></li></ul></li><li><p>完成安装，根据提示重启即可(可拔去启动U盘/硬盘，避免再次从启动U盘启动)</p></li></ol><hr><h2 id="将-从主服务器下载-更换为-国内镜像站点下载"><a href="#将-从主服务器下载-更换为-国内镜像站点下载" class="headerlink" title="将 从主服务器下载 更换为 国内镜像站点下载"></a>将 从主服务器下载 更换为 国内镜像站点下载</h2><p>​    显示应用程序 - 软件和更新 - Ubuntu软件 - 下载自 - 其他站点 - 选择最佳服务器（自动选择最合适的站点）</p><hr><h2 id="更新系统文件"><a href="#更新系统文件" class="headerlink" title="更新系统文件"></a>更新系统文件</h2><p><strong>打开终端</strong>的快捷键：<code>Ctrl</code>+<code>Alt</code>+<code>T</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><hr><h2 id="获得各种开发工具"><a href="#获得各种开发工具" class="headerlink" title="获得各种开发工具"></a>获得各种开发工具</h2><p><code>sudo apt-get install build-essential</code></p><ul><li><p>安装<strong>文字编辑器vim</strong>和<strong>浏览器chromium</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br><span class="line">sudo apt-get install chromium-browser</span><br></pre></td></tr></table></figure></li><li><p>树视图</p><p><code>sudo apt-get install tree</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmder</title>
      <link href="/2019/04/16/Cmder/"/>
      <url>/2019/04/16/Cmder/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载Cmder（压缩包，解压即用），有两种不同的版本可供选择：</p><ul><li>Mini</li><li>Full（附带msysgit工具）</li></ul><p>可根据设备是否已安装git自行选择</p><hr><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="添加系统环境变量"><a href="#添加系统环境变量" class="headerlink" title="添加系统环境变量"></a>添加系统环境变量</h3><p>我的电脑 - 右键属性 - 高级系统设置 - 环境变量 - 系统变量，在<code>Path</code>中添加Cmder路径</p><p><img src="https://i.loli.net/2019/04/16/5cb5a739330de.png" alt></p><hr><h3 id="添加Cmder到右键菜单"><a href="#添加Cmder到右键菜单" class="headerlink" title="添加Cmder到右键菜单"></a>添加Cmder到右键菜单</h3><ol><li><code>Win + R</code> - 输入<code>Cmder</code>，确认，打开Cmder</li><li>点击右下方的<code>Create new console</code></li><li>Startup command or {Task} name - {bash::bash}</li><li>Run as administrator</li><li>Start，即打开一个管理员权限的控制台 <img src="https://i.loli.net/2019/04/17/5cb6b470b7f0f.png" alt></li><li>输入 <code>Cmder.exe /REGISTER ALL</code>，回车。即可在每个文件夹中鼠标右键右键 - <code>Cmder here</code>，打开Cmder</li></ol><hr><h2 id="默认开启设置"><a href="#默认开启设置" class="headerlink" title="默认开启设置"></a>默认开启设置</h2><p>Cmder窗口右下角右键<code>Show system menu</code> - General - Choose your startup task or even a shell with arguments: - {bash::bash} - Save settings</p><p><img src="https://i.loli.net/2019/04/17/5cb6bbe028a30.png" alt></p><hr><h2 id="关闭Tab不提示"><a href="#关闭Tab不提示" class="headerlink" title="关闭Tab不提示"></a>关闭Tab不提示</h2><p>Cmder窗口右下角右键<code>Show system menu</code> - General - Confirm - Close confirmations下的复选框全不勾选 - Save settings</p><p><img src="https://i.loli.net/2019/04/17/5cb6bd25b23b6.png" alt></p><hr><p>参考：<a href="http://weikeqin.cn/2017/04/28/cmder-notes/" target="_blank" rel="noopener">Cmder 使用 笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dev-C++</title>
      <link href="/2019/04/16/Dev-Cpp/"/>
      <url>/2019/04/16/Dev-Cpp/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dev-C++是一个SourceForge的项目，<strong>早已停止更新</strong>。</p><p>缺点：</p><ul><li>分辨率低，脱节于屏幕素质的提升，使用感官不佳</li><li>中文注释容易乱码，且没有明显的选项用来修改编码格式</li></ul><hr><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>安装过程中的语言没有中文选项，选择English即可，按照默认选项安装。首次运行时，选择<strong>使用软件时的语言</strong>为简体中文即可，按照默认选项完成初运行配置。</p><hr><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul><li>菜单栏 - 工具 - 编辑器选项 - 语法 - 预设 - Obsidian 黑曜石主题</li></ul><p><img src="https://i.loli.net/2019/04/16/5cb598b4cba28.png" alt="工具 - 编辑器选项"></p><p><img src="https://i.loli.net/2019/04/16/5cb599bfef712.png" alt="语法 - 预设 - Obsidian 黑曜石主题"></p><ul><li><p>菜单栏 - 工具 - 编辑器选项 - 基本</p><ul><li style="list-style: none"><input type="checkbox" checked> 显示编辑器提示</li><li style="list-style: none"><input type="checkbox" checked> 显示函数提示</li><li>高亮显示当前行 - 色彩 - Black</li></ul><p><img src="https://i.loli.net/2019/04/16/5cb59bb680afc.png" alt></p></li></ul><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>菜单栏 - 工具 - 编辑器选项 - 显示 - 字体 - YaHei Consolas Hybrid</p><p>字体下载： <a href="https://pan.baidu.com/s/1kldCHl7A5SIZaCLJniLzwQ" target="_blank" rel="noopener"><a href="https://pan.baidu.com/s/1kldCHl7A5SIZaCLJniLzwQ" target="_blank" rel="noopener">Consolas和微软雅黑混合字体</a></a></p><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>自动整理代码</td><td>Ctrl + Shift + A</td></tr><tr><td>代码补全</td><td>Ctrl + Space(<strong>和输入法切换快捷键冲突</strong>)</td></tr></tbody></table><p>自定义快捷键：工具 - 快捷键选项 - 菜单项的底部 - Show Code Completion(代码补全)，自定义即可。</p><hr><h2 id="添加-C99-C-11-标准"><a href="#添加-C99-C-11-标准" class="headerlink" title="添加 C99/C++11 标准"></a>添加 C99/C++11 标准</h2><p>工具 - 编译选项 - 编译时加入以下命令 - <code>-std=c99</code>或<code>-std=C++11</code></p><p><img src="https://i.loli.net/2019/04/16/5cb59e4d63a98.png" alt></p><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”"><a href="#初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”" class="headerlink" title="初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”"></a>初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”</h3><p>菜单栏 - 工具 - 编译选项 - 代码生成/优化 - 连接器 - 产生调试信息 - Yes</p><p><img src="https://i.loli.net/2019/04/17/5cb6d8b4f11b0.png" alt></p><h3 id="调试窗口查看变量的实时数据"><a href="#调试窗口查看变量的实时数据" class="headerlink" title="调试窗口查看变量的实时数据"></a>调试窗口查看变量的实时数据</h3><p>开启调试后，有三种方式可以查看变量的实时数据：</p><ol><li>左侧调试窗口 - 空白处鼠标右键 - 添加查看</li><li>下侧调试窗口 - 添加查看</li><li>代码界面鼠标在变量名处停留，会显示当前变量值</li></ol><p><img src="https://i.loli.net/2019/04/17/5cb6dc99352a7.png" alt></p><hr><p>参考：</p><ul><li><del><a href="https://ice1000.org/2016/10/28/DevCpp/" target="_blank" rel="noopener">如何正确使用 DEV C++</a></del></li><li><a href="https://blog.csdn.net/MonkeyWang98/article/details/80202024" target="_blank" rel="noopener">DEV-C++调试时出现“项目没有调试信息，你想打开调试选项并重新生成吗”</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dev-C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>香港两日半 | 不妨长作岭南人</title>
      <link href="/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/"/>
      <url>/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="情之所起"><a href="#情之所起" class="headerlink" title="情之所起"></a>情之所起</h2><p>说起香港，脑海中闪过的第一个念头就是《重庆森林》——重庆大厦里奔走的林青霞、趴在半山扶梯上窥看编号633住处的王菲和她哼唱的《California Dreamin’》。终于要去见识这个憧憬太久的目的地了啊。</p><p>准备用完整的两天时间游览香港，从杭州出发，在三种方案中做选择： </p><ol><li>飞机直飞香港 （香港机场，位置较偏，根据实时价格、抵达时间综合考虑）</li><li>高铁直达香港（西九龙高铁站，高价、抵达时间深夜）</li><li>火车到<strong>深圳站</strong>，无缝衔接<strong>罗湖关口</strong>（硬卧￥360+ ~ ￥400，当天下午出发，隔天早上6点多或8点多抵达深圳站）</li></ol><p>由于勤(shi)俭(ge)节(qiong)约(bi)，同时为了能最大化利用在港时间，选择了方案3，买了03月19日的15:17杭州东站出发的T101次硬卧中铺，03月20日08:15抵达深圳站。03月22日16:00深圳站返程。</p><p>以及如下准备：  </p><ul><li style="list-style: none"><input type="checkbox" checked> 带上身份证去办港澳通行证（￥80）+ 香港团队旅游签注（￥15，<strong>现在团签可自助过关，与个签没有分别</strong>；7个工作日出证）  </li><li style="list-style: none"><input type="checkbox" checked> 去中国银行兑换1000港币  </li><li style="list-style: none"><input type="checkbox" checked> 买好路上的干粮</li><li style="list-style: none"><input type="checkbox" checked> 备好北纬22°所需衣物</li><li style="list-style: none"><input type="checkbox" checked> 预订酒店（一般酒店都备有转换插头，无需自带）</li><li style="list-style: none"><input type="checkbox" checked> 根据个人需求：淘宝买香港的x日电话卡；或在手机自带的全球上网一类app上购买流量包</li></ul><p><strong>冲冲冲！</strong></p><hr><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p>一夜的火车，从北纬30°到北纬22°，20+℃的气温暗示着夏天的气息。换上短袖，跟着指示牌前往关口。</p><p><img src="https://i.loli.net/2019/03/27/5c9b65af74dc6.jpeg" alt="标识牌"></p><p><img src="https://i.loli.net/2019/03/29/5c9db75b6307e.jpeg" alt="标识牌"></p><p>自助过关，机器读取港澳通行证，人脸+指纹识别后出内地关口，再经香港的检查人员核实身份后，即可入关。</p><p><img src="https://i.loli.net/2019/03/29/5c9db7a38f91a.jpeg" alt="自助查验标识"></p><p><img src="https://i.loli.net/2019/03/29/5c9db7cb6463a.jpeg" alt></p><p><img src="https://i.loli.net/2019/03/29/5c9db7e0dd89f.jpeg" alt></p><p>过关之后，先去柜台办了一张八达通，把1000港币破开。接着跟着标识牌去羅湖站坐港铁MTR。上了地铁以后，一看手机果然没有信号了，启用购买的流量包，在墙外的Internet上尽情呼吸。</p><h3 id="第一站-大學"><a href="#第一站-大學" class="headerlink" title="第一站 大學"></a>第一站 大學</h3><p><img src="http://p1-q.mafengwo.net/s13/M00/D4/7C/wKgEaVybmLqAcKOZAAj0436BHXM79.jpeg" alt="大學站"></p><p>大學站所指的大學是<strong>香港中文大學</strong>，一出地铁站就可以出现在校园之内。在香港中文大學可以初窥香港的地形，依山而建、高低错落，似极了重庆，对重庆曾经的小香港别称有了一丝恍然。来香港中文大學主要是为了打卡景点<strong>天人合一</strong>，顺便感受一下高等学府的环境与氛围。</p><p>校内有免费大巴可以乘坐，坐上可到<strong>新亚学院</strong>的车次，天人合一便只有几步之遥。</p><p>我以为能拍到的天人合一 和 我实际上拍到的天人合一……</p><p><img src="http://p2-q.mafengwo.net/s13/M00/15/90/wKgEaVybrXWAEF5lAA2DIiXf-E829.jpeg" alt="天人合一"></p><p>校园角落：</p><p><img src="http://p3-q.mafengwo.net/s13/M00/DA/16/wKgEaVybm9-AOh6xABCfboRpnSc44.jpeg" alt></p><p><img src="http://n3-q.mafengwo.net/s13/M00/DA/1C/wKgEaVybm-KAckzIAA5ElX33Oes68.jpeg" alt></p><p><img src="http://n4-q.mafengwo.net/s13/M00/DA/22/wKgEaVybm-WAPVXZABLFqn7fKRA87.jpeg" alt="头脑特工队"></p><p><img src="http://n1-q.mafengwo.net/s13/M00/DA/2A/wKgEaVybm-mAenGvABy4pAOS__I08.jpeg" alt="巴士站点的宝可梦装饰"></p><p><img src="https://i.loli.net/2019/03/29/5c9dba427e1d0.jpeg" alt="校园里很容易发现的宝可梦元素"></p><p><img src="http://p3-q.mafengwo.net/s13/M00/D5/6A/wKgEaVybmUaAOfqXAB-iQlRulA098.jpeg" alt></p><p>香港的车道上总会印着慢駛，斑马线上总会印着望左或望右，当我们在说城市的人文关怀的时候，我们在说什么：</p><p><img src="https://i.loli.net/2019/03/29/5c9dbd1e0f31c.jpeg" alt></p><p><img src="http://b1-q.mafengwo.net/s13/M00/D5/51/wKgEaVybmT2AWbyIAB88o5XJexk61.jpeg" alt="img"></p><hr><h3 id="第二站-彩虹"><a href="#第二站-彩虹" class="headerlink" title="第二站 彩虹"></a>第二站 彩虹</h3><p><img src="http://b4-q.mafengwo.net/s13/M00/DA/EC/wKgEaVybnGiATIJBABrUlqkj9j080.jpeg" alt="彩虹站"></p><p>逛完香港中文大學之后，继续坐上开往紅磡方向的東鐡綫，经由九龍塘换乘开往調景嶺方向的觀塘綫，在彩虹站下车，C3/C4口出站，<del>跟着感觉走就到了打卡点</del>跟着导航找到一个三层的<strong>停车楼</strong>，走上楼就到了彩虹邨的天台球场打卡点。</p><p><img src="http://n4-q.mafengwo.net/s13/M00/21/3A/wKgEaVyYpPWASCoxABbKpJXZH7g06.jpeg" alt></p><p>坪石邨就在彩虹邨附近，一并打卡。</p><p><img src="http://p2-q.mafengwo.net/s13/M00/21/47/wKgEaVyYpQKAX3IQABkI976-WGg74.jpeg" alt></p><hr><h3 id="第三站-旺角"><a href="#第三站-旺角" class="headerlink" title="第三站 旺角"></a>第三站 旺角</h3><p><img src="http://p1-q.mafengwo.net/s13/M00/DD/68/wKgEaVybnhWAfe3tAA8QRIHaSp453.jpeg" alt></p><p>预订的酒店在旺角站附近的新興大厦，12点多到酒店登记，接待的前台一口甜软的台湾腔，仿佛服务上升了一个台阶，因为两点之后房间才能清理好，把行李暂存到前台之后出门觅食。</p><p>奥海城有一家轮胎一星的添好運点心专门店，有点路，但也可以顺便熟悉一下市区，就慢慢摇过去。香港的红绿灯还有喇叭播放的摇铃提醒，通过不同的节奏来提供听觉上的交通信号。当我们在说城市设计的时候，我们在说什么。这家添好運不在商场内部，而是外围的街边店，用普通话取了号，但店员在叫号的时候只用粤语，结果就过号了Orz…最终跟另外一家口拼了一桌，得以入座。点了酥皮叉烧包、虾饺、牛肉肠粉，满足。</p><p>吃完之后，去逛香港特色的“二楼书店”。寸土寸金的香港，小众的个体书店隐匿于窄小楼梯通往的上层楼层，西洋菜街分布着多家二楼书店，这个时候导航显得十分无力<del>，果然还是要跟着感觉走</del>。有一定年头的旧式电梯和陈旧的楼道已经相辅相成，一迈进逼仄的楼道，隔着喧闹的街市，年代感迎面而来。</p><p>走在街道上，正巧看到宣扬法轮功和抵制邪教的横幅只有一布之隔，各自发声。下意识感慨神奇，心生羡慕。</p><p>最终在商务印书馆找到了想买的书，外面世界的书真不便宜。如果国内能出版的话，最多￥30+应该就能买到，不过可以理解成出版自由的附加值来抚慰自己，以及感谢支付宝的境外推广活动。</p><h3 id="第四站-尖沙咀"><a href="#第四站-尖沙咀" class="headerlink" title="第四站 尖沙咀"></a>第四站 尖沙咀</h3><p>逛完书店，回到住处入住了房间。躺下来补充一下体力之后，出门地铁前往尖沙咀。因为一心想趁着天还亮着，去拍香港文化中心，没有注意就在尖沙咀站附近的重庆大厦。走了一段距离，就走到了香港文化中心。</p><p>维港一瞥：</p><p>然后由西到东走了一遍星光大道，走马观花了一遍著名港星的手印和简介。麦兜作为出现在星光大道上的唯一卡通形象，“木有鱼丸，木有粗面”的麦兜在香港的地位可见一斑，虽然是在愚人节之前来香港，但猪年看到出乎意料的麦兜也算应景。</p><p>逛完了星光大道，想着走回尖沙咀站打卡重庆大厦。走进重庆大厦，一股闷热感和走动的印度面孔让人感慨电影中的重庆大厦的相关画面，但如今与当初相比，治安和清洁方面该是好了很多，其中实在逛无可逛。看了下地图，发现恰好有一家蘭芳園在重庆大厦负一层。但是不能被重庆大厦的入口所迷惑，因为走进重庆大厦的正门却没有走到负一层的路。只需在街道上往北走上几步路，就能看到地下入口。</p><p>点了丝袜奶茶和猪扒包</p><p>一起拼桌的两位，一位是港人、一位是白人，两人用粤语无障碍交流着，在个别词汇无法表达时，会夹杂着些许英语。在香港这样一个文化如此多元的地域，你很难不被多元的语言交流所感染。正吃着饭，一位内地游客看着我们这桌有一张空着的凳子，便用普通话问白人小哥：“这个位置有人坐吗？”白人小哥停下交流，回头一瞥，同样用普通话回答道：“呃…没有。”不禁感叹白人小哥真的有、东西。吃完晚饭，准备起身结账时，不小心撞了一下桌子，把拼桌两位的饮料洒了一些出来，脑海中瞬间闪过一个念头：“我该说sorry还是对唔住还是唔好意思？”结果怂怂地用普通话说了两句：“不好意思”…</p><p>吃完饭出来天色已暗，不逛诚品，不足以谈人生？诚品书店名声在外，听了太多年，正好海港城有分店，就去逛了逛。逛过之后，才明白逛诚品书店为什么能消磨时间，想来算是个商场中的商场。</p><h3 id="第五站-跑馬地赛马场"><a href="#第五站-跑馬地赛马场" class="headerlink" title="第五站 跑馬地赛马场"></a>第五站 跑馬地赛马场</h3><p>逛完诚品，走向天星碼头，坐天星小轮到对岸，再去跑馬地馬场看每周三的赛马。原本想坐到湾仔碼头（莫名想吃水饺…），一不留神坐上了去往中环碼头的轮渡。</p><p>在天星小轮上一赏维港夜景：</p><p>到达对岸之后，前往公交站，坐上去跑馬地馬场的巴士。到站后发现，票价港币$10的<strong>公众入口只有G口</strong>，还需要往南走上一段路。刷八达通即可入场感受人声鼎沸、灯火通明的香港赌马文化。其中酒水餐饮一应俱全，不得不感叹赛马的魅力。</p><h3 id="第六站-廟街"><a href="#第六站-廟街" class="headerlink" title="第六站 廟街"></a>第六站 廟街</h3><p>看完一场赛马之后，准备坐巴士去廟街。巴士的站点正好在一座印度廟前，正好遇到当天仪式的印度人一家又一家地从中走出，再次感叹文化的多元。廟街不如想象中的热闹，想到极限挑战好想在这里取过景。一家家街角的大排档确实有让人想一尝的想法，但是单人旅途确实和大排档不合适。笔直的廟街中间是搭起棚子的贩卖各色饰品、服装、玩具纪念品的小摊贩，两侧的商铺则有形形色色的食铺、覆上帘子的成人影片店铺，还能看到几位穿着暴露的性服务者… 最后，找到了拍廟街远景的停车楼，我想象中能拍到的廟街 和 我实际上拍到的廟街：</p><p>在麥文記麺家吃了一碗云吞面作宵夜，好像就是running man去吃过的那家。</p><p>走了3万步的一天终于结束了…</p><hr><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h2><h3 id="第七站-翠园金華冰厅"><a href="#第七站-翠园金華冰厅" class="headerlink" title="第七站 翠园金華冰厅"></a>第七站 <del>翠园</del>金華冰厅</h3><p>原本想去翠园（旺角新世纪广场店）吃早茶，在路上找到一片涂鸦墙，真好啊。</p><p>10点多找到店铺后，排号的人已不少，感觉不一定能在11：30前的早茶时间吃完，遂作罢。正好发现金華冰厅就在附近，<del>屁颠屁颠</del>走到店里，点了菠萝油和冻奶茶，菠萝油也太好吃了8？！</p><h3 id="第八站-香港大學"><a href="#第八站-香港大學" class="headerlink" title="第八站 香港大學"></a>第八站 香港大學</h3><p>Pillar of Shame</p><h3 id="第九站-半山扶梯"><a href="#第九站-半山扶梯" class="headerlink" title="第九站 半山扶梯"></a>第九站 半山扶梯</h3><p>原本应该从香港大學出发去卢吉道，但是Google地图用不惯……高德的导航没有给出一个合适的路线，只好曲线救国，先去打卡半山扶梯。</p><p>太平山街周边的涂鸦</p><p>拍了皇后大道、皇后大道西、皇后大道中，最后没有去打卡一下皇后大道东，<del>算了反正都没有皇宫</del>。</p><p>想不起来是先去吃的翠華餐廰还是先逛的半山扶梯。去翠華吃了咖喱牛腩饭和冻鸳鸯。</p><p>半山扶梯</p><h3 id="第十站-太平山顶"><a href="#第十站-太平山顶" class="headerlink" title="第十站 太平山顶"></a>第十站 太平山顶</h3><p><del>智障级徒步曲线爬坡，无数次感慨这就是重庆地形</del>登上凌霄阁观景台，真真正正的一滴都没有了。走了一段卢吉道，回想李尚敏坐红眼航班登卢吉道看香港日出的片段之后，排队缆车下山。</p><h3 id="第十一站-幻彩咏香江"><a href="#第十一站-幻彩咏香江" class="headerlink" title="第十一站 幻彩咏香江"></a>第十一站 <del>幻彩咏香江</del></h3><p>坐巴士去再興燒臘飯店，点了叉烧饭和鱼蛋菜汤。鱼蛋菜汤加了猪油，味道香浓。最后光盘行动…得到了老板娘“好靓仔”的夸奖…</p><p>拖着一滴都没有了的残躯，想去湾仔碼头的观景台看夜景。在8点过几分之后到达，发现是幻彩咏香江的盲区…香港岛这一侧的灯光是主体部分，在湾仔碼头却完美地被建筑遮挡，无法看到。后来发现就在碼头左侧的金紫荆广场应该是香港岛这一侧的优质观景位置。金紫荆广场上有着许多的香港动漫人物的塑像，如步惊云、陈浩南及许多卡通式人物，和对岸的星光大道有遥相呼应的味道。</p><p>从湾仔站打道回府，结束因徒步太平山而被掏空的一天…</p><hr><h2 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h2><h3 id="第十二站-翠园早茶"><a href="#第十二站-翠园早茶" class="headerlink" title="第十二站 翠园早茶"></a>第十二站 翠园早茶</h3><p>稍微比昨天早一点到了翠园，取号之后马上被叫到了号，如愿以偿吃上早茶。龙井+凤爪+豉汁蒸排骨+瑶柱灌汤饺。我对茶餐厅真的没有抵抗力啊…</p><h3 id="第十三站-买买买"><a href="#第十三站-买买买" class="headerlink" title="第十三站 买买买"></a>第十三站 买买买</h3><p>找了一家卖美国保健品的店铺，其中一个店员只会粤语和英语，结账时，为脑子里能出现checkout而感到欣慰… 赶在12点的退房时间前整理好行李退房 。屈臣氏、万宁、莎莎、卓悦等等不表…</p><h3 id="第十四站-重回香港中文大學"><a href="#第十四站-重回香港中文大學" class="headerlink" title="第十四站 重回香港中文大學"></a>第十四站 重回香港中文大學</h3><p>买好必需品后，乘上返程的地铁，想着适合解决午饭的地点。于是又回到开始的地方，轻车熟路去了众志堂食堂，自助点餐冻柠茶+烧味双拼饭后，八达通付款，吃完了在香港的最后一顿，Happy Ending。</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>过关安检、15:00进深圳站。返程的火车上，一群上海老年旅游团好不闹热，其乐融融的气氛能很好地感染他人。</p><p>遇到一个在义乌做生意的60岁韩国大叔。用我蹩脚的韩语+英语表达了我对running man、无限挑战、2天1夜的喜爱之情，尝了他分享的海苔。大叔说自己在中国吃面只吃打着新疆招牌的面和温州海鲜面哈哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优雅使用Windows 10</title>
      <link href="/2019/03/18/%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8Windows-10/"/>
      <url>/2019/03/18/%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8Windows-10/</url>
      
        <content type="html"><![CDATA[<h2 id="桌面效果图"><a href="#桌面效果图" class="headerlink" title="桌面效果图"></a>桌面效果图</h2><p><img src="https://i.loli.net/2019/03/28/5c9c986753d63.png" alt="Win 10桌面"></p><hr><h2 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h2><ul><li>PDF阅读器： <a href="https://www.gaaiho.com/index.php/zh-cn/products/reader/pdf-reader-pc/overview" target="_blank" rel="noopener">文电通PDF阅读器</a></li><li>视频播放器：<a href="https://daumpotplayer.com/download/" target="_blank" rel="noopener">PotPlayer</a></li><li>广告拦截：<a href="http://www.admflt.com/" target="_blank" rel="noopener">阿呆喵</a></li><li>解压缩软件：<a href="https://cn.bandisoft.com/bandizip/" target="_blank" rel="noopener">Bandizip</a></li><li>百度网盘全速下载：<a href="https://pandownload.com/" target="_blank" rel="noopener">PanDownload</a></li><li>UWP：DailyPic(Bing的每日壁纸，可选择性下载中意的壁纸作为桌面背景)</li></ul><hr><h2 id="系统速度优化"><a href="#系统速度优化" class="headerlink" title="系统速度优化"></a>系统速度优化</h2><p><code>Ctrl + alt + Esc</code>打开任务管理器 - 启动 - 选择需要禁用的开机启动项</p><hr><h2 id="任务栏透明化"><a href="#任务栏透明化" class="headerlink" title="任务栏透明化"></a>任务栏透明化</h2><p>Microsoft Store下载<strong>TranslucentTB</strong>，启动。</p><ul><li><strong>Open at boot</strong>(开机启动)</li><li><strong>Regular - Clear</strong>（常规 - 透明）</li></ul><hr><h2 id="滑动关机"><a href="#滑动关机" class="headerlink" title="滑动关机"></a>滑动关机</h2><ol><li><code>Win + S</code>唤出Cortana，搜索<code>SlideToShutdown</code>，选择打开文件位置</li><li>右键 - 发送到 - 桌面快捷方式</li><li>右键 - 属性 - 快捷键，自定义滑动关机快捷键，如<code>Ctrl + Alt + 1</code></li><li>如果想将滑动关机固定到任务栏，见<a href="#Win-10-风格图标">Win 10 风格图标</a></li></ol><hr><h2 id="Win-10-风格图标"><a href="#Win-10-风格图标" class="headerlink" title="Win 10 风格图标"></a>Win 10 风格图标</h2><p>注：仅适用于PC端软件，UWP应用不可用。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>图标素材网站：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>；<a href="https://www.easyicon.net/" target="_blank" rel="noopener">easyicon</a></li><li>PNG格式图标在线转为ico格式图标网站：<a href="https://www.easyicon.net/covert/" target="_blank" rel="noopener">iconvert</a></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>找到需要转换图标的软件快捷方式（如果不是快捷方式，右键 - 发送到 - 桌面快捷方式，统一进行转换）</li><li>在素材网站筛选合适的图标，选择下载<strong>白色</strong>的PNG格式图标</li><li>将图标转为ico格式，下载统一存放（便于管理）</li><li>右键软件快捷方式 - 属性 - 更改图标 - 浏览 - 在ico图标存放地址选择相应图标 - 确定</li><li>右键软件快捷方式 - 固定到任务栏</li><li>删除桌面上的软件快捷方式</li></ol><hr><h2 id="任务栏图标居中"><a href="#任务栏图标居中" class="headerlink" title="任务栏图标居中"></a>任务栏图标居中</h2><ol><li>桌面新建文件夹</li><li>右键任务栏空白处 - <strong>取消勾选</strong>锁定任务栏</li><li>右键任务栏空白处 - 工具栏 - 新建工具栏 - 选择桌面新建的文件夹</li><li>向左拖动新建的工具栏，将应用程序栏挤到右侧</li><li>右键新建的工具栏 - <strong>取消勾选</strong> 显示文本 和 显示标题</li><li>将应用程序栏拖拽到合适的位置后，锁定任务栏</li></ol><hr><h2 id="桌面的系统相关图标隐藏"><a href="#桌面的系统相关图标隐藏" class="headerlink" title="桌面的系统相关图标隐藏"></a>桌面的系统相关图标隐藏</h2><p><code>Win + i</code>打开设置 - 个性化 - 主题 - 相关的设置 - 桌面图标设置 - 取消勾选相应图标即可隐藏</p><hr><h2 id="资源管理器像浏览器一样使用Tab标签页"><a href="#资源管理器像浏览器一样使用Tab标签页" class="headerlink" title="资源管理器像浏览器一样使用Tab标签页"></a>资源管理器像浏览器一样使用Tab标签页</h2><ol><li>下载安装<a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener">QTTabBar</a></li><li><code>Win + E</code>打开资源管理器，查看 - 选项 - 勾选GTTabBar(注：选项按钮上方的默认图形只是选项的其中一项，<strong>需点击选项文字</strong>)，此时资源管理器就多出了标签栏</li><li>右键标签栏空白处 - QTTabBar Options - General - Download language file - 选择更新日期较近的简体中文（注：<strong>下载语言文件需要科学上网</strong>，附<a href="https://pan.baidu.com/s/1mc2Ubnh5JfEoELu5EnIKTg" target="_blank" rel="noopener">百度网盘资源</a>）- apply即可汉化</li><li>标签栏的”+”按钮默认为<strong>浏览文件夹并打开新标签</strong>，比较麻烦。右键标签栏空白处 - QTTabBar 选项 - 鼠标事件 - 标签和标签栏 - 点击标签栏的”+”按钮 - 用户命令 - 创建一个新命令 - 命令的类型 - 文件和文件夹 - 路径（根据个人喜好选择默认打开路径）</li><li>按照个人喜好调整功能</li></ol><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">Win + 数字</td><td style="text-align:left">对应任务栏从左到右固定的程序</td></tr><tr><td style="text-align:left">Win + A</td><td style="text-align:left">通知中心</td></tr><tr><td style="text-align:left">Win + L</td><td style="text-align:left">锁屏</td></tr><tr><td style="text-align:left">Win + D</td><td style="text-align:left">回到桌面/当前界面</td></tr><tr><td style="text-align:left">Win + W</td><td style="text-align:left">WINDOWS INK 工作区</td></tr><tr><td style="text-align:left">Win + - ( + )</td><td style="text-align:left">放大镜</td></tr><tr><td style="text-align:left">Win + Q/S</td><td style="text-align:left">Cortana</td></tr><tr><td style="text-align:left">Win + E</td><td style="text-align:left">文件资源管理器</td></tr><tr><td style="text-align:left">Win + I</td><td style="text-align:left">Windows 设置</td></tr><tr><td style="text-align:left">Win + K</td><td style="text-align:left">蓝牙</td></tr><tr><td style="text-align:left">Ctrl + Alt + Esc</td><td style="text-align:left">任务管理器</td></tr><tr><td style="text-align:left">Win + Ctrl + ⬅/➡</td><td style="text-align:left">切换至相邻的虚拟桌面</td></tr><tr><td style="text-align:left">Win + Shift + S</td><td style="text-align:left">可框选截图</td></tr><tr><td style="text-align:left">Win + Printscreen</td><td style="text-align:left">全屏截图</td></tr></tbody></table><hr><h2 id="触摸板手势"><a href="#触摸板手势" class="headerlink" title="触摸板手势"></a>触摸板手势</h2><table><thead><tr><th>手势</th><th>功能</th></tr></thead><tbody><tr><td>单指点击两次 + 拖动</td><td>多选</td></tr><tr><td>两指拖动</td><td>滚动页面</td></tr><tr><td>两指捏合</td><td>缩放</td></tr><tr><td>三指上滑</td><td>多任务视图</td></tr><tr><td>三指下滑</td><td>显示桌面</td></tr><tr><td>三指左右滑动</td><td>切换应用</td></tr><tr><td>三指单击</td><td>唤出Cortana</td></tr><tr><td>四指单击</td><td>通知中心</td></tr><tr><td>四指左右滑动</td><td>切换虚拟桌面</td></tr></tbody></table><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/yourng/article/details/83013726" target="_blank" rel="noopener">QTTabBar 简单配置</a></li><li><a href="https://sspai.com/post/45594" target="_blank" rel="noopener">Windows 虚拟桌面的高效启动技巧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新笔记本电脑验机</title>
      <link href="/2019/03/18/%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E9%AA%8C%E6%9C%BA/"/>
      <url>/2019/03/18/%E6%96%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E9%AA%8C%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>准备：下载<strong>卡硬工具箱免安装版</strong>至U盘或其他移动设备。</p><p><strong>以下任何一步有问题，退货。</strong></p><ol><li>检查笔记本外壳是否有<strong>指纹、裂痕、凹陷</strong>，机身是否有<strong>变形</strong>，屏幕是否<strong>完好</strong>。</li><li>USB接口是否有抽插痕迹。</li><li><strong>不插电源，直接按电源键</strong>，若<strong>能开机，则很可能是二手</strong>。</li><li>插上电源，按电源键开机。</li><li>进入系统，系统初始化设置（<strong>若没有设置界面，直接进入了系统，二手</strong>）。</li><li><strong>不连接网络</strong>，防止后续检查有问题无法退货。</li><li>进入桌面后，插上有卡硬工具箱的U盘。<ol><li>显示器工具 - 检测屏幕坏点。</li><li>硬盘工具 - Diskinfo - 检查通电次数和通电时间（<strong>一般通电时间在24小时内，通电次数在150次以内，可以判定为新机硬盘</strong>）。</li></ol></li></ol><p><strong>上述步骤没有出现问题后，依然不要联网，在无理由退货时间内使用电脑，以便后续使用不满意时方便退货。</strong></p><hr><p>参考：<a href="https://zhuanlan.zhihu.com/p/40181275" target="_blank" rel="noopener">笔记本电脑验机指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 验机与续命 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 验机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联想Y480拆机清灰</title>
      <link href="/2019/03/18/%E8%81%94%E6%83%B3Y480%E6%8B%86%E6%9C%BA%E6%B8%85%E7%81%B0/"/>
      <url>/2019/03/18/%E8%81%94%E6%83%B3Y480%E6%8B%86%E6%9C%BA%E6%B8%85%E7%81%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="彻底拆机清灰（涂硅脂、更换）"><a href="#彻底拆机清灰（涂硅脂、更换）" class="headerlink" title="彻底拆机清灰（涂硅脂、更换）"></a><a href="http://ideapad.it168.com/thread-5334703-1-1.html" target="_blank" rel="noopener">彻底拆机清灰</a>（涂硅脂、更换）</h2><h2 id="清理键盘"><a href="#清理键盘" class="headerlink" title="清理键盘"></a>清理键盘</h2><ol><li>键盘在D面有<strong>两个螺丝固定</strong>，先卸下D面挡板，再卸下键盘螺丝、固定光驱的螺丝。</li><li>按照彻底拆机的拆卸键盘方法即可取下键盘。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 验机与续命 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拆机 </tag>
            
            <tag> 清灰 </tag>
            
            <tag> 保养 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑屏幕色差矫正</title>
      <link href="/2019/03/18/%E7%94%B5%E8%84%91%E5%B1%8F%E5%B9%95%E8%89%B2%E5%B7%AE%E7%9F%AB%E6%AD%A3/"/>
      <url>/2019/03/18/%E7%94%B5%E8%84%91%E5%B1%8F%E5%B9%95%E8%89%B2%E5%B7%AE%E7%9F%AB%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<ul><li>电脑屏幕色彩管理软件：LUT Manager</li><li>MAC自带的颜色配置文件：MAC.icc</li><li>适用系统：Windows  </li></ul><hr><ol><li>下载<a href="https://pan.baidu.com/s/1p1jvs2lUirS_KbFI7T7w4g" target="_blank" rel="noopener">LUT Manager和MAC.icc</a></li><li>将MAC.icc放到<code>系统盘/windows/system32/spool/drivers/color/</code>目录下</li><li>打开控制面板（查看方式-图标）- 颜色管理 - 高级 - 更改系统默认值 - 高级 - 使用Windows显示器校准 - 关闭</li><li>设备 - 显示器 - 使用我对此设备的设置 - 添加 - 选择MAC.icc - 设置为默认配置文件 - 关闭</li></ol><hr><p>参考：<a href="https://www.mooyuu.com/school/985/#downs" target="_blank" rel="noopener">矫正色差的软件</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 屏幕色差 </tag>
            
            <tag> LUT Manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE方式安装Windows 10</title>
      <link href="/2019/03/18/PE%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Windows-10/"/>
      <url>/2019/03/18/PE%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Windows-10/</url>
      
        <content type="html"><![CDATA[<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>可以更改硬盘格式与引导方式</li><li>可以备份原有系统的数据</li><li>自带修复软件，可以在不重装系统的情况下修复系统</li></ol><hr><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>PE安装工具下载：<a href="http://www.wepe.com.cn/download.html" target="_blank" rel="noopener">微PE工具箱</a></li><li>操作系统镜像下载：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN</a></li><li><strong>8G及以上空间</strong>的U盘/移动硬盘(主要用于存放系统镜像)</li></ul><hr><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol><li><p>安装PE到U盘/移动硬盘</p></li><li><p>将操作系统镜像放到U盘（或移动硬盘对应的存储分区）</p></li><li><p>重启电脑，进入<strong>选择启动方式界面</strong>（联想笔记本：F12；惠普笔记本：F9）</p></li><li><p>选择PE所在设备，即启动PE</p></li><li><p>启动桌面上的<strong>Windows安装器</strong>：</p><ul><li><p>第一行：选择操作系统镜像文件</p></li><li><p>第二行（选择引导驱动器）：想要安装系统的硬盘的格式（<a href="https://www.bilibili.com/video/av45677113" target="_blank" rel="noopener">硬盘格式与引导方式、MBR与GPT、UEFI 与LEGACY bios的区别</a>）不同，需要选择的盘区也不同。</p><ol><li>GPT格式：选择ESP分区（大约90~250MB大小的一个隐藏盘区）</li><li>MBR格式：选择要装系统的盘区即可</li></ol><p><strong>两种方式都需要右边的三个指示灯不为红色（黄绿两色OK）</strong></p></li><li><p>第三行（安装磁盘的位置）：选择系统将要安装的盘区即可。</p></li><li><p>第四行：选择安装的Win 10版本。</p></li></ul><p>完成以上四行内容即可点击开始安装。</p><p>​    注：用 DiskGenius 格式化硬盘/转换硬盘格式 时记得勾选<strong>对齐分区到此扇区数的整数倍</strong>（即4K对齐，无需修改具体参数）。</p></li><li><p>重启系统，进行Win 10的初始化设置，<strong>建议进入桌面后再联网</strong>，操作过程会快一些。</p></li></ol><hr><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><p>去官网下载驱动安装，或者下载<strong>驱动精灵免安装版</strong>安装驱动（另外，Windows自身的更新会下载部分相关驱动）。</p><p>注：部分<strong>旧机型</strong>官网没有Windows10版本的相关驱动，不建议官网下载相关旧驱动，很可能不兼容。直接使用驱动精灵无脑安装基本驱动即可。</p><p>注注：博主的老机子联想Y480的触摸板在驱动精灵中没有相关的驱动，无法使用Win10的触摸板手势，但是<strong>鲁大师的驱动检测功能下可以看到触摸板驱动，选择升级即可使用手势</strong>。博主猜测此方法同样适用于部分老机型，不得不赞美一下娱乐大师。</p><p>注注注：Elitebook 830 G5的固态硬盘是三星的PM961，需要加上Turbo驱动提速，官网没有直接的链接，可以通过驱动精灵安装。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/av45170351" target="_blank" rel="noopener">Win 10全面官方装系统教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统与软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的基本概念</title>
      <link href="/2018/07/18/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/07/18/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>传统的C语言用法中，变量名使用小写字母，符号常量名使用大写字母</p><hr><h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符signed与unsigned可以用于<strong>限定char类型或任何整型</strong>。</p><ul><li><code>signed</code> （默认）<br>如char类型 <code>signed char</code>，取值范围为-128~127</li><li><code>unsigned</code> （<strong>无符号类型</strong>）<br>总是正值或0，例如char类型，<code>unsigned char</code> 取值范围为0~255</li></ul><hr><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><ul><li><p><strong>方法一： const 数据类型 变量名 = 常量；</strong>（<strong>推荐</strong>）</p><p>例： <code>const int AMOUNT=100;</code></p><p><code>const</code>也能配合<strong>数组参数</strong>使用，表明函数不能修改数组元素的值。</p></li><li><p><strong>方法二：#define 标识符 常量</strong><br><strong>末尾没有分号</strong><br>例：<code>#define LOWER 0</code></p></li></ul><hr><h2 id="定义布尔类型"><a href="#定义布尔类型" class="headerlink" title="定义布尔类型"></a>定义布尔类型</h2><ul><li>需要在开头写如下代码：<code>#include &lt;stdbool.h&gt;</code></li></ul><p>布尔类型为<code>bool</code> (Java中为Boolean)</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>例：<code>int number[100];</code> (Java中为 int[] number = new int[100];)</p><p>（C99开始，<strong>可以用变量定义数组大小</strong>）</p><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><ul><li><p><strong>列数必须给出</strong>，行数可以交给编译器来数</p></li><li><p>每行一个<code>{}</code>，用逗号分隔<code>,</code></p></li><li><p>最后的<code>,</code>可以存在，有古老的传统</p></li><li><p>如果内容省略，表示补0</p></li><li><p>也可以用定位（C99 ONLY）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">3</span>, <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>用<code>[n]</code>在初始化数据中给出定位</li><li>没有定位的数据接在前面的位置后面</li><li>其他位置的值补零</li><li>也可以不给出数组大小，让编译器算</li><li>特别适合初始数据稀疏的数组</li></ul></li></ul><h3 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h3><p><code>sizeof(a)/sizeof(a[0])</code></p><ul><li><code>sizeof</code>给出整个数组所占据的内容的大小，单位是字节</li><li><code>sizeof(a[0])</code>给出数组中单个元素的大小，相除就得到了数组的单元个数</li><li>数组作为函数的参数时 实际是指针（数组的地址）,<strong>需要用另一个参数来传入数组的大小</strong><ul><li>不能在<code>[]</code>中给出数组的大小</li><li>不能再利用<code>sizeof</code>来计算数组的元素个数</li></ul></li></ul><h3 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h3><ul><li>数组变量本身<strong>不能被赋值</strong></li><li>要把一个数组的所有元素交给另一个数组，必须采用遍历</li></ul><hr><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>char是一种整数，也是一种特殊的类型——字符。</p><ul><li><code>&#39;&#39;</code>也是一个字符</li><li><code>printf</code>和<code>scanf</code>里用<code>%c</code>来输入输出字符</li></ul><h3 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h3><table><thead><tr><th>字符</th><th>意义</th></tr></thead><tbody><tr><td><code>\b</code></td><td>回退一格</td></tr><tr><td><code>\t</code></td><td>到下一个表格位</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\\</code></td><td>反斜杠本身</td></tr></tbody></table><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>C语言的编译器自上而下，按顺序分析代码</strong>。</p><p><strong>函数的先后顺序</strong>很重要。</p><p>C语言的函数可以将声明和定义分离，从而顺利通过编译,如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>; <span class="comment">//声明，函数原型， 如果没有参数，括号内最好填写 void，更严谨</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">//main的参数部分也可以写 void</span></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">sum(<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d到%d的和是%d\n"</span>, begin, end, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul><li>调用函数时，<strong>给的值可以与参数类型不完全匹配</strong>，编译器自行转换类型，（Java则对类型转换要求严格）。</li><li>C语言调用函数传参数时，是<strong>值传递</strong>。</li></ul><hr><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><ul><li><p>一元运算符<code>&amp;</code><br>获取变量的地址，它的<strong>操作数必须是变量</strong>，没有其他的运算包括其中。<br><code>p = &amp;c;</code> 称p为“指向”c的指针。</p></li><li><p>一元运算符<code>*</code><br>间接寻址运算符。<code>*</code>作用于指针时，将访问指针所指向的变量。</p></li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针就是<strong>保存地址的变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p,q; <span class="comment">//p为指针，值为所指向的地址；*p是int类型变量，为所指向地址上的值；</span></span><br></pre></td></tr></table></figure><h3 id="指针应用场景"><a href="#指针应用场景" class="headerlink" title="指针应用场景"></a>指针应用场景</h3><ol><li><p>交换两个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *pa;</span><br><span class="line">    *pa = *pb;</span><br><span class="line">    *pb = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数需要返回多个值，某些值就只能通过指针返回</p></li></ol><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><ol><li><p>指针是const（<strong>*在const前</strong>）：表示一旦得到了某个变量的地址，不能再指向其他变量；<strong>不影响改变该地址上的值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> q = &amp;i; <span class="comment">//q是const</span></span><br><span class="line">*q = <span class="number">26</span>; <span class="comment">//所指变量的值可以更改</span></span><br><span class="line">q++; <span class="comment">//ERROR!</span></span><br></pre></td></tr></table></figure></li><li><p>所指的类型是const（<strong>*在const后</strong>）：表示不能通过指针去修改那个变量（<strong>不会使那个变量成为const</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i; <span class="comment">// int const *p 作用相同</span></span><br><span class="line">*p = <span class="number">26</span>; <span class="comment">//ERROR! (*p)是const</span></span><br><span class="line">i = <span class="number">26</span>; <span class="comment">//OK</span></span><br><span class="line">p = &amp;j; <span class="comment">//OK</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><p>以下四种函数原型等价</p><ul><li><code>int sum(int *arr, int n);</code></li><li><code>int sum(int *, int);</code></li><li><code>int sum(int arr[], int n);</code></li><li><code>int sum(int [], int)</code></li></ul><p><strong>数组变量是特殊的指针</strong></p><ul><li>数组无需用&amp;取地址</li><li><p>数组的单元表达的是变量，需要用&amp;取地址</p></li><li><p><code>[]</code>运算符可以对数组做，也可以对指针做<br><code>p[0] &lt;==&gt; a[0]</code></p></li><li><p><code>*</code>运算符可以对指针做，也可以对数组做</p></li><li><p>数组变量是const的指针，所以不能被赋值<br><code>int a[] &lt;==&gt; int *const a=...</code></p></li></ul><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C语言的字符串以字符数组的形态存在</p><ul><li>不能用运算符对字符串做运算<ul><li>通过数组的方式可以遍历字符串</li></ul></li></ul><p>以整数0结尾的一串字符为字符串。（0或<code>\0</code>是一样的，但是和<code>&#39;0&#39;</code>不同）</p><ul><li><strong>0标志字符串的结束，但不是字符串的一部分</strong></li><li>字符串以数组的形式存在，以数组或<strong>指针(主)的形式访问</strong></li><li><code>string.h</code>里有很多处理字符串的函数</li></ul><h3 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> word[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> line[<span class="number">10</span>] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>例如：<code>Hello</code>，字符串会被编译器变成一个字符数组放在某处，这个数组的<strong>长度是5+1</strong>，结尾还有<strong>表示结束的0</strong></p><p>例：<code>char* s = &quot;Hello, world!&quot;;</code></p><ul><li>s是一个指针，初始化为指向一个字符串常量<ul><li>由于这个常量存储的地方，实际上s为<code>const char* s</code>。(历史原因，编译器接受不带const的写法)</li><li>试图对s所指的字符串做写入会导致严重的后果</li></ul></li><li>如果需要修改字符串，应该用数组：<code>char s[] = &quot;Hello, world!&quot;;</code></li></ul><p><strong>选择指针还是数组形式处理字符串？</strong></p><ul><li><p>数组（字符串就存放在当前位置，<strong>如果要构造一个字符串</strong>）</p><ul><li>作为本地变量，空间被自动回收</li></ul></li><li><p>指针（不知道字符串的存储位置，<strong>如果要处理一个字符串</strong>）</p><ul><li>处理参数</li><li>动态分配空间</li></ul></li></ul><hr><h2 id="读入、输出数据"><a href="#读入、输出数据" class="headerlink" title="读入、输出数据"></a>读入、输出数据</h2><ul><li>需要在开头写如下代码：<code>#include &lt;stdio.h&gt;</code></li></ul><p>读取数据，需要在变量名前加上<code>&amp;</code>，从而赋值给变量。</p><h3 id="EOF（End-Of-File"><a href="#EOF（End-Of-File" class="headerlink" title="EOF（End Of File)"></a>EOF（End Of File)</h3><p>可以通过<code>printf(&quot;%d&quot;, EOF);</code>读取EOF的数值，一般的设备上值是-1。<br>EOF操作：</p><ul><li>windows：<code>Ctrl + Z</code></li><li>unix：<code>Ctrl + D</code></li></ul><h3 id="浮点数的输入输出"><a href="#浮点数的输入输出" class="headerlink" title="浮点数的输入输出"></a>浮点数的输入输出</h3><ul><li>输入：<code>scanf(&quot;%lf&quot;, ...);</code></li><li>输出：<ul><li><code>printf(&quot;%f&quot;, ...);</code> //float和double类型，printf函数都使用%f进行说明</li><li><code>printf(&quot;%ld&quot;, ...);</code> //对应long整型的参数</li></ul></li></ul><h3 id="字符的输入-输出"><a href="#字符的输入-输出" class="headerlink" title="字符的输入/输出"></a>字符的输入/输出</h3><ul><li>输入 <code>getchar()</code><br>从文本流中读入下一个输入字符，并将其作为结果值返回。</li><li>输出 <code>putchar(c)</code><br>打印一个字符</li></ul><h3 id="字符串的输入输出"><a href="#字符串的输入输出" class="headerlink" title="字符串的输入输出"></a>字符串的输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p>scanf读入一个单词（到空格、tab或回车为止）</p><hr><ul><li><code>program &lt;infile</code><br>从输入文件<code>infile</code>中读取字符。</li><li><code>otherprogram | program</code><br>将程序<code>otherprogram</code>的标准输出 通过管道，重定向到程序program的标准输入上。 </li></ul><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul><li><code>&amp;</code> 与</li><li><code>|</code> 或</li><li><code>^</code> 异或</li><li><code>~</code> 求反码</li><li><code>&gt;&gt;</code> 右移（高位出现的空位，原来高位是什么，就用什么补该空位；<code>&gt;&gt;&gt;</code>无符号右移，<strong>高位的空位用0补</strong>）</li></ul><hr><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li><p>外部</p><ul><li>用<code>static</code>声明限定外部变量与函数，可以将对象的<strong>作用域限定为被编译源文件的剩余部分</strong>。</li><li>通过<code>static</code>限定外部对象，可以达到隐藏外部对象的目的。</li><li>如果把函数名声明为static类型，则该函数名除了对该函数的声明所在的文件可见外，其他文件都无法访问。</li></ul></li><li><p>内部</p><ul><li><code>static</code>类型的内部变量，不管其所在函数是否被调用，都会存在。（一直占据存储空间；自动变量：随着函数的 调用/退出 而 存在/消失）</li></ul></li></ul><h2 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h2><p><code>register</code>声明告诉编译器，它所声明的变量在程序中使用频率较高</p><hr><h2 id="结构（和java中的类-概念类似-只有变量没有函数）"><a href="#结构（和java中的类-概念类似-只有变量没有函数）" class="headerlink" title="结构（和java中的类 概念类似,只有变量没有函数）"></a>结构（和java中的类 概念类似,只有变量没有函数）</h2><p>关键字<code>struct</code>引入结构声明。</p><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>关键字<code>struct</code>后面的名字是可选的，称为<strong>结构标记</strong>。</p><ul><li><p>有结构标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt</span> = &#123;</span><span class="number">320</span>, <span class="number">200</span>&#125;; <span class="comment">//定义了一个struct point类型的变量pt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt2</span> = &#123;</span>.y = <span class="number">200</span>, .x = <span class="number">320</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>无结构标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; p1, p2; <span class="comment">//p1、p2都是无标记结构，里面有x和y</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>结构的合法操作只有几种：<strong>作为一个整体赋值和赋值（包括向函数传递参数以及从函数返回值）</strong>，通过<code>&amp;</code>运算符取地址，访问其成员。</p><p>例：函数<code>makepoint</code>，带有两个整型参数，并返回一个point类型的结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct point <span class="title">makepoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">temp</span>;</span></span><br><span class="line">temp.x = x;</span><br><span class="line">temp.y = y;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结构指针</strong>的使用频度非常高，为了使用方便，C语言提供了另一种简写方式。假设<code>p</code>是一个指向结构的指针，可以用<code>p-&gt;结构成员</code>的形式（等价于<code>(*p).结构成员</code>），引用相应的结构成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct point* <span class="title">getStruct</span><span class="params">(struct point *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, p-&gt;x, p-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言提供一个编译时的一元运算符sizeof，可以用来<strong>计算任一对象的长度</strong>。</p><p><code>sizeof 对象</code>和<code>sizeof(类型名)</code>会返回一个整型值，等于指定对象或类型<strong>占用的存储空间字节数</strong>。</p><h3 id="类型定义-typedef"><a href="#类型定义-typedef" class="headerlink" title="类型定义 (typedef)"></a>类型定义 (typedef)</h3><p><code>typedef</code>用来<strong>建立新的 数据类型名</strong>。<br>例如，声明<code>typedef int Length;</code><br>将Length定义为与int具有同等意义的名字，Length与类型int完全相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span> &#123;</span><span class="comment">//ADate同样可以略去</span></span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125; Date; <span class="comment">//简化了复杂的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可正常构造结构后，按如下方式定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span> <span class="title">Date</span>;</span></span><br></pre></td></tr></table></figure><hr><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>C99之前无法用变量作为数组定义的大小，当时如何解决该问题？</p><p><code>malloc</code>函数：在需要时，向操作系统申请存储空间，需要<code>#include &lt;stdlib.h&gt;</code>。</p><p><code>void* malloc(size_t size);</code></p><ul><li>向malloc申请的空间的大小以字节为单位</li><li>返回的结果是<code>void*</code>，需要类型转换为需要的类型。例如<code>int *a = (int*)malloc(n*sizeof(int))</code></li></ul><p>因为程序中的某些地方可能不通过 malloc调用 申请空间，所以，<strong>malloc管理的空间不一定是连续的</strong>。</p><h3 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h3><p><code>free(a);</code><br><strong>malloc得到的空间一定要有free的习惯，只能free申请来的空间的首地址</strong></p><hr><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a><code>gets()</code></h3><p>gets()函数包含于stdio.h头文件，会一直读取用户输入，直至换行为止；而scanf一直读至空格键</p><hr><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul><li><p><code>strlen</code> 字符串长度<br><code>size_t strlen (const char *s);</code> 返回s的字符串长度，不包括结尾的0</p></li><li><p><code>strcmp</code> 比较字符串<br><code>int strcmp (const char *s1, char *s2);</code> 比较字符串的大小，返回两者 第一个不同的字符的差值</p></li><li><p><code>strncmp</code> 比较字符串</p><p><code>int strncmp (const char *s1, const char *s2, size_t n)</code> 比较字符串，<code>n</code>为比较的字符数量，若前n个字符相同，返回0 </p></li><li><p><code>strcpy</code> 复制<br><code>char* strcpy(char *restrict dst, const char *restrict src);</code> 把src的字符串复制给dst<br><strong><code>restrict</code>表明src和dst不重叠</strong>，返回dst</p><p>复制字符串的操作示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(dst,src);</span><br></pre></td></tr></table></figure><p><code>memcpy</code>复制</p><p><code>void* memcpy (void*dest, const void *src, size_t n);</code></p><p><strong>与<code>strcpy</code>相比，<code>memcpy</code>并不是遇到’\0’就结束，而是一定会拷贝完n个字节。</strong></p></li><li><p>字符串中找字符<br><code>char* strchr(const char *s, int c);</code><br><code>char* strrchr(const char *s, int c);</code><br>返回NULL表示没有找到</p></li><li><p>字符串中找字符串<br><code>char* strstr(const char *s1, const char *s2);</code><br><code>char* strcasestr(const char *s1, const char *s2); //忽略大小写 查找字符串</code> </p></li><li><p>连接字符串</p><p><code>char *strcat(char *dest, const char *restrict src);</code>将参数 src 字符串复制到参数 dest 所指的字符串尾部</p></li></ul><hr><h3 id="标准库函数-qsort排序"><a href="#标准库函数-qsort排序" class="headerlink" title="标准库函数 qsort排序"></a>标准库函数 qsort排序</h3><p>C语言有<code>qsort()</code>；C++有<code>sort()</code>；Java有<code>Arrays</code>类</p><p><code>qsort()</code>声明在stdlib.h文件中。<br><code>void qsort(void *base,size_t nelem,size_t width,int (*cmp)(const void *,const void *));</code></p><ul><li><p>base:<br>要排序的数组</p></li><li><p>nmemb:<br>数组中的元素数目</p></li><li><p>size:<br>每个数组元素占用内存空间，可使用sizeof获得</p></li><li><p>cmp:<br>比较两个数组元素的比较函数，返回值是<strong>int类型</strong>。比较函数的第一个参数值a与参数b，<strong>此函数需要自定义</strong></p><ul><li>返回值 &gt; 0, a 将被排在b后面;</li><li>返回值 &lt; 0, a 将被排在b前面;</li><li>示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123; <span class="comment">//升序</span></span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">long</span> <span class="keyword">int</span> *)b; <span class="comment">//不能用'&gt;'、'&lt;'比较符(返回无负值)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="转换字符大小写"><a href="#转换字符大小写" class="headerlink" title="转换字符大小写"></a>转换字符大小写</h3><p>函数声明在&lt;ctype.h&gt;文件中：</p><p><code>int tolower(int c)</code></p><p><code>int toupper(int c)</code></p><hr><h2 id="枚举-enumeration"><a href="#枚举-enumeration" class="headerlink" title="枚举(enumeration)"></a>枚举(enumeration)</h2><ul><li><p>枚举是用关键字<code>enum</code>来声明的一种自定义的数据类型：</p><p><code>enum 枚举类型名字 {标识符0, 标识符1, ..., 标识符n};</code></p></li><li><p>枚举类型名字<strong>第一个字母最好大写</strong>，花括号中的标识符是<strong>常量符号，只使用大写字母，类型是int，值依次从0到n</strong>。</p><p>如<code>enum Color {RED, YELLOW, GREEN};</code></p></li><li><p><strong>主要应用：当需要一些可以排列起来的常量值时，定义枚举就是为了给这些常量值名字</strong></p></li><li><p>枚举类型可以跟上<code>enum</code>作为类型：<code>void f(enum Color c);</code>；<code>Color t = RED;</code></p></li><li><p>声明枚举量的时候可以指定值：<code>enum Color {RED = 1, YELLOW, GREEN = 5, BLUE};</code></p><p><code>YELLOW</code>的值为2，<code>BLUE</code>的值为6。</p></li><li><p>不同的枚举常量可以取相同的整数值，但最好采用唯一值，有助于预防难以发现的逻辑错误。</p></li></ul><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="构造结点"><a href="#构造结点" class="headerlink" title="构造结点"></a>构造结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><h3 id="构造链表"><a href="#构造链表" class="headerlink" title="构造链表"></a>构造链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node *head;</span><br><span class="line">&#125; List;</span><br></pre></td></tr></table></figure><hr><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="全局变量初始化"><a href="#全局变量初始化" class="headerlink" title="全局变量初始化"></a>全局变量初始化</h3><ul><li><strong>没有做初始化的全局变量会得到0值</strong><ul><li>指针会得到NULL值</li></ul></li><li>只能用编译时刻已知的值来初始化全局变量</li><li>它们的初始化发生在main函数之前</li></ul><p><strong>如果函数内部存在与全局变量同名的变量，则全局变量被隐藏</strong></p><h3 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a>静态本地变量</h3><ul><li>在本地变量定义时加上<code>static</code>修饰符就成为静态本地变量，<strong>没有做初始化的静态变量会得到0值</strong></li><li><strong>当函数离开的时候，静态本地变量会继续存在并保持其值</strong></li><li>静态本地变量的初始化只在第一次进入该函数时，以后进入函数会保持上次离开的值</li></ul><p><strong>静态本地变量是特殊的全局变量</strong></p><hr><h2 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h2><ul><li><code>#</code>开头的是编译预处理指令</li></ul><h3 id="define-用来定义宏"><a href="#define-用来定义宏" class="headerlink" title="#define 用来定义宏"></a>#define 用来定义宏</h3><ul><li><code>#define &lt;名字&gt; &lt;值&gt;</code>（结尾没有分号，不是C语句）</li><li>名字必须是一个单词，值可以是各种东西</li><li>在C语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字换成值（文本替换）</li></ul><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>如果一个宏的<strong>值中有其他宏的名字</strong>，也会被替换</li><li>如果宏的值超过一行，最后一行之前的行末需要加<code>\</code></li><li>宏的值后边的注释不会被当作宏的值的一部分</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRT printf(<span class="meta-string">"%f "</span>, PI); \</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, PI2)</span><br></pre></td></tr></table></figure><h3 id="预定义的宏"><a href="#预定义的宏" class="headerlink" title="预定义的宏"></a>预定义的宏</h3><ul><li>_LINE_ ：当前行号</li><li>_FILE_ ：文件路径</li><li>_DATE_ ：日期</li><li>_TIME_ ：时间</li></ul><h3 id="带参数的宏的原则"><a href="#带参数的宏的原则" class="headerlink" title="带参数的宏的原则"></a>带参数的宏的原则</h3><ul><li><p>一切都要括号</p><ul><li>整个值要括号</li><li>参数出现的每个地方都要括号</li></ul><p>例：<code>#define RADTODEG(x) ((x)*57.29578)</code></p></li><li><p>可以带多个参数</p><p><code>#define MIN(a,b) ((a)&gt;(b)?(b):(a))</code></p></li><li><p>也可以组合（嵌套）使用其他宏</p></li></ul><h3 id="include-头文件"><a href="#include-头文件" class="headerlink" title="#include 头文件"></a>#include 头文件</h3><p>将included的文件的全部内容原封不动d地插入到所在位置，因此也不一定要在.c文件最前面<code>#include</code></p><ul><li><code>#include &quot;xxx.h&quot;</code> （要求编译器首先在当前目录寻找该文件，如果没有，到编译器指定目录去找）</li><li><code>#include &lt;xxx.h&gt;</code> （让编译器只在指定目录寻找）</li></ul><p>把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中<code>#include</code>这个头文件，就能让编译器在编译的时候知道函数的原型。<code>#include</code>和宏一样在是编译预处理指令。</p><p><strong><code>#include</code>不是用来引入库的</strong>，<code>stdio.h</code>中只有printf等函数的原型，用来保证调用时给出的参数值是正确的类型。printf的代码在另外的地方，某个.lib（Windows）或.a（Unix）中。现在的C语言编译器默认会引入所有的标准库。</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul><li>在使用和定义这个函数的地方都应该<code>#include</code>这个头文件</li><li>一般的做法是任何.c文件都有对应同名的.h文件，把所有对外公开的函数原型和全局变量的声明放进去</li></ul><h3 id="不对外公开的函数"><a href="#不对外公开的函数" class="headerlink" title="不对外公开的函数"></a>不对外公开的函数</h3><ul><li>在函数前加上<code>static</code>使其成为只能在<strong>所在编译单元中</strong>被使用的函数</li><li>在全局变量前面加上<code>static</code>使其成为只能在<strong>所在编译单元中</strong>被使用的全局变量</li></ul><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><ul><li><code>int i;</code>是变量的定义（产生代码）</li><li><code>extern int i;</code>是变量的声明（不产生代码）</li></ul><h3 id="标准头文件结构"><a href="#标准头文件结构" class="headerlink" title="标准头文件结构"></a>标准头文件结构</h3><ul><li><p>运用条件编译和宏，保证这个头文件在一个编译单元中只会被<code>#include</code>一次</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LIST_HEAD__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIST_HEAD__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"node.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span> &#123;</span></span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p><code>%[flags][width][.prec][hlL]type</code></p><ul><li>Flag</li></ul><table><thead><tr><th>Flag</th><th>含义</th></tr></thead><tbody><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>强制显示符号（正数会显示+）</td></tr><tr><td>(space)</td><td>正数留空</td></tr><tr><td>0</td><td>0填充</td></tr></tbody></table><ul><li>width</li></ul><table><thead><tr><th>width或prec</th><th>含义</th></tr></thead><tbody><tr><td>number</td><td>最小字符数（总长，包括小数点后的位数）</td></tr><tr><td>*</td><td>下一个参数是字符数，例：<code>printf(&quot;%*d, 6, 123&quot;);</code></td></tr><tr><td>.number</td><td>小数点后的位数</td></tr><tr><td>.*</td><td>下一个参数是小数点后的位数</td></tr></tbody></table><ul><li>hlL</li></ul><table><thead><tr><th>hlL（类型修饰）</th><th>含义</th></tr></thead><tbody><tr><td>hh</td><td>单个字节</td></tr><tr><td>h</td><td>short</td></tr><tr><td>l</td><td>long</td></tr><tr><td>ll</td><td>long long</td></tr><tr><td>L</td><td>long double</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th>type</th><th>用于</th></tr></thead><tbody><tr><td>i 或 d</td><td>int</td></tr><tr><td>u</td><td>unsigned int</td></tr><tr><td>o</td><td>八进制</td></tr><tr><td>x</td><td>十六进制</td></tr><tr><td>X</td><td>字母大写的十六进制</td></tr><tr><td>f 或 F</td><td>float</td></tr><tr><td>e 或 E</td><td>指数</td></tr><tr><td>g</td><td>float</td></tr><tr><td>G</td><td>float</td></tr><tr><td>a 或 A</td><td>十六进制浮点数</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>n</td><td>读入/写出的个数</td></tr></tbody></table><h3 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h3><p><code>%[flag]type</code></p><ul><li>flag</li></ul><table><thead><tr><th>flag</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>跳过</td></tr><tr><td>数字</td><td>最大字符数</td></tr><tr><td>hh</td><td>char</td></tr><tr><td>h</td><td>short</td></tr><tr><td>l</td><td>long, double</td></tr><tr><td>ll</td><td>long long</td></tr><tr><td>L</td><td>long double</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>int</td></tr><tr><td>i</td><td>整数，也可以是16进制、8进制</td></tr><tr><td>u</td><td>unsigned int</td></tr><tr><td>o</td><td>8进制</td></tr><tr><td>x</td><td>16进制</td></tr><tr><td>a, e, f, g</td><td>float</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>[…]</td><td>允许的字符（例：<code>*[^,]</code>是到<code>,</code>之前的所有字符都跳过）</td></tr><tr><td>p</td><td>指针</td></tr></tbody></table><hr><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h3><ul><li><p><code>&amp;</code> 与</p><p>相同位上都为1，结果为1；否则结果为0</p></li><li><p><code>|</code> 或</p><p>相同位上至少一个是1，结果为1；否则结果为0</p></li><li><p><code>~</code> 取反</p><p>把1位变0，0位变1</p></li><li><p><code>^</code> 异或</p><p>如果两个位相等，结果为0；两个位不相等，结果为1。</p><p>对一个变量用同一个值异或两次，变量不变（可用于加密）</p></li></ul><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul><li><p><code>&lt;&lt;</code> 左移</p><ul><li><p><code>i &lt;&lt; j</code>：i中所有的位向左移动j个位置，<strong>右边填入0</strong></p></li><li><p><code>x &lt;&lt;= n</code> 等价于x *= $2^n$</p></li></ul></li><li><p><code>&gt;&gt;</code> 右移</p><ul><li><code>i &gt;&gt; j</code>：i中所有的位向右移j个位置。unsigned类型，左边填入0；signed类型，左边填入原来的最高位</li><li><code>x &gt;&gt;= n</code> 等价于x /= $2^n$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下的一些终端操作</title>
      <link href="/2018/06/27/Ubuntu%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/27/Ubuntu%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="终端界面的说明"><a href="#终端界面的说明" class="headerlink" title="终端界面的说明"></a>终端界面的说明</h2><p>示例：<br><code>hunter@Hunter-PC:~$</code></p><ul><li>最左侧的<code>hunter</code>是<strong>目前用户的账号</strong></li><li>@之后的<code>Hunter-PC</code>是<strong>主机名</strong></li><li><code>~</code>是<strong>目前所在目录</strong>；<code>~</code>为<strong>当前用户的home目录</strong></li><li><code>$</code>是<strong>提示字符</strong>；root的提示符为<code>#</code>，普通用户为<code>$</code></li></ul><p>登录后取得的程序被称为<code>Shell</code>(壳，因为该程序负责最外面跟使用者沟通，被戏称称为壳程序）</p><p>在Linux下平常<strong>最好使用一般账号来登录</strong>，需要动用到系统功能修订时，再使用root。</p><hr><h2 id="操作说明及技巧"><a href="#操作说明及技巧" class="headerlink" title="操作说明及技巧"></a>操作说明及技巧</h2><p><strong>Linux严格区分大小写</strong>。</p><p>在指令列模式里面下达指令时，会有两种主要的情况：</p><ul><li>直接显示结果，然后回到命令提示字符，等待下一个指令的输入</li><li>进入到该指令的环境，直到结束该指令，回到命令提示字符的环境</li></ul><hr><ul><li>指令太长的时候，可以使用<code>\</code>使指令连续到下一行。<code>\</code>后需要立刻接<br><strong>回车</strong>，才能跳脱！</li></ul><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + Alt + T</td><td>打开终端</td></tr><tr><td>Shift + Ctrl + C/V</td><td>复制/粘贴</td></tr></tbody></table><hr><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><p><strong>Linux命令中，参数一般是无序的，特殊情况除外</strong>。</p><h3 id="更新系统文件"><a href="#更新系统文件" class="headerlink" title="更新系统文件"></a>更新系统文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p><code>sudo apt-get install xxx（程序名）</code></p><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><ul><li><p><code>sudo apt-get remove -purge xxx(程序名)</code></p></li><li><p><code>sudo apt autoremove</code></p></li></ul><h3 id="磁盘管理命令"><a href="#磁盘管理命令" class="headerlink" title="磁盘管理命令"></a>磁盘管理命令</h3><ul><li><p>注销Linux：<code>exit</code>(Linux本身还在运行，只是退出了登录的操作)</p></li><li><p>语系</p><ul><li>显示目前支持的语系：<br>  <code>locale</code></li><li><p>修改语系：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.utf8</span><br><span class="line">export LC_ALL=en_US.utf8</span><br></pre></td></tr></table></figure><p>LANG只与<strong>输出讯息</strong>有关，若需要更改其他不同的信息，要同步更新<code>LC_ALL</code>。</p></li></ul></li><li><p>显示日期：<code>date</code></p></li><li><p>计算器：<code>bc</code>(win10的ubuntu子系统需要先安装)<br>  事实上，该操作是<strong>进入到<code>bc</code>这个软件的工作环境</strong>。<br>  　　<code>bc</code>预设仅<strong>输出整数</strong>，如果要输出小数，需要先执行<code>scale=number</code>，<code>number</code>是小数点位数</p><ul><li>要离开<code>bc</code>，需要输入<code>quit</code>命令</li></ul></li><li><p>转换成root用户：<code>sudo su</code></p></li><li><p>展示文件和目录：<code>ls</code></p><ul><li><code>-a/--all</code> 展示当前目录下<strong>所有文件和目录</strong>（隐藏文件和特殊目录以<code>.</code>开头）</li><li><code>-l</code> 查询详细列表(可以组合使用<code>-al</code>)</li><li><code>-h</code> 友好展示信息<br><code>ls -l</code>可以简写为<code>ll</code></li></ul></li><li><p>切换目录：<code>cd</code></p><ul><li><code>~</code> 当前用户的家目录</li><li><code>/</code> 根目录</li><li><code>-</code> 切换到上次访问的目录</li></ul></li><li><p>显示当前所在目录：<code>pwd</code>(print working directory)</p></li><li><p>创建目录：<code>mkdir</code></p><ul><li><code>-p</code>(parents) 父目录不存在的情况下，生成父目录</li><li><code>-v</code> 显示命令执行过程中的详细信息</li></ul></li><li><p>删除<strong>空</strong>目录：<code>rmdir</code></p></li></ul><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><ul><li><p>快捷查看当前文件的内容：<code>cat</code>，<strong>适合查看少量信息的文件</strong></p></li><li><p>分页显示内容，标注每行的行号：<code>less -mN</code>(<strong>适用于大量数据的查看</strong>)</p><ul><li><code>回车</code> 向下n行（需要定义，默认为1行）</li><li><code>空格</code> 向下一页</li><li><code>b</code> 向上一页</li><li><code>q</code> 退出</li></ul></li><li><p>快速查看文件后n行的内容：<code>tail -n</code>(<strong>查看日志</strong>)</p></li><li><p>复制文件/目录：<code>cp 需要复制的文件 复制的位置</code></p><ul><li><code>-r/--recursive</code> 递归处理，将指定目录下的子目录一并处理<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求：把/root/Demo.java 文件复制到 /root/t1 目录中，改名为d.java</span><br><span class="line">位置：root</span><br><span class="line">命令：cp Demo.java t1/d.java</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>文件移动：<code>mv 需要移动的文件 移动的位置</code></p><ul><li><code>-f</code> 强制性覆盖</li><li><strong>文件/目录重命名操作</strong>：<code>mv 原文件 新文件名</code>（原文件名即转换为新文件名）</li></ul></li><li><p>文件/目录删除：</p><ul><li><code>rm 文件名</code><ul><li><code>-f/--force</code> 强制删除</li><li><code>-r/--recursive</code> 递归处理，将指定目录下的子目录一并处理</li></ul></li><li><code>rm -rf 目录</code></li></ul></li><li><p>查找文件或目录：<code>find [目录名] -name &#39;需要查找的字符串&#39;</code>（不填写目录名则在当前目录下查找）</p></li><li><p>压缩、解压命令：<code>tar</code></p><ul><li><code>-c</code> 建立一个压缩文件(create)</li><li><code>-x</code> 解开一个压缩文件(extract)</li><li><code>-z</code> 用gzip压缩</li><li><code>-v</code> 压缩过程中显示文件(verbose)</li><li><code>-f</code> 使用档名，在f之后要接档名(file)</li></ul></li></ul><p>Linux的压缩包格式：<code>*.tar</code>(打包不压缩)、<code>*.tar.gz</code>(打包并压缩文件大小)</p><pre><code>- 压缩：`tar -zcvf 压缩包名.tar.gz 需要压缩的内容`例如`tar -zcvf test.tar.gz *`(将当前目录下内容进行打包压缩)- 解压：`tar -zxvf 需要解压的压缩包名.tar.gz [-C 指定解压路径]`</code></pre><h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><ul><li><p>查看系统进程：<code>ps -ef</code>(Process Status) 同时会显示执行ps命令的进程信息<br>示例：<code>ps -ef | grep -i vim</code> 查看vim相关的进程</p></li><li><p>强制结束进程：<code>kill -9 pid号</code></p></li><li><p>显示网络设备：<code>ifconfig</code></p></li><li>测试和目标的连通性：<code>ping ip地址</code></li></ul><h3 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h3><ul><li>权限更改：<code>chmod 权限设置 需要更改权限的文件</code><ul><li><code>-R/--recursive</code> 递归处理<br>示例：</li><li>更改所属用户(user)的权限：<code>chmod u=rwx test.txt</code></li><li>更改所属组(group)的权限：<code>chmod g=rx test.txt</code></li><li>更改其他用户(other)的权限：<code>chmod o=rx test.txt</code></li><li>更改所有用户(all)的权限：<code>chmod a=r test.txt</code></li></ul></li></ul><hr><h2 id="几个重要的热键"><a href="#几个重要的热键" class="headerlink" title="几个重要的热键"></a>几个重要的热键</h2><ul><li><p><code>Tab</code><br><code>Tab</code>具有<strong>命令补全</strong>和<strong>文件补齐</strong>的功能，<strong>可以避免打错指令或文件名</strong>。</p><ul><li><code>Tab</code>接在一串指令的第一个字的后面，则为<strong>命令补全</strong></li><li><code>Tab</code>接在一串指令的第二个字以后时，则为<strong>文件补齐</strong></li></ul></li><li><p><code>Ctrl + c</code>：中断目前程序</p></li><li><p><code>Ctrl + d</code>: 键盘输入结束；也可以用来取代<code>exit</code>的输入</p></li><li><p><code>Ctrl + PgUp/PgDown</code>：翻页（指令执行后，显示的内容很长时可以用到）</p></li></ul><hr><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><h3 id="指令名后加上-help"><a href="#指令名后加上-help" class="headerlink" title="指令名后加上--help"></a>指令名后加上<code>--help</code></h3><p>即可查看指令的用法，如<code>cal --help</code>。</p><h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>　　<code>man</code>是<code>manual</code>(操作说明)的简写，通过<code>man 指令名</code>进入的画面，就是<code>man page</code>。</p><p><strong>man page下</strong>能使用的相关操作：  </p><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PgDn</td><td>向下翻一页</td></tr><tr><td>PgUp</td><td>向上翻一页</td></tr><tr><td>Home</td><td>去到第一页</td></tr><tr><td>End</td><td>去到最后一页</td></tr><tr><td><code>/string</code></td><td>向<strong>下</strong>搜寻string这个字符串，如果要搜寻vbird 的话，就输入/vbird</td></tr><tr><td><code>?string</code></td><td>向<strong>上</strong>搜寻string 这个字符串</td></tr><tr><td><code>n, N</code></td><td>利用<code>/</code>或<code>?</code>来查找字符串时，可以用<code>n</code>来继续下一个查找，利用<code>N</code>来进</td></tr></tbody></table><p>行<strong>反向查找</strong> |<br>| q | 结束这次的man page |</p><hr><p>示例（<code>man date</code>）:<br><img src="https://i.loli.net/2019/03/28/5c9c99ef62fbb.png" alt="man date操作之后的页面"></p><p>在页面第一行，可以看到<code>DATE(1)</code>，<code>DATE</code>是指令名称，<code>(1)</code>代表<strong>一般用户可使用的指令</strong>。</p><table><thead><tr><th style="text-align:right">代号</th><th>代表内容</th></tr></thead><tbody><tr><td style="text-align:right">1</td><td>用户在shell 环境中可以操作的指令或可执行文件</td></tr><tr><td style="text-align:right">2</td><td>系统核心可呼叫的函数与工具等</td></tr><tr><td style="text-align:right">3</td><td>一些常用的函数(function)与函式库(library)，大部分为C 的函式库(libc)</td></tr><tr><td style="text-align:right">4</td><td>装置文件的说明，通常在/dev 下的文件</td></tr><tr><td style="text-align:right">5</td><td>配置文件或者是某些文件的格式</td></tr><tr><td style="text-align:right">6</td><td>游戏(games)</td></tr><tr><td style="text-align:right">7</td><td>惯例与协议等，例如Linux 文件系统、网络协议、ASCII code 等等的说明</td></tr><tr><td style="text-align:right">8</td><td>系统管理员可用的管理指令</td></tr><tr><td style="text-align:right">9</td><td>跟kernel 有关的文件</td></tr></tbody></table><hr><p><code>man page</code>大致分成以下几个部分：</p><table><thead><tr><th>代号</th><th>内容说明</th></tr></thead><tbody><tr><td>NAME</td><td>简短的指令、数据名称说明</td></tr><tr><td>SYNOPSIS</td><td>简短的指令下达语法(syntax)简介</td></tr><tr><td>DESCRIPTION</td><td>较为完整的说明，这部分最好仔细看看！</td></tr><tr><td>OPTIONS</td><td>针对SYNOPSIS 部分中，有列举的所有可用的选项说明</td></tr><tr><td>COMMANDS</td><td>当这个程序(软件)在执行的时候，可以在此程序(软件)中下达的指令</td></tr><tr><td>FILES</td><td>这个程序或数据所使用或参考或连结到的某些文件</td></tr><tr><td>SEE ALSO</td><td>可以参考的，跟这个指令或数据有相关的其他说明！</td></tr><tr><td>EXAMPLE</td><td>一些可以参考的范例</td></tr></tbody></table><p>在查询某个数据时可以这样来查阅：</p><ol><li>先察看NAME的项目，看一下这个资料的意思</li><li>再详看一下DESCRIPTION，这个部分会提到很多相关的资料与使用时机，从这个地方可以学到很多小细节</li><li>如果这个指令已经很熟悉了，主要就是查询关于OPTIONS的部分，可以知道每个选项的意义，可以下达比较细部的指令内容</li><li>最后再看一下，跟这个资料有关的还有哪些东西可以使用。举例来说，date的<code>SEE ALSO</code>就告知我们还可以利用<code>info coreutils date</code>来进一步查阅数据；</li><li>某些说明内容还会列举有关的文件(FILES部分)来提供我们参考！这些都是很有帮助的！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据请求的具体扩展名、请求头不同，返回不同格式的相同内容</title>
      <link href="/2018/06/14/%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A9%E5%B1%95%E5%90%8D%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E5%86%85%E5%AE%B9/"/>
      <url>/2018/06/14/%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A9%E5%B1%95%E5%90%8D%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="内容协商多视图"><a href="#内容协商多视图" class="headerlink" title="内容协商多视图"></a>内容协商多视图</h2><p><a href="https://blog.csdn.net/yu412346928/article/details/20637439" target="_blank" rel="noopener">SpringMVC配置多视图-内容协商原理</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><a href="https://junq.io/spring-mvc%E5%AE%9E%E7%8E%B0http%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86-content-negotiation.html" target="_blank" rel="noopener">Spring MVC三种方式实现HTTP内容协商(Content Negotiation)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
          <category> Spring MVC </category>
          
          <category> 视图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视图 </tag>
            
            <tag> ContentNegotiatingViewResolver </tag>
            
            <tag> contentNegotiationManager </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
